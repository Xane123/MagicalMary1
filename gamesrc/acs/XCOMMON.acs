//Common code for use in all levels.
#library "xglobal"
#include "zcommon.acs"

//WARNING: There's a limit of 128 variables outside of script scope per file!
//XCOMMON, due to how messy of a big file it is, has used 102/128 variables, with 26 left! Use them wisely!
//This number may be out of date and it may be closer to the limit than this states.

#define MAX_PLAYERS 8	//Maximum number of players, used for multiplayer, in case this ever is ported to Zandronum.

//User keys: USER1 = Transform into super form, USER2 = Warp to Small Hut, USER3 = Restart run in other modes, USER4 = Empty

#define TIME_PLAY 0
#define TIME_PAUSE 1
#define TIME_STOP -1

//WORLD variables are only valid until the next level. Special Stages and the Small Hut don't reset them. Use these to let level scripts interact with global script variables.
world int 0:ltime_control;	//Whether the timer should move as normal, pause, or stop for the rest of the level.
world int 2:ss_number;	//Whsat number this Special Stage is. Try to replace with LEVELINFO_SPECSTGNO.
world int 3:initial_music;	//This is set by areas and determines what music it will play initially.
world int 4:world_info[];	//This holds the world number ([0]) and level number within that world ([1]) to form things like "1-1".

world int 5:ss_returnlevel;	//What level to return to on request by certain scripts.
world int 6:movement[];	//Movement registering; They come in the order forward, backward, left, right. 1 = low amount, 2= big amount. Increase by MAX_PlAYERS+PlayerNumber as with other scripts.
world int 7:movesky[];	//[0] is horizontal skybox movement while [1] is vertical.
world int 8:framecount;	//Current frame; Use for waiting for certain frames to do something.

world bool 9:level_ready;	//This prevents certain scripts from working until it's set to TRUE by SeamlessHelper.

world int 10:ss_return_id;	//The checkpoint ID that the player will respawn from upon returning from a special stage.
world int 11:OpenInput[];	//Curent player input; 0-7 = Current, 8-15 = Previous.
world int 12:fadeout;	//The requested fade out during areas. Fade may seem redundant, try to remove it.
world int 13:last_ground_position[];	//The last XYZ coordinates each player was detected to be on the ground at. [PlayerNumber()] = X, [MAX_PLAYERS+PlayerNumber()] = Y, [MAX_PLAYERS*2+PlayerNumber()] = Z, [MAX_PLAYERS*3+P)] = Angle. [MAX_PLAYERS*4+PlayerNumber()] is supposedly used for jump-through platforms.

//GLOBAL variables are always valid, no matter how many levels the player goes through.
global int 2:score[];
global int 3:cgem_count;	//Chaos Bridges count
global int 4:ss_position;	//Return map position for special stages. The player will be teleported to 1100 * (this + 1) + PlayerNumber().
//global bool 5:dialogue_completed[];	//See DIALOGUE.acs for this global variable.
global bool 6:fade;	//Requested fade upon level transition.
global int 7:completed_levels[];  //[0] increases as a counter; Any other array index is each level's completed percentage. 100% = completed.
#define MAX_LEVELS 4 	//Not to be confused with TRANSITION_LEVELS or whatever, this is the max number of levels that completed levels will include. This doesn't include the counter, so increase by 1 when storing.
global int 8:curscore[];

global int 9:disablewind[];	//If non-zero, wind stops affecting this player. Only increase or decrease this variable, never forcibly set it.

//Global variables #12-#14 are available.

global int 15:combo[];	//Current combo (successive kills). First MAX_PLAYERS is current, while second are decrease amounts.
global int 16:lives;

global int 17:seconds[];	//The timer is global to allow the planned other modes to work.
global int 18:timer_tics;	//Used for the speedrunning timer's "milliseconds".

//Global variable #0 is available!

global bool 19:challenge_status[];	//Indicates if a challenge for a level is completed, marking it in the interface when selecting levels. There's only one per level, so each index is the level number - 1.

global int 20:level[];	//Level number; [0] is highest level reached, [1] is last level played, and [2] is the last #-1 (start of world) level visited (used for Game Over script).

global int 21:stored_velocity[];	//Used for hackish teleporting to and from the Small Hut ([0]). Unknown about its other purposes.

global bool 22:no_scripts[];	//Tells most standard scripts like special abilities not to run.
global bool 23:important_fade[];		//If an important fade (like dying or a transition) is happening, set this to TRUE.
global int 24:meter[];		//Time before the current combo level is lost.
global int 25:gamemode;	//0: Normal, 1: Time attack, 2: Boss rush, 3: Practice, 4: Wave-based battle
global bool 26:event_completed[];	//Whether the FMV with this ID has run. It will be skipped if TRUE.
global int 27:upgrades[];	//Upgrades; 0: Hammer upgrades, 1: Max coins, 2: Umbrella, 3: Sword (Xane). This is synced between all players. Sword upgrades are planned.
global bool 28:special_id[];	//An array determining whether a player picked up a special item or entered a certain special stage entrance. See the line below this one for the current highest ID.
//The highest current special ID is 3.

//global bool 29:tutorial_completed[];	//See TUTORIAL.acs for this global variable.
//Global variable #30 is available!
global int 31:total_coins;	//How many coins the player has collected to be spent.

//Powerup Coin tics; This stores how many tics for each coin are remaining for each player.
global int 32:damage_tics[];	//Increases damage done by weapons if supported.
global int 33:heal_tics[];		//Slowly heals the player.
global int 34:ninja_tics[];		//Allows the player to stick to walls and control their movement.
global int 35:water_tics[];		//Disables drowning. May also prevent lava damage in the future.
global int 36:combo_tics[];		//Maintains the player's current combo for however long a Combo Coin is active.
global int 37:speed_tics[];		//Speeds the player up.

#define CONSTANT_TCOINDISPTICS 135	//How many tics the total coins counter should be displayed for.
int totalcointics = CONSTANT_TCOINDISPTICS;	//Number of tics to show the player's total coins for.

#define CONSTANT_SCOIN_REQ 50	//Required coins to transform.
#define CONSTANT_SCOIN_DEC 25	//Number of tics to wait inbetween each coin removal/check to remove super.
#define CONSTANT_1UP_SCORE 10000	//Score required to get an extra life.
#define CONSTANT_1UP_PRIZE_SCORE 500	//Score awarded if 1UP is awarded but the player has 9 lives.
#define CONSTANT_1UP_INITIAL 3	//Players' starting lives
#define CONSTANT_1UP_100PERCENT_INITIAL 2	//First 100%'s extra lives awarded.
#define CONSTANT_1UP_100PERCENT_INC 2	//Second/third 100%s' extra life awards, added to the above.

#define CONST_MAXUPGRADES_HAMMER 4	//Maximum number of hammer upgrades.
#define CONST_MAXUPGRADES_UMBRELLA 2	//Maximum number of umbrella upgrades.
#define CONST_MAXUPGRADES_SWORD 2	//Maximum number of sword upgrades for Xane's Sword.
#define CONSTANT_COIN_METERINC 5	//Amount combo meter increases with each collected coin.

#define CONSTANT_BOUNCE_TICS 10	//How many tics the player can avoid bouncing for when landing after pushing the back button.
#define CONST_MAXCOIN_INCAMOUNT 5	//How much the coin limit will raise with each upgrade collected.
#define CONST_BOOST_TICS 10	//How many tics a boost panel pushes the player.

#define CONST_SECS_NINJA 30
#define CONST_SECS_WATER 25
#define CONST_SECS_DAMAGE 30
#define CONST_SECS_HEAL 25
#define CONST_SECS_COMBO 20
#define CONST_SECS_SPEED 25

#define CONST_TRANS_LEVELS_START 200	//Maximum "normal" levels. Levels higher than this are used for "transition" levels. (See the map TMP1 for an example.)

bool on_ground[MAX_PLAYERS];	//If the player's on the ground; Used for object-based platforms.

int cdrop_delay[MAX_PLAYERS];
bool spring[MAX_PLAYERS];
int OldVelZ[MAX_PLAYERS];
bool cancelJump[MAX_PLAYERS];
//bool transformed[MAX_PLAYERS];	//Whether a player's "morphed" into their super form. For checking if the player is super, check inventory for SuperX.

int rain_mode[MAX_PLAYERS];

bool spawns[10] = { false, false, false, false, false, false, false, false, false, false };
bool no_variable_jumping[MAX_PLAYERS];
bool forcenormal[MAX_PLAYERS];	//Force non-super speed/friction. Confirm if used and consider change to speed multipliers.
bool force_death[MAX_PLAYERS];			//Forcibly kills the player without taking their health away.
bool force_detransform[MAX_PLAYERS];	//Forcibly detransforms the player if they are transformed.

#define C_TID		1050	//Default camera tid
#define MAX_R		80	//Maximum radius (or distance from the player)
#define ADJUST_R	8	//Amount to adjust the camera by
#define VIEW_HEIGHT	41.0	//The approximate height of the player's view

		int a[MAX_PLAYERS];
		int p = 0;
		int mmx[MAX_PLAYERS];
		int y[MAX_PLAYERS];
		int z[MAX_PLAYERS];
          int r = MAX_R;
		int xyr;

bool tp_to_last_ground_position[MAX_PLAYERS];	//If this is set for a specific player, they will teleport to their last ground position after reloading from a checkpoint.

script "SetMode" (int mode) { gamemode = mode; }
script "SetCoins" (int number, int mode) { If(mode==FALSE) total_coins = number; Else total_coins += number; }
script "SetSSPosition" (int number) { if(ss_position<0) ss_position = 0; if(ss_position>3) ss_position = 3; ss_position= number; }
script "SetFadeOut" (int number) { if(number<0) number = 0; if(number>7) number = 7; fadeout = number; }
script "DisplayTotalCoins" (int amount)
{
	If(amount==0) totalcointics = CONSTANT_TCOINDISPTICS;
	Else If(amount<0) totalcointics = CONSTANT_TCOINDISPTICS * abs(amount);
	Else totalcointics = amount;
}

script "StoreValues" UNLOADING	//This temporarily stores the players' scores and velocities.
{
curscore[0] = score[0];
curscore[1] = score[1];
curscore[2] = score[2];
curscore[3] = score[3];
curscore[4] = score[4];
curscore[5] = score[5];
curscore[6] = score[6];
curscore[7] = score[7];

If(GameType()==GAME_NET_DEATHMATCH||GameType()==GAME_TITLE_MAP||GetLevelInfo(LEVELINFO_LEVELNUM)>=CONST_TRANS_LEVELS_START) Terminate;
}

script "HammerSlam" (void)
{
	int initial = GetActorZ(0);
	
	Until(GetActorZ(0)-GetActorFloorZ(0)<8.5||GetActorVelZ(0)==0.0||GetActorProperty(0, APROP_Health)==0) Delay(1);
	if(GetActorProperty(0, APROP_Health)==1||force_death[PlayerNumber()]==TRUE) { GiveInventory("MaryHammer_MidAirDone",1); Terminate; }	//If Mary died, don't do the slam!
	
	if(((initial - GetActorZ(0))/96) >> 16 > 0) GiveInventory("Hammer_SlamDamage",((initial - GetActorZ(0))/96) >> 16);
	else GiveInventory("Hammer_SlamDamage",1);
}

//Interaction scripts

script "GetLevel" (int which) { SetResultValue(level[which]); }

//"Circle" scripts

//Spawn coins surrounding the calling actor. Arg[2]: 0 = 360, 1 = 90, 2 = 180.

int cgem_dist = 16;

script "SpawnCoinCircle" (int number, int radius, int degree_mod)
{
int angle;
int number_abs = abs(number);

angle = GetActorAngle(0);
angle += 0.5;

	If(number_abs==0||radius==0) { Log(s:"A coin circle spawner didn't specify its settings."); Terminate; }
	
	if(degree_mod==0) number_abs++;
	If(degree_mod==1) number_abs = number_abs * 4;
	If(degree_mod==2) number_abs = number_abs * 2;
	
	For(int numberscc = 1; numberscc < number_abs /*+ 1*/; numberscc++)
	{
		if(degree_mod==1 && numberscc==1)	//90 degrees
		{
			numberscc = (number_abs/2)+(number_abs/4);
			angle += (0.25/2);
		}
		if(degree_mod==2 && numberscc==1)	//180 degrees
		{
			numberscc = (number_abs/2);
		}

		/*If(number<0) */SpawnForced("CoinSpawner_Gravity",GetActorX(0)+sin(angle+(FixedDiv(1,number_abs)) * numberscc) * radius, GetActorY(0)+cos(angle+(FixedDiv(1,number_abs)) * numberscc) * radius,GetActorZ(0));
		//Else SpawnForced("CoinX",GetActorX(0)+sin(angle+(FixedDiv(1,number_abs)) * numberscc) * radius, GetActorY(0)+cos(angle+(FixedDiv(1,number_abs)) * numberscc) * radius,GetActorZ(0));
	}

}

bool limit_effects = FALSE;

Script "SpawnCGems" (void)
{
int i, loc1 = UniqueTID(930,999), loc2 = UniqueTID(940,999), loc3 = UniqueTID(950,999), loc4 = UniqueTID(960,999), loc5 = UniqueTID(970,999), loc6 = UniqueTID(980,999), loc7 = UniqueTID(990,999);
ACS_NamedExecuteAlways("MoveCGems",0,0,0,0);

SpawnForced("CGem1", 0, 0, 0, loc1);
SpawnForced("CGem2", 0, 0, 0, loc2);
SpawnForced("CGem3", 0, 0, 0, loc3);
SpawnForced("CGem4", 0, 0, 0, loc4);
SpawnForced("CGem5", 0, 0, 0, loc5);
SpawnForced("CGem6", 0, 0, 0, loc6);
SpawnForced("CGem7", 0, 0, 0, loc7);

/*SetActorState(loc1, "FadeIn", TRUE);
SetActorState(loc2, "FadeIn", TRUE);
SetActorState(loc3, "FadeIn", TRUE);
SetActorState(loc4, "FadeIn", TRUE);
SetActorState(loc5, "FadeIn", TRUE);
SetActorState(loc6, "FadeIn", TRUE);
SetActorState(loc7, "FadeIn", TRUE);*/

int cgem_timer = 76;
While(cgem_timer>0)
{
cgem_timer--;
Delay(1);

i += 0.05 - cgem_dist/32;

SetActorProperty(loc1, APROP_Alpha, 1.0);
SetActorProperty(loc2, APROP_Alpha, 1.0);
SetActorProperty(loc3, APROP_Alpha, 1.0);
SetActorProperty(loc4, APROP_Alpha, 1.0);
SetActorProperty(loc5, APROP_Alpha, 1.0);
SetActorProperty(loc6, APROP_Alpha, 1.0);
SetActorProperty(loc7, APROP_Alpha, 1.0);

If(SetActorPosition(loc1, GetActorX(0)+(sin(i)*cgem_dist), GetActorY(0)+(cos(i)*cgem_dist), GetActorZ(0)+32.0, FALSE)==FALSE) SetActorProperty(loc1, APROP_Alpha, 0.0);
If(SetActorPosition(loc2, GetActorX(0)+(sin(i+0.14)*cgem_dist), GetActorY(0)+(cos(i+0.14)*cgem_dist), GetActorZ(0)+32.0, FALSE)==FALSE) SetActorProperty(loc2, APROP_Alpha, 0.0);
If(SetActorPosition(loc3, GetActorX(0)+(sin(i+0.28)*cgem_dist), GetActorY(0)+(cos(i+0.28)*cgem_dist), GetActorZ(0)+32.0, FALSE)==FALSE) SetActorProperty(loc3, APROP_Alpha, 0.0);
If(SetActorPosition(loc4, GetActorX(0)+(sin(i+0.42)*cgem_dist), GetActorY(0)+(cos(i+0.42)*cgem_dist), GetActorZ(0)+32.0, FALSE)==FALSE) SetActorProperty(loc4, APROP_Alpha, 0.0);
If(SetActorPosition(loc5, GetActorX(0)+(sin(i+0.56)*cgem_dist), GetActorY(0)+(cos(i+0.56)*cgem_dist), GetActorZ(0)+32.0, FALSE)==FALSE) SetActorProperty(loc5, APROP_Alpha, 0.0);
If(SetActorPosition(loc6, GetActorX(0)+(sin(i+0.7)*cgem_dist), GetActorY(0)+(cos(i+0.7)*cgem_dist), GetActorZ(0)+32.0, FALSE)==FALSE) SetActorProperty(loc6, APROP_Alpha, 0.0);
If(SetActorPosition(loc7, GetActorX(0)+(sin(i+0.84)*cgem_dist), GetActorY(0)+(cos(i+0.84)*cgem_dist), GetActorZ(0)+32.0, FALSE)==FALSE) SetActorProperty(loc7, APROP_Alpha, 0.0);

}
//After spinning around for a bit, disappear!
Thing_Remove(loc1);
Thing_Remove(loc2);
Thing_Remove(loc3);
Thing_Remove(loc4);
Thing_Remove(loc5);
Thing_Remove(loc6);
Thing_Remove(loc7);
}

script "MoveCGems" (void)
{
	cgem_dist = 160;
	While(cgem_dist>32) { cgem_dist -= 6; Delay(1); } Delay(3);
	While(cgem_dist<48) { cgem_dist += 2; Delay(1); } Delay(2);
	While(cgem_dist>24) { cgem_dist -= 2; Delay(1); } Delay(1);
	While(cgem_dist<512) { cgem_dist += 7; Delay(1); }
}

script "SpawnShockwave" (int distance)
{
	int speed = distance / 12;	//Initial speed of shockwave, slowed down after a bit.
	
	//Print(d:CheckActorInventory(1000, "Hammer_SlamDamage"));
	
	For(int sw_distance = 0; sw_distance <= distance; sw_distance += speed)
	{
		ACS_NamedExecuteAlways("SpawnSWCircle",0,sw_distance,0,0);
		if(speed>70) speed -= 4;
		else if(speed>50) speed -= 3;
		else if(speed>30) speed -= 2;
		else speed--;
		Delay(1);
	}
}

script "SpawnSWCircle" (int radius)
{
int angle;
int number = 25;
bool degree_mod = false;

if(GameType()==GAME_SINGLE_PLAYER) degree_mod = TRUE;	//If singleplayer, only render in front of the player.

if(limit_effects==TRUE||PlayerCount()>2) number = 8;	//Reduce shockwave detail if it is needed.

angle = 0;//GetActorAngle(0);
angle += 0.5;
	
	number++;
	
	For(int numberscc = 1; numberscc < number /*+ 1*/; numberscc++)
	{
		SpawnForced("Shockwave",GetActorX(0)+sin(angle+(FixedDiv(1,number)) * numberscc) * radius, GetActorY(0)+cos(angle+(FixedDiv(1,number)) * numberscc) * radius,GetActorFloorZ(0)-32.0);
	}

}

script "DetermineWUpgradeSpawn" (int mode)	//0 = Spawn item at location, 1 = Return result for Jane's shop
{
	int randomnumberwu;
	int remaining_checks = 10;	//Try to get a random match ten times before forgetting this random weapon upgrade.
	If(PlayerClass(0)==CHAR_SCALETEST) { Log(s:"Scale test detected!"); Terminate; }
	While(remaining_checks>0)
	{
		If(PlayerClass(Random(0,PlayerCount()-1))==CHAR_MARY)	//If a random player is Mary...
		{
			randomnumberwu = Random(0,7);
			If(randomnumberwu % 2 == 1 && upgrades[0] < CONST_MAXUPGRADES_HAMMER) { remaining_checks = 1; If(mode==0) Spawn("PowerupHammer",GetActorX(0),GetActorY(0),GetActorZ(0),0,0); Else SetResultValue(1); }
			If(randomnumberwu % 2 == 0 && upgrades[2] < CONST_MAXUPGRADES_UMBRELLA) { remaining_checks = 1; If(mode==0) Spawn("PowerupUmbrella",GetActorX(0),GetActorY(0),GetActorZ(0),0,0); Else SetResultValue(2); }
		}
		Else	//Else, if they are playing as Xane...
		{
			If(upgrades[3] < CONST_MAXUPGRADES_SWORD) { remaining_checks = 1; If(mode==0) Spawn("PowerupSword",GetActorX(0),GetActorY(0),GetActorZ(0),0,0); Else SetResultValue(1); }
		}
		
		remaining_checks--;
	}
	
	Thing_Remove(0);	//After spawning the upgrade, remove the dummy spawner object.
}

//Common

//TELEPORT SCRIPT
// Teleports player from reference point (from) to reference point (to); Maintains momentum and direction!
script "TP" (int from, int to, int below_z) 
{
	level_ready = FALSE;	//Make the culling polyobject speed up.
	GiveInventory("Variable5",1);	//Make the player pass through the polyobject.
	
	if(below_z==0) TeleportGroup(0,from,to,0,0);
	else if(GetActorZ(0)>>16 < below_z) TeleportGroup(0,from,to,0,0);
	
	Delay(8);
	level_ready = TRUE;	//Return the culling polyobject back to normal speed.
	TakeInventory("Variable5",1);	//Return the player to being solid again.
}

//ACTIVATE/DEACTIVATE GROUP
//Activates all objects with the specified TID. Use "AutoDoorOpener" for things like dynamic lights.
script "SetGroupActivation" (int activate, int tid)
{ If(activate) Thing_Activate(tid); Else Thing_Deactivate(tid); }

//LADDERS
//Locks the player in place then moves them up to the set height, which should be the top of the ladder.
script "Ladder" (int height)
{	
	SetActorVelocity(0, 0.0, 0.0, 1.1, FALSE, FALSE);
	height = height  << 16;
	ACS_NamedExecuteAlways("PlayerMovement",0,TRUE,FALSE,FALSE);
	
	While(GetActorZ(0)<height + 3.5)
	{
		SetActorVelocity(0, 0.0, 0.0, GetActorVelZ(0), FALSE, FALSE);
		ThrustThingZ(0, 12, 0, FALSE);
		Delay(2);
	}
	
	ThrustThing(GetActorAngle(0) >> 8, 4,TRUE, 0);
	Delay(4);
	ACS_NamedExecuteAlways("PlayerMovement",0,FALSE,FALSE,FALSE);
}

bool rslot_busy[2];

//RAILS
//See https://worldofkirbycraft.miraheze.org/wiki/Rail for details.
script "Rail" (int path_follower, int bpanel)
{
	bool no_jump = FALSE;
	If(path_follower==0||bpanel==0) { Log(s:"Invalid rail detected! Please set both the follower and panel TIDs."); Terminate; }
	If(path_follower<0) { no_jump = TRUE; path_follower = abs(path_follower); }	//Negative path_follower disables player jumping. This doesn't affect scripted enemy jumps.
	If(GetActorZ(0)-GetActorZ(bpanel)>32.5||GetActorZ(0)-GetActorZ(bpanel)<-4.5) Terminate;	//If the player is above the boost panel, they shouldn't grind on this rail!
	
	int rt_x, rt_y, railtics, whichslot;	//Position variables used to check if the player should stop following the rail.
	
	If(rslot_busy[0]==FALSE) { rslot_busy[0] = TRUE; whichslot = 0; }
	Else If(rslot_busy[1]==FALSE) { rslot_busy[1] = TRUE; whichslot = 1; }
	Else { whichslot = 2; }
	
	//PrintBold(d:whichslot, s:" (", d:path_follower+whichslot, s:") claimed.");
	
	Thing_Activate(path_follower+whichslot);
	
	if(CheckActorClass(0, "LGirlPlayer")==TRUE||CheckActorClass(0, "XanePlayer")==TRUE) ACS_NamedExecuteAlways("PlayerMovement",0,TRUE,FALSE,2);	//Freeze (the last argument here) being 2 means the velocity isn't stored or recovered.
	
	rt_x = -676;
	rt_y = -676;
	railtics = 0;
	
	if(CheckActorClass(0, "LGirlPlayer")==FALSE&&CheckActorClass(0, "XanePlayer")==FALSE) SetActorState(0, "Grind", TRUE);	//If not Mary, make the monster appear to be "grinding".
	
	PlaySound(path_follower+whichslot, "rail/grind", CHAN_BODY, 1.0, TRUE, 1.75);
	
	While(GetActorX(0)!=rt_x||GetActorY(0)!=rt_y)
	{		
		rt_x = GetActorX(0);
		rt_y = GetActorY(0);
		
		Spawn("GrindSpark",GetActorX(0),GetActorY(0),GetActorZ(0));
		
		Delay(1);
		railtics++;
		
		SetActorPosition(0,GetActorX(path_follower+whichslot),GetActorY(path_follower+whichslot),GetActorZ(path_follower+whichslot),FALSE);
		SetActorVelocity(0,GetActorVelX(path_follower+whichslot),GetActorVelY(path_follower+whichslot),GetActorVelZ(path_follower+whichslot),FALSE,FALSE);
		SetActorAngle(0, GetActorAngle(path_follower+whichslot));
		Spawn("GrindSpark",GetActorX(0),GetActorY(0),GetActorZ(0));
		
		if( ( (openInput[MAX_PLAYERS*4+PlayerNumber()] & BT_JUMP || openInput[MAX_PLAYERS*4+PlayerNumber()] & BT_USE) && railtics>17 && no_jump==FALSE) || CheckInventory("ForceJump")==TRUE) { rt_x = GetActorX(0); rt_y = GetActorY(0); }
	}
	
	ThrustThing(GetActorAngle(0)>>8,23,TRUE,0);
	if((openInput[MAX_PLAYERS*4+PlayerNumber()] & BT_JUMP || openInput[MAX_PLAYERS*4+PlayerNumber()] & BT_USE) && no_jump==FALSE) ThrustThingZ(0, 28,FALSE,TRUE);
	
 	if(CheckActorClass(0, "LGirlPlayer")==FALSE&&CheckActorClass(0, "XanePlayer")==FALSE) SetActorState(0, "GrindEnd", FALSE);	//If not Mary, make the monster appear to be "grinding".
	if(CheckActorClass(0, "LGirlPlayer")==TRUE||CheckActorClass(0, "XanePlayer")==TRUE) { no_variable_jumping[PlayerNumber()] = TRUE; ACS_NamedExecuteAlways("DisableVarJumpHeightsUntilGroundHit",0,0,0,0); }

	Thing_Deactivate(path_follower+whichslot);
	
	//PrintBold(d:whichslot, s:" (", d:path_follower+whichslot, s:") is now open.");
	
	if(whichslot<2) rslot_busy[whichslot] = FALSE;
	
	StopSound(path_follower+whichslot,CHAN_BODY);
	PlaySound(path_follower+whichslot, "rail/jump", CHAN_BODY, 1.0, FALSE, 1.75);
	Delay(5);
	if(CheckActorClass(0, "LGirlPlayer")==TRUE||CheckActorClass(0, "XanePlayer")==TRUE) ACS_NamedExecuteAlways("PlayerMovement",0,FALSE,FALSE,2);
}

script "RailJump" (void) { SpawnSpotForced("ForceRailJump", 618, 0, 0); }

int specialheight[9] = { -9999.1, -9999.1, -9999.1, -9999.1, -9999.1, -9999.1, -9999.1, -9999.1, -9999.1 };	//Height of water/pit/lava. Array index 9 ([MAX_PLAYERS]) is for monsters. 
int specialbehavior[9];	//0: Water, 1: Death, 2: Lava
int airsupply[MAX_PLAYERS] = { 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050 };	//Replicating the DECORATE/player struct counterpart.

#define CONSTANT_LAVA_TICS 32

int hammermove[MAX_PLAYERS];	//How many tics to prevent walljumping[PlayerNumber()]; The opposite of "walljumping[PlayerNumber()]".
int walljumping[MAX_PLAYERS];	//How many tics to not allow hammer abilities.
int fspeed[MAX_PLAYERS];	//The player's current falling speed. It is set to 0 if they move upward.
bool fscreamed[MAX_PLAYERS];	//Has Mary screamed yet?
int waterlevels[MAX_PLAYERS];
int surface_tics[MAX_PLAYERS*2];	//Tics left until assuming the player's no longer on the water.

script "ControlWParticles" (int playerno, int mode)	{	surface_tics[PlayerNumber()+MAX_PLAYERS] = mode;	}

script "WParticles" ENTER
{
	While(1)
	{
		Delay (1);
		
		If(surface_tics[PlayerNumber()+MAX_PLAYERS] == TRUE)
		{
			int lasttid = UniqueTID(700,75);
			Spawn("WaterSurface", GetActorX(GetCurrentPlayerTID()), GetActorY(GetCurrentPlayerTID()), GetActorZ(GetCurrentPlayerTID()),lasttid);
			PlaySound(lasttid,"misc/watersurface",CHAN_BODY,0.7,0,ATTN_NORM);
		}
	}
}

script "SetSpecial" (int property, int front, int back)	//0/FALSE: behavior; 1/TRUE: height)
{
	if(property==1) { front = front << 16; back = back << 16; }
	
	If(LineSide()==LINE_FRONT) { if(property==0) { specialbehavior[PlayerNumber()] = front; specialbehavior[MAX_PLAYERS] = front; } if(property==1) { specialheight[PlayerNumber()] = front; specialheight[MAX_PLAYERS] = front; } }
	Else { if(property==0) { specialbehavior[PlayerNumber()] = back; specialbehavior[MAX_PLAYERS] = back; } if(property==1) { specialheight[PlayerNumber()] = back; specialheight[MAX_PLAYERS] = back; } }
	If(GetCVAR("debug_water")==TRUE) print(s:"HEIGHT: ", f:specialheight[MAX_PLAYERS], s:"\nBEHAV: ", d:specialbehavior[MAX_PLAYERS]);
}

int no_movement[MAX_PLAYERS];	//Tics until the player can move with the movement keys.
script "PreventMovement" (int tics, int all_players)
{
	If(all_players==FALSE) no_movement[PlayerNumber()] = tics;
	Else
	{
		For(int pm_playercount = 0; pm_playercount <= PlayerCount(); pm_playercount++) no_movement[pm_playercount] = tics;
	}
}

script "CheckWater" ENTER
{
int lasttid, input_water[MAX_PLAYERS];
While(specialbehavior[PlayerNumber()]==0)	//While water is enabled for the current player.
	{
	waterlevels[PlayerNumber()] = WaterLevel(0);	//Get water levels
	Delay(1);
	if(no_scripts[PlayerNumber()]==FALSE && waterlevels[PlayerNumber()] == 0 && WaterLevel(0) < 3 && (abs(GetActorVelX(GetCurrentPlayerTID())) > 13.0 || abs(GetActorVelY(GetCurrentPlayerTID())) > 13.0) && specialbehavior[PlayerNumber()] == 0)//Compare to see if it changed.
		{	//The water level changed now, and the player's going fast enough? Run on the water!
		GiveActorInventory(GetCurrentPlayerTID(),"onWater",1);
		lasttid = 0;
		
		While(WaterLevel(0)>0)
			{
			if(framecount % 3 == 0) PlaySound(0, "step/water", 4, 0.7, FALSE, 0.88);	//Generate fake footstep sounds.
			TakeInventory("Animation1",1);
			hammermove[PlayerNumber()] = 5;
			If(WaterLevel(0)>0)	walljumping[PlayerNumber()] = 5;
			ACS_ExecuteAlways(66,0,0,0,0);
			fspeed[PlayerNumber()] = 0.0;
			fscreamed[PlayerNumber()] = FALSE;
			no_movement[PlayerNumber()] = 5;	//Don't allow the player to control their movement on water (minus stopping and Air Dashes).
			lasttid++;
			input_water[PlayerNumber()] = GetPlayerInput(PlayerNumber(),INPUT_BUTTONS);
			
			if(specialheight[PlayerNumber()]+16.1>GetActorZ(0))
			{
				If(input_water[PlayerNumber()] & BT_JUMP)
				{
					ACS_NamedExecuteAlways("PlaySoundX",0,1,0,0);
					ThrustThingZ(GetCurrentPlayerTID(),64,FALSE,TRUE);
					Delay(5);
				}
				Else if(input_water[PlayerNumber()] & BT_BACK) SetActorVelocity(GetCurrentPlayerTID(),FixedDiv(GetActorVelX(GetCurrentPlayerTID()), 1.01),FixedDiv(GetActorVelY(GetCurrentPlayerTID()), 1.01),1.5,FALSE,FALSE);
				Else SetActorVelocity(GetCurrentPlayerTID(),FixedMul(GetActorVelX(GetCurrentPlayerTID()), 1.0),FixedMul(GetActorVelY(GetCurrentPlayerTID()), 1.0),1.5,FALSE,FALSE);
			}
			
			if(lasttid>20)
				{
				Delay(1);
				lasttid = 0;
				}
			}
		}
		TakeActorInventory(GetCurrentPlayerTID(),"onWater",1);
		
	}
	
	//Log(s:"Player stopped water detection.");
	ACS_NamedExecuteAlways("RunCheckScript",0,0,0,0);
}

script "GetSpecial" (int which) { If(which<0) which = 0; If(which>1) which = 1; If(which==0) SetResultValue(specialbehavior[PlayerNumber()]); If(which==1)SetResultValue(specialheight[PlayerNumber()]); }

function int WaterLevel (int x)	//This should recreate the built-in waterlevel variables.
{
	if(GetActorZ(0)<=specialheight[PlayerNumber()]-abs(GetActorProperty(0, APROP_Height))) x = 4;	//Fully submerged
	else if(GetActorZ(0)<=(specialheight[PlayerNumber()]-abs(GetActorProperty(0, APROP_Height))/2)) x = 3;	//At least 1/2 in water.
	else if(GetActorZ(0)<=(specialheight[PlayerNumber()]-abs(GetActorProperty(0, APROP_Height))/4)) x = 2;	//At least 1/4 in water.
	else if(GetActorZ(0)<=specialheight[PlayerNumber()]) x = 1;	//At least this person's feet are in water.
	else x = 0;	//Not in water.
	
	If(GetCVAR("debug_water")) Log(s:"WaterLevel: ", d:x);
	SetActorPosition(999, GetActorX(1000), GetActorY(1000), specialheight[0], FALSE);

    return x;
}

script "CheckDeathPit" (void)
{
	While(specialbehavior[PlayerNumber()]==1)
	{
		Delay(1);
		//If the player ever falls below the special plane's height, kill them instantly.
		If(WaterLevel(0)>0) { force_death[PlayerNumber()] = TRUE; While(WaterLevel(0)>0) { SetActorVelocity(0, FixedDiv(GetActorVelX(0),1.25), FixedDiv(GetActorVelY(0),1.25), FixedDiv(GetActorVelZ(0),1.25), FALSE, FALSE); Delay(1); } Delay(35); }
	}
	
	//Log(s:"Player stopped bottomless pit detection.");
	ACS_NamedExecuteAlways("RunCheckScript",0,0,0,0);

}

int lava_damage[MAX_PLAYERS];	//Amount of damage to apply to the player after they've been hurt by lava.

script "CheckLava" (void)
{
	ACS_NamedExecuteAlways("ApplyLavaDamage",0,0,0,0);
	
	Until(specialbehavior[PlayerNumber()]!=2&&lava_damage[PlayerNumber()]==0)
	{
		Until(WaterLevel(0)>0) { If(lava_damage[PlayerNumber()]>0&&framecount % 8 == 7) lava_damage[PlayerNumber()]--; Delay(1); }
		
		If(lava_damage[PlayerNumber()]<12)
		{
			If(WaterLevel(0)==1) { If(lava_damage[PlayerNumber()]<2) lava_damage[PlayerNumber()] += 3; Else lava_damage[PlayerNumber()]++; }
			If(WaterLevel(0)==2) lava_damage[PlayerNumber()] ++;
			If(WaterLevel(0)==3) lava_damage[PlayerNumber()] += 2;
			If(WaterLevel(0)==4) lava_damage[PlayerNumber()] += 3;
		}
		
		Delay(23);
	}
	
	//Log(s:"Player stopped lava detection.");
	ACS_NamedExecuteAlways("RunCheckScript",0,0,0,0);

}

script "ApplyLavaDamage" (void)
{
	While(specialbehavior[PlayerNumber()]==2)
	{
		Delay(23);
		If(lava_damage[PlayerNumber()]>0) { If(CheckInventory("SuperX")==FALSE) DamageThing(lava_damage[PlayerNumber()], 14); Else DamageThing(lava_damage[PlayerNumber()]/2, 14); StopSound(0, CHAN_VOICE); PrintBold(d:lava_damage[0]); }
	}
}

script "RunCheckScript" (void)
{
	if(specialbehavior[PlayerNumber()]==0) ACS_NamedExecuteAlways("CheckWater",0,0,0,0);
	if(specialbehavior[PlayerNumber()]==1) ACS_NamedExecuteAlways("CheckDeathPit",0,0,0,0);
	if(specialbehavior[PlayerNumber()]==2) ACS_NamedExecuteAlways("CheckLava",0,0,0,0);	
}

#define MAXRANDOMBUBBLEINDEXES 90
int rand_bubbles[MAXRANDOMBUBBLEINDEXES] = {	//A pusedo-random series of numbers used for bubble spawning decisions.
0, 2, 1, 0, 0,
1, 1, 0, 1, 0,
0, 1, 1, 1, 0,
1, 0, 0, 0, 1,
1, 0, 0, 1, 0,
0, 1, 1, 1, 0,
1, 0, 0, 1, 0,
1, 0, 2, 0, 1,
0, 1, 1, 0, 1,
0, 0, 1, 0, 0,
1, 1, 0, 1, 0,
0, 1, 1, 1, 0,
1, 0, 0, 0, 1,
1, 0, 0, 1, 0,
0, 1, 1, 1, 2,
1, 0, 0, 1, 0,
1, 0, 0, 0, 1,
0, 1, 1, 0, 1
};	//Yes, multiple bubbles can advance this array too fast.
int bubble_angle = 0;
int bubble_arrayindex;

script "ControlBubbles" (int mode)	//0: Determine bubble size, 1: Determine wait time
{
	If(mode==0)	//Determine bubble size (returns result)
	{
		SetResultValue(rand_bubbles[bubble_arrayindex]);
		bubble_arrayindex++;
		If(bubble_arrayindex>MAXRANDOMBUBBLEINDEXES-1) bubble_arrayindex = 0;
	}
	Else If(mode==1)	//Determine wait time
	{
		Log(s:"initial wait begins.");
		Delay(8+(rand_bubbles[26+(bubble_arrayindex%5)]));	//This formula should give okay delays between each bubble.
		Log(d:8+(rand_bubbles[26+(bubble_arrayindex%5)]), s:" tics should have passed there.");
		GiveInventory("Variable1",1);	//This tells the bubble spawner to create its next bubble.
	}
}

bool fs_channel;	//Controls whether footstep sounds come from sound channel 4 or 5, used for metal footstep sounds.
script "PlayFootstepSound" (void)	//This plays sounds depending on the surface the player is on.
{
	If(GetActorZ(0)-GetActorFloorZ(0)>1.3) Terminate;	//Footsteps can't happen if not on the ground. Water plays its own "footstep" sounds.
	
	if((CheckActorClass(0, "LGirlPlayer")==TRUE||CheckActorClass(0, "XanePlayer")==TRUE||CheckActorClass(0, "AdultScaleTester")==TRUE)&&GetCVAR("snd_footstepsplayer")==FALSE) Terminate;
	else
	{	//If not a player, they must be an enemy!
		if(GetCVAR("snd_footstepsenemy")==FALSE) Terminate;	//If enemy footstep sounds are disabled, don't do anything!
	}
	
	If(WaterLevel(0)==0)
	{
		If(CheckActorFloorTexture(0, "T_SHAWN2") ||
		CheckActorFloorTexture(0, "INB_SHMB") ||
		CheckActorFloorTexture(0, "CITYGATE") ||
		CheckActorFloorTexture(0, "CITYENT3") ||
		CheckActorFloorTexture(0, "CITYENT4") ||
		CheckActorFloorTexture(0, "CITYTELE") ||
		CheckActorFloorTexture(0, "GEN_VENT") ||
		CheckActorFloorTexture(0, "SPC2_BLK") ||
		CheckActorFloorTexture(0, "SPC2_PLT") ||
		CheckActorFloorTexture(0, "SPEC02B") ||
		CheckActorFloorTexture(0, "SPEC06") ||
		CheckActorFloorTexture(0, "SPEC07") ||
		CheckActorFloorTexture(0, "SPEC0B") ||
		CheckActorFloorTexture(0, "SPEC0C") ||
		CheckActorFloorTexture(0, "SPEC0DB") ||
		CheckActorFloorTexture(0, "SPEC0E") ||
		CheckActorFloorTexture(0, "SPECORA1") ||
		CheckActorFloorTexture(0, "SPECORA2") ||
		CheckActorFloorTexture(0, "EXDS_VNT")
		) { fs_channel = !fs_channel; PlaySound(0, "step/metal", 4+fs_channel, 0.5, FALSE, 0.8); }
		Else If(CheckActorFloorTexture(0, "CITYWIND") ||
		CheckActorFloorTexture(0, "T_SHAWNG")
		) PlaySound(0, "step/glass", 4, 1.0, FALSE, 1.03);
		Else If(CheckActorFloorTexture(0, "CARPET01") ||
		CheckActorFloorTexture(0, "CARPET02") ||
		CheckActorFloorTexture(0, "CARPET03") ||
		CheckActorFloorTexture(0, "CARPET04") ||
		CheckActorFloorTexture(0, "CARPET05") ||
		CheckActorFloorTexture(0, "CARPET06") ||
		CheckActorFloorTexture(0, "CARPET07") ||
		CheckActorFloorTexture(0, "CARPET08") ||
		CheckActorFloorTexture(0, "CARPET09") ||
		CheckActorFloorTexture(0, "CARPET10") ||
		CheckActorFloorTexture(0, "FABRIC01") ||
		CheckActorFloorTexture(0, "FABRIC02") ||
		CheckActorFloorTexture(0, "FABRIC03") ||
		CheckActorFloorTexture(0, "FABRIC04") ||
		CheckActorFloorTexture(0, "FABRIC05") ||
		CheckActorFloorTexture(0, "FABRIC06") ||
		CheckActorFloorTexture(0, "FABRIC07") ||
		CheckActorFloorTexture(0, "FABRIC08") ||
		CheckActorFloorTexture(0, "SSTGFLR1") ||
		CheckActorFloorTexture(0, "OD1_SAND") ||
		CheckActorFloorTexture(0, "OD1_GRS1") ||
		CheckActorFloorTexture(0, "OD1_GRS2") ||
		CheckActorFloorTexture(0, "OD1_GRS3")
		) PlaySound(0, "step/carpet", 4, 0.7, FALSE, 1.13);
		Else If(CheckActorFloorTexture(0, "CRT1BRWN") ||
		CheckActorFloorTexture(0, "CRT1TBRN") ||
		CheckActorFloorTexture(0, "CRT1GRAY") ||
		CheckActorFloorTexture(0, "CUP_LTOP") ||
		CheckActorFloorTexture(0, "CRT1TGRY") ||
		CheckActorFloorTexture(0, "CRT1BLUE") ||
		CheckActorFloorTexture(0, "CRT1TBLU") ||
		CheckActorFloorTexture(0, "MARYBLOK")
		) PlaySound(0, "step/crate", 4, 0.9, FALSE, 0.95);
		Else If(CheckActorFloorTexture(0, "WOD1SIDE") ||
		CheckActorFloorTexture(0, "WOD1TOPB") ||
		CheckActorFloorTexture(0, "FENCWODF") ||
		CheckActorFloorTexture(0, "WOODFLR1") ||
		CheckActorFloorTexture(0, "MARYCSID") ||
		CheckActorFloorTexture(0, "WOODTEX1") ||
		CheckActorFloorTexture(0, "WOODTEX2")
		) PlaySound(0, "step/wood", 4, 0.7, FALSE, 1.05);
		Else If(CheckActorFloorTexture(0, "CITYWCHP")
		) PlaySound(0, "step/leaf", 4, 0.7, FALSE, 0.9);
		
		Else PlaySound(0, "step/generic", 4, 1.0, FALSE, 0.97);
	}
	Else PlaySound(0, "step/water", 4, 0.7, FALSE, 0.88);
}

//FALLING 3D FLOOR PLATFORMS

script "FallingPlatform" (int sid)
{
//Check to make sure the player isn't bouncing on the falling platform.
If(GetActorZ(GetCurrentPlayerTID())!=GetSectorCeilingZ(sid,0,0)) Terminate;
Delay(1);
If(GetActorZ(GetCurrentPlayerTID())!=GetSectorCeilingZ(sid,0,0)) Terminate;

Until(GetActorZ(GetCurrentPlayerTID())!=GetSectorCeilingZ(sid,0,0))
    {
    Delay(5);
    }
Floor_LowerByValue(sid,96,1024);
Ceiling_LowerByValue(sid,96,1024);
TagWait(sid);
Delay(10);

Ceiling_RaiseToNearest(sid,32767);
Floor_RaiseToNearest(sid,32767);
Delay(1);
}

//CHARACTER-SPECIFIC AREAS
script "ForceField" (int character, int mode, int spawnid)
//MODES:
//0: Rejects if not the indicated player character ID.
//1: Kills if not the selected player ID (used as last resort if the player glitches through the actual forcefield)
//2: Bouncy walls
{
	If(mode<2&&PlayerClass(PlayerNumber())==2) Terminate;	//The scale tester is allowed to go anywhere!
	If(mode!=1)
	{
		If(mode==0&&PlayerClass(PlayerNumber())==character)	//If you are the character, go through but do nothing for now.
		{
			/*If(spawns[spawnid]==FALSE)
			{
				ACS_Execute(spawnid+10,0,0,0,0);	//Execute a script based on the spawn ID; 0-9 = S10-19.
				spawns[spawnid] = TRUE;
			}*/
		}
		Else
		{
			Switch(mode)
			{
				Case 0: SetActorVelocity(0, -(FixedMul(GetActorVelX(0),2.25)), -(FixedMul(GetActorVelY(0),2.25)), FixedMul(GetActorVelZ(0),1.33), FALSE, FALSE); Break;
				Case 2: SetActorVelocity(2, -(FixedMul(GetActorVelX(0),1.13)), -(FixedMul(GetActorVelY(0),1.13)), FixedMul(GetActorVelZ(0),1.13), FALSE, FALSE); Break;
			}
			If(mode==0)
			{
				If(character==CHAR_MARY) Log(s:"\c[Brick]This area is only for Mary."); If(character==CHAR_XANE) Log(s:"\c[Brick]This area is only for Xane.");
			}
		}
	}
	Else  If(PlayerClass(PlayerNumber())!=character) DamageThing(255,0);
}

/////////////////
//PRECIPITATION//
/////////////////
int flowers;
#define CONSTANT_MAX_FLOWERS 200
#define CONSTANT_PREC_ANGLE 0.13	//The angle added/subtracted from base angle comparisons to determine what direction the player's facing.

script "Precipitation" OPEN
{
int spawntid = 1000;	//Default to player 1.
bool valid_spawn = FALSE;	//This variable will indicate a valid player has been found.
bool pside[4] = { FALSE, FALSE, FALSE, FALSE };	//Which sides to spawn weather on. -X, +X, -Y (down), +Y (up), the latter two in Doom are inverted from logical settings.
int spawnz;	//Height precipitation will be spawned at.

While(1)
	{
	valid_spawn = FALSE;	//Set it to false before running this code.

	if(rain_mode[0]==0&&rain_mode[1]==0&&rain_mode[2]==0&&rain_mode[3]==0&&rain_mode[4]==0&&rain_mode[5]==0&&rain_mode[6]==0&&rain_mode[7]==0)
	{	//If all players aren't requesting precipitation...
		Delay(5);	//Just delay the script.
	}
	Else
	{
	spawntid = 1000 + Random(0, PlayerCount()-1);	//Set the spawntid to a random player.
		Until(valid_spawn==TRUE)
		{
		Delay(1);
		
		if(rain_mode[spawntid-1000]==0) spawntid--;	//If this player isn't requesting rain/snow, try a lower-numbered one.
		Else valid_spawn = TRUE;
		
		if(spawntid<1000) spawntid = 1000 + PlayerCount()-1;	//If searching for "player -1" (999), set this to the highest-numbered player.
		
		}
	
	if(GetActorCeilingZ(spawntid)-GetActorZ(spawntid)>256.0) spawnz = GetActorZ(spawntid)+242.0;
	Else spawnz = GetActorCeilingZ(spawntid)-32.0;
	
	//Next, check what direction the player is facing to limit precip. to that direction.
	
	pside[0] = FALSE;	//First set all the variables to FALSE.
	pside[1] = FALSE;
	pside[2] = FALSE;
	pside[3] = FALSE;
	
	if(GetActorAngle(spawntid)<0.25+CONSTANT_PREC_ANGLE||GetActorAngle(spawntid)>0.75-CONSTANT_PREC_ANGLE)	{ pside[1] = TRUE; }	//Facing right (+X)
	if(GetActorAngle(spawntid)<0.5+CONSTANT_PREC_ANGLE||GetActorAngle(spawntid)>1.0-CONSTANT_PREC_ANGLE)	{ pside[3] = TRUE; }	//Facing up (+Y)
	if(GetActorAngle(spawntid)<0.75+CONSTANT_PREC_ANGLE&&GetActorAngle(spawntid)>0.25-CONSTANT_PREC_ANGLE)	{ pside[0] = TRUE; }	//Facing left (-X)
	if(GetActorAngle(spawntid)>0.5-CONSTANT_PREC_ANGLE||GetActorAngle(spawntid)<0.0+CONSTANT_PREC_ANGLE)	{ pside[2] = TRUE; }	//Facing down (-Y)
	}
	
	

	If(rain_mode[spawntid-1000]==1&&no_scripts[spawntid-1000]==FALSE)
		{
		Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1]),GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3]),spawnz);
		Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1]),GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3]),spawnz);
		Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1]),GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3]),spawnz);
		Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1]),GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3]),spawnz);
		Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1]),GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3]),spawnz);
		Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1]),GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3]),spawnz);
		Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1]),GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3]),spawnz);
		Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1]),GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3]),spawnz);

		Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*2,spawnz);
		Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*2,spawnz);
		Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*2,spawnz);
		Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*2,spawnz);

		if(GetUserCVAR(spawntid-1000,"xane_precipamount")==TRUE) Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*3,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*3,spawnz);
		if(GetUserCVAR(spawntid-1000,"xane_precipamount")==TRUE) Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*3,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*3,spawnz);
		if(GetUserCVAR(spawntid-1000,"xane_precipamount")==TRUE) Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*3,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*3,spawnz);
		if(GetUserCVAR(spawntid-1000,"xane_precipamount")==TRUE) Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*3,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*3,spawnz);
		if(GetUserCVAR(spawntid-1000,"xane_precipamount")==TRUE) Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*3,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*3,spawnz);
		if(GetUserCVAR(spawntid-1000,"xane_precipamount")==TRUE) Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*3,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*3,spawnz);
		if(GetUserCVAR(spawntid-1000,"xane_precipamount")==TRUE) Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*3,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*3,spawnz);
		if(GetUserCVAR(spawntid-1000,"xane_precipamount")==TRUE) Spawn(StrParam(s:"Rain", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*3,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*3,spawnz);

		Delay(1+GetCVAR("xane_precipdelay"));
		}
	
	If(rain_mode[spawntid-1000]==2&&no_scripts[spawntid-1000]==FALSE)
		{
		Spawn(StrParam(s:"Snow", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*2,spawnz);
		Spawn(StrParam(s:"Snow", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*2,spawnz);
		Spawn(StrParam(s:"Snow", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*2,spawnz);

		Spawn(StrParam(s:"Snow", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*4,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*4,spawnz);
		Spawn(StrParam(s:"Snow", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*4,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*4,spawnz);
		Spawn(StrParam(s:"Snow", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*4,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*4,spawnz);
		Spawn(StrParam(s:"Snow", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*4,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*4,spawnz);
		Spawn(StrParam(s:"Snow", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*4,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*4,spawnz);

		if(GetUserCVAR(spawntid-1000,"xane_precipamount")==TRUE) Spawn(StrParam(s:"Snow", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		if(GetUserCVAR(spawntid-1000,"xane_precipamount")==TRUE) Spawn(StrParam(s:"Snow", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		if(GetUserCVAR(spawntid-1000,"xane_precipamount")==TRUE) Spawn(StrParam(s:"Snow", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		if(GetUserCVAR(spawntid-1000,"xane_precipamount")==TRUE) Spawn(StrParam(s:"Snow", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		if(GetUserCVAR(spawntid-1000,"xane_precipamount")==TRUE) Spawn(StrParam(s:"Snow", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		if(GetUserCVAR(spawntid-1000,"xane_precipamount")==TRUE) Spawn(StrParam(s:"Snow", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		if(GetUserCVAR(spawntid-1000,"xane_precipamount")==TRUE) Spawn(StrParam(s:"Snow", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		if(GetUserCVAR(spawntid-1000,"xane_precipamount")==TRUE) Spawn(StrParam(s:"Snow", d:spawntid),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);

		Delay(2+(GetCVAR("xane_precipdelay")));
		}
		
	If(rain_mode[spawntid-1000]==3&&no_scripts[spawntid-1000]==FALSE)
	{
	If(flowers<CONSTANT_MAX_FLOWERS)
		{
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		Spawn("Flower",GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[0],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[1])*6,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[2],GetUserCVAR(spawntid-1000,"xane_precipdist")*pside[3])*6,spawnz);
		}
	Delay(1);
	}
	
	If(rain_mode[spawntid-1000]==4)
	{
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		SpawnParticle(0xAFBFFF,false,240,Random(5,7),GetActorX(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,GetActorY(spawntid)+Random(-GetUserCVAR(spawntid-1000,"xane_precipdist"),GetUserCVAR(spawntid-1000,"xane_precipdist"))*2,(spawnz-128)-Random(0,128),0,0,0,0,0,0,-1,0);
		Delay(15);
	}
	
  }
}

script 311 (int mode) { rain_mode[PlayerNumber()] = mode; }

script "Snow_CheckSky" (void)	//Used by both rain and snow.
{
	If(CheckActorCeilingTexture(0,"SPEC_SKY")==FALSE) Thing_Remove(0);
}

////////
//Wind//
////////

int wind_power[MAX_PLAYERS], wind_x[MAX_PLAYERS], wind_y[MAX_PLAYERS], wind_phase[MAX_PLAYERS], wind_disabledelay[MAX_PLAYERS]; //Wind variables. Only set power directly. x/y/phase are automatically altered. The last variable is done to stop accidental doubling of the disablewind variable.
int direction[MAX_PLAYERS];	//Requested wind direction. Send a request (negative value) or set to 1.0 exactly to resume auto wind.
bool override[MAX_PLAYERS];	//Whether to override automatic "random" wind.
int wdirections[30] = { 0.01, 0.5, 0.31, 0.9, 0.19, 0.65, 0.25, 0.8, 0.02, 0.85, 0.96, 0.21, 0.36, 0.66, 0.4, 0.24, 0.75, 0.81, 0.22, 0.45, 0.05, 0.76, 0.47, 0.43, 1.02, 0.63 };
int index;	//Current wind direction array index. Also affects pauses inbetween wind direction changes.

#define CONST_WINDSPEED_MAX 6
#define CONST_WIND_DISABLETICS 8

Script "ControlWPhase" ENTER
{
	While(1)
	{
		if(direction[PlayerNumber()]<wind_phase[PlayerNumber()]) wind_phase[PlayerNumber()] -= 0.005;
		if(direction[PlayerNumber()]>wind_phase[PlayerNumber()]) wind_phase[PlayerNumber()] += 0.005;
		
		wind_x[PlayerNumber()] = FixedMul(sin(wind_phase[PlayerNumber()]),FixedDiv(wind_power[PlayerNumber()],2));
		wind_y[PlayerNumber()] = FixedMul(cos(wind_phase[PlayerNumber()]),FixedDiv(wind_power[PlayerNumber()],2));
		
		Delay(3);
	}
}

Script "AutoWind" OPEN
{
	int bg_direction;	//Current "wind direction" when auto wind is overwritten.
	int fake_direction;	//Imitation of wind_phase[PlayerNumber()] to accurately imitate wind direction when in the "background".
	
	direction[0] = 0.5;
	direction[1] = 0.5;
	direction[2] = 0.5;
	direction[3] = 0.5;
	direction[4] = 0.5;
	direction[5] = 0.5;
	direction[6] = 0.5;
	direction[7] = 0.5;
	fake_direction = 0.5;
	
	While(1)
	{
		If(fake_direction>bg_direction-0.01&&fake_direction<bg_direction+0.01) { Delay(175); index++; if(wdirections[index]==0) index = 0; bg_direction = wdirections[index]; if(override[0]==FALSE) direction[0] = wdirections[index]; if(override[1]==FALSE) direction[1] = wdirections[index]; if(override[2]==FALSE) direction[2] = wdirections[index]; if(override[3]==FALSE) direction[3] = wdirections[index]; if(override[4]==FALSE) direction[4] = wdirections[index]; if(override[5]==FALSE) direction[5] = wdirections[index]; if(override[6]==FALSE) direction[6] = wdirections[index]; if(override[7]==FALSE) direction[7] = wdirections[index]; }
		
		if(bg_direction<fake_direction) fake_direction -= 0.005;
		if(bg_direction>fake_direction) fake_direction += 0.005;
		
		Delay(3);
		
		
	}
}

	/*This script sets wind properties. Here are the settings changable with arg[0]/argument 1:
	 *
	 *0: Set wind direction; This overrides the automatic wind until set back to 0. 1-8 are CCW from right/"north".
	 *1: Wind power (0-4). 0 disables wind while 4 is very hard to control Mary during.
	 *2: Disable wind moving Mary with 1. Use 0 to resume it. This stacks if multiple scripts request this.
	*/

script "SetWind" (int mode, int value, int all_players)
{
	If(mode==2)
	{
		if(value<0) value = 0;
		if(value>1) value = 1;
		
		if(value==0)
		{
			if(all_players==FALSE) { if(disablewind[PlayerNumber()]>0&&wind_disabledelay[PlayerNumber()]==0) { disablewind[PlayerNumber()]--; wind_disabledelay[PlayerNumber()] = CONST_WIND_DISABLETICS; } }
			Else
			{
				if(disablewind[0]>0&&wind_disabledelay[0]==0) disablewind[0]--;
				if(disablewind[1]>0&&wind_disabledelay[1]==0) disablewind[1]--;
				if(disablewind[2]>0&&wind_disabledelay[2]==0) disablewind[2]--;
				if(disablewind[3]>0&&wind_disabledelay[3]==0) disablewind[3]--;
				if(disablewind[4]>0&&wind_disabledelay[4]==0) disablewind[4]--;
				if(disablewind[5]>0&&wind_disabledelay[5]==0) disablewind[5]--;
				if(disablewind[6]>0&&wind_disabledelay[6]==0) disablewind[6]--;
				if(disablewind[7]>0&&wind_disabledelay[7]==0) disablewind[7]--;
				
				wind_disabledelay[0] = CONST_WIND_DISABLETICS;
				wind_disabledelay[1] = CONST_WIND_DISABLETICS;
				wind_disabledelay[2] = CONST_WIND_DISABLETICS;
				wind_disabledelay[3] = CONST_WIND_DISABLETICS;
				wind_disabledelay[4] = CONST_WIND_DISABLETICS;
				wind_disabledelay[5] = CONST_WIND_DISABLETICS;
				wind_disabledelay[6] = CONST_WIND_DISABLETICS;
				wind_disabledelay[7] = CONST_WIND_DISABLETICS;
			}
		}
		if(value==1)
		{
			if(all_players==FALSE) { if(wind_disabledelay[PlayerNumber()]==0) { disablewind[PlayerNumber()]++; wind_disabledelay[PlayerNumber()] = CONST_WIND_DISABLETICS; } }
			Else
			{
				if(wind_disabledelay[0]==0)disablewind[0]++;
				if(wind_disabledelay[1]==0)disablewind[1]++;
				if(wind_disabledelay[2]==0)disablewind[2]++;
				if(wind_disabledelay[3]==0)disablewind[3]++;
				if(wind_disabledelay[4]==0)disablewind[4]++;
				if(wind_disabledelay[5]==0)disablewind[5]++;
				if(wind_disabledelay[6]==0)disablewind[6]++;
				if(wind_disabledelay[7]==0)disablewind[7]++;
				
				wind_disabledelay[0] = CONST_WIND_DISABLETICS;
				wind_disabledelay[1] = CONST_WIND_DISABLETICS;
				wind_disabledelay[2] = CONST_WIND_DISABLETICS;
				wind_disabledelay[3] = CONST_WIND_DISABLETICS;
				wind_disabledelay[4] = CONST_WIND_DISABLETICS;
				wind_disabledelay[5] = CONST_WIND_DISABLETICS;
				wind_disabledelay[6] = CONST_WIND_DISABLETICS;
				wind_disabledelay[7] = CONST_WIND_DISABLETICS;
			}
		}
	}

	if(mode==1)
	{
		if(value>CONST_WINDSPEED_MAX) value = CONST_WINDSPEED_MAX;
		if(value<0) value = 0;
		
		if(all_playerS==FALSE) wind_power[PlayerNumber()] = value;
		Else
		{
			wind_power[0] = value;
			wind_power[1] = value;
			wind_power[2] = value;
			wind_power[3] = value;
			wind_power[4] = value;
			wind_power[5] = value;
			wind_power[6] = value;
			wind_power[7] = value;
		}
	}
	
	if(mode==0)
	{
		If(value<0) value = 0;
		If(value>8) value = 12;
		
		if(all_players==FALSE) override[PlayerNumber()] = TRUE;
		Else
		{
			override[0] = TRUE;
			override[1] = TRUE;
			override[2] = TRUE;
			override[3] = TRUE;
			override[4] = TRUE;
			override[5] = TRUE;
			override[6] = TRUE;
			override[7] = TRUE;
		}
		
		Switch(value)
		{
			Case 0:
				if(all_players==FALSE)override[PlayerNumber()] = FALSE;
				Else
				{
					override[0] = FALSE;
					override[1] = FALSE;
					override[2] = FALSE;
					override[3] = FALSE;
					override[4] = FALSE;
					override[5] = FALSE;
					override[6] = FALSE;
					override[7] = FALSE;
				}
			Break;
			Case 3:
				value = 0.0;	//Up
			Break;
			Case 2:
				value = 0.13;	//Up-right
			Break;
			Case 1:
				value = 0.25;	//Right
			Break;
			Case 8:
				value = 0.38;	//Down-right
			Break;
			Case 7:
				value = 0.5;	//Down
			Break;
			Case 6:
				value = 0.63;	//Down-left
			Break;
			Case 5:
				value = 0.75;	//Left
			Break;
			Case 4:
				value = 0.88;	//Up-left
			Break;
		}
		
		if(all_players==FALSE) direction[PlayerNumber()] = value;	//Set this as the requested wind direction.
		Else
		{
			direction[0] = value;
			direction[1] = value;
			direction[2] = value;
			direction[3] = value;
			direction[4] = value;
			direction[5] = value;
			direction[6] = value;
			direction[7] = value;
		}
	}
}

script "GetXProperty" (int type, int extra) { SetResultValue(GetValue(type)); }

function bool GetValue (int type)
{
int val;

Switch(type)
{
	Case 0:	//Use >>16 if errors happen in-game for 0 and 1!
	//val = wind_x;
	Break;
	Case 1:
	//val = wind_y;
	Break;
	Case 2:
	val = GetCVAR("xane_popindistance");
	Break;
	Case 3:
	val = FixedMul(wind_x[0],8);
	Break;
	Case 4:
	val = FixedMul(wind_y[0],8);
	Break;
	Case 5:
	val = FixedMul(wind_x[1],8);
	Break;
	Case 6:
	val = FixedMul(wind_y[1],8);
	Break;
	Case 7:
	val = FixedMul(wind_x[2],8);
	Break;
	Case 8:
	val = FixedMul(wind_y[2],8);
	Break;
	Case 9:
	val = FixedMul(wind_x[3],8);
	Break;
	Case 10:
	val = FixedMul(wind_y[3],8);
	Break;
	Case 11:
	val = FixedMul(wind_x[4],8);
	Break;
	Case 12:
	val = FixedMul(wind_y[4],8);
	Break;
	Case 13:
	val = FixedMul(wind_x[5],8);
	Break;
	Case 14:
	val = FixedMul(wind_y[5],8);
	Break;
	Case 15:
	val = FixedMul(wind_x[6],8);
	Break;
	Case 16:
	val = FixedMul(wind_y[6],8);
	Break;
	Case 17:
	val = FixedMul(wind_x[7],8);
	Break;
	Case 18:
	val = FixedMul(wind_y[7],8);
	Break;
}

return val;
}

script "ObjGroup_Spawn" (int tid, int tid_high, int type)
{
	If(type==-1)
	{
		For(int spb = tid; spb <= tid_high; spb++)
		{
			If(GetCVAR("debug_")==TRUE) Log(s:"Removed TID ", d:spb);
			SetActorState(spb+1000,"FadeOut",FALSE);
			
			If(spb % 50 == 0)Delay(1);
		}
	}
	else	//...spawn the lag-causing objects!
	{
		For(int spa = tid; spa <= tid_high; spa++)
		{
			If(type==0)SpawnForced("TreeA",GetActorX(spa),GetActorY(spa),GetActorZ(spa),spa+1000,Random(0,360));
			
			If(spa % 50 == 0)Delay(1);
			If(GetCVAR("debug_")==TRUE) Log(s:"Created ObjGroup object at TID ", d:spa);
		}
		
		If(GetCVAR("debug_")==TRUE) Log(s:"ObjGroup's tree spawning TID was ", d:tid_high+1, s:"!");
	}
		
}

//EXIT SCRIPTS

int playersExit;
bool playersExitArray[MAX_PLAYERS] = { false, false, false, false, false, false, false, false };
bool exitLocked = false;

script "ExitLevelCounter" (int mode, int line_id)
{
If(exitLocked==false)
{
If(GameType()==GAME_NET_DEATHMATCH) 
{
int dmflags = 0;
dmflags = GetCVAR("dmflags");
If(dmflags & 1024)   //If "Allow exit" is not allowed...
    {
    PrintBold(s:"Player ", d:PlayerNumber(), s:" attempted to leave the area.");
   Thing_Damage(GetCurrentPlayerTID(),10001,20); //...kill the player.
    }
Else
    {
    Line_SetBlocking(line_id,0,BLOCKF_PLAYERS);
    exitLocked = true;
    Print(s:"WARNING: YOU'RE ABOUT TO LEAVE THE AREA!");
    }
}
Else If(GameType()==GAME_SINGLE_PLAYER) 
{
	Line_SetBlocking(line_id,0,BLOCKF_PLAYERS);
	exitLocked = true;
	If(gamemode==0) Print(s:"WARNING: YOU'RE ABOUT TO LEAVE THE AREA!");
}
Else If(GameType()==GAME_NET_COOPERATIVE)
    {
        if(mode==0)
            {
            playersExit++;
            playersExitArray[PlayerNumber()] =true;
            
            If(ACS_NamedExecuteWithResult("ExitDetermineRequirement",0,0,0,0)<=playersExit)
                {
                exitLocked = true;
                Line_SetBlocking(line_id,0,BLOCKF_PLAYERS);
                PrintBold(s:"THIS AREA CAN NOW BE LEFT!");
                }
            Else
                {
                PrintBold(s:" PLEASE WAIT!\n", d:ACS_NamedExecuteWithResult("ExitDetermineRequirement",0,0,0,0)-playersExit, s:" PLAYER(S) NEEDED TO EXIT THIS AREA.");
                ACS_NamedExecute("ExitNag",0,0,0,0);
                }
            }
        Else
            {
            playersExit--;
            playersExitArray[PlayerNumber()] =false;
                PrintBold(s:"STAY HERE; ", d:ACS_NamedExecuteWithResult("ExitDetermineRequirement",0,0,0,0)-playersExit, s:" PLAYER(S) NEEDED TO EXIT THIS AREA.");
            }
        }
    }
}

script "ExitDetermineRequirement" (void)
{
int value;

Switch(PlayerCount())
{
Case 2:
value = 1;
Break;
Case 3:
value = 2;
Break;
Case 4:
value = 2;
Break;
Case 5:
value = 3;
Break;
Case 6:
value = 3;
Break;
Case 7:
value = 4;
Break;
Case 8:
value = 5;
Break;
Default:
value = 1;
Break;
}
SetResultValue(value);
}

script "ExitNag"  (void)
{
/*If(playersExitArray[0]==false)
    {
    SetActivator(1000,AAPTR_PLAYER1);
    Print(s:"Hurry up, Player 1!\nYour team is waiting for you\nat the end of this area!");
    }
If(playersExitArray[1]==false)
    {
    SetActivator(1001,AAPTR_PLAYER2);
    Print(s:"Hurry up, Player 2!\nYour team is waiting for you\nat the end of this area!");
    }
If(playersExitArray[2]==false)
    {
    SetActivator(1002,AAPTR_PLAYER3);
    Print(s:"Hurry up, Player 3!\nYour team is waiting for you\nat the end of this area!");
    }
If(playersExitArray[3]==false)
    {
    SetActivator(1003,AAPTR_PLAYER4);
    Print(s:"Hurry up, Player 4!\nYour team is waiting for you\nat the end of this area!");
    }
If(playersExitArray[4]==false)
    {
    SetActivator(1004,AAPTR_PLAYER5);
    Print(s:"Hurry up, Player 5!\nYour team is waiting for you\nat the end of this area!");
    }
If(playersExitArray[5]==false)
    {
    SetActivator(1005,AAPTR_PLAYER6);
    Print(s:"Hurry up, Player 6!\nYour team is waiting for you\nat the end of this area!");
    }
If(playersExitArray[6]==false)
    {
    SetActivator(1006,AAPTR_PLAYER7);
    Print(s:"Hurry up, Player 7!\nYour team is waiting for you\nat the end of this area!");
    }
If(playersExitArray[7]==false)
    {
    SetActivator(1007,AAPTR_PLAYER8);
    Print(s:"Hurry up, Player 8!\nYour team is waiting for you\nat the end of this area!");
    }*/
}

int levelinfo[6] = { 99, 99, 99, 99, 99, 99 };


script "UpdateLevelInfo" OPEN
{
While(1)
	{
		Delay(7);
		levelinfo[0] = GetLevelInfo(LEVELINFO_KILLED_MONSTERS);
		levelinfo[1] = GetLevelInfo(LEVELINFO_TOTAL_MONSTERS);
		levelinfo[2] = GetLevelInfo(LEVELINFO_FOUND_ITEMS);
		levelinfo[3] = GetLevelInfo(LEVELINFO_TOTAL_ITEMS);
		levelinfo[4] = GetLevelInfo(LEVELINFO_FOUND_SECRETS);
		levelinfo[5] = GetLevelInfo(LEVELINFO_TOTAL_SECRETS);
	}
}

/*script "TestPointHUDHealth" ENTER
{
	int old_tid, new_tid;
	While(1)
	{			
		// Get the existing TID, if there is one.
		// A TID of 0 is the same as not having a TID, so "setting" it to 0 will not
		// change anything's TID.
		old_tid = PickActor(1000, GetActorAngle(0), GetActorPitch(0), 512, 0, MF_SOLID, 0, PICKAF_RETURNTID);
		
		// Find a TID that's not currently in use.
		new_tid = UniqueTID();
		
		// Do the "real" call.  This will return true if an actor was actually found,
		// and also forcibly set its TID.
		if (PickActor(1000, GetActorAngle(0), GetActorPitch(0), 512, new_tid, MF_SOLID, 0, PICKAF_FORCETID))
		{
			// Do some stuff with the temporary TID.
			PrintBold(d:GetActorProperty(new_tid, APROP_Health), s:"/", d:GetActorProperty(new_tid,APROP_SpawnHealth));
			
			// When you're done, restore the actor's TID to its original value.
			Thing_ChangeTID(new_tid, old_tid);
		}
		
		Delay(3);
	}
}*/

bool moveskybox = TRUE;	//Set this to FALSE to make this script stop moving the skybox viewpoint based on player 1's movement.
script "MoveSkybox" (int x_offset, int y_offset)	//Offsets are set by the sky viewpoint. Make sure to set them correctly!
{	
	Thing_ChangeTID(0, 615);
	
	Delay(3);
	
	If(GameType()==GAME_NET_COOPERATIVE||GameType()==GAME_NET_DEATHMATCH||movesky[0]<=0||movesky[1]<=0) Terminate;
	SetActivator(1000, AAPTR_PLAYER1);
	
	int skybox_x, skybox_y, skybox_z;	//This is where the skybox viewpoint object initially spawns in the small room near the skybox. It moves into the skybox using offsets.
	skybox_x = GetActorX(615);
	skybox_y = GetActorY(615);
	skybox_z = GetActorZ(615);
	x_offset = x_offset << 16;	//Convert the offses into floating point numbers.
	y_offset = y_offset << 16;
	
	
	While(moveskybox)
	{
		If(movesky[0]==0) movesky[0] = 16;	//Prevent division by zero by setting these to a slow-moving number like 16.
		If(movesky[1]==0) movesky[1] = 16;
		SetActorPosition(615, (skybox_x+x_offset)+(GetActorX(1000)/movesky[0]), (skybox_y+y_offset)+(GetActorY(1000)/movesky[0]), skybox_z+(GetActorZ(1000)/movesky[1]), FALSE);
		Delay(1);
	}
}

script "ShowHUDLInfo" ENTER
{
If(GetCVAR("cl_demo")==TRUE) Terminate;
int fcolors[3] = { -1, -1, -1 };
While(1)
	{
	Delay(3);
	
	If(GetUserCVAR(PlayerNumber(),"xane_hudlinfo")==TRUE&&CheckActorInventory(GetCurrentPlayerTID(),"NoHUD")==FALSE)
		{
		if(GetCVAR("screenblocks")==11)	//Unused
			{
			if(levelinfo[0]==levelinfo[1]) fcolors[0] = CR_GREEN;
			if(levelinfo[0]<levelinfo[1])fcolors[0] = CR_WHITE;		
				
			if(levelinfo[4]==levelinfo[5]) fcolors[1] = CR_GREEN;
			if(levelinfo[4]<levelinfo[5])fcolors[1] = CR_WHITE;
			
			SetFont("BIG_TEXT");
			SetHUDSize(640,420,0);
			
			if(levelinfo[1]!=0) HudMessage(s:"M: ", d:levelinfo[0], s:"/", d:levelinfo[1], s:" (", d:levelinfo[0], s:"%", d:levelinfo[1], s:"%)";
				HUDMSG_FADEOUT|HUDMSG_NOTWITHFULLMAP, 0, fcolors[0], 745.2, 325.0, 0.1, 0.05);
			else HudMessage(s:"M: ", d:levelinfo[0], s:"/", d:levelinfo[1], s:" (100%)";
					HUDMSG_FADEOUT|HUDMSG_NOTWITHFULLMAP, 0, fcolors[0], 745.2, 325.0, 0.1, 0.05);
			if(levelinfo[5]!=0) HudMessage(s:"S: ", d:levelinfo[4], s:"/", d:levelinfo[5], s:" (", d:levelinfo[4], s:"%", d:levelinfo[5], s:"%)";
				HUDMSG_FADEOUT|HUDMSG_NOTWITHFULLMAP, 0, fcolors[1], 745.2, 345.0, 0.1, 0.05);
			else HudMessage(s:"S: ", d:levelinfo[4], s:"/", d:levelinfo[5], s:" (100%)";
					HUDMSG_FADEOUT|HUDMSG_NOTWITHFULLMAP, 0, fcolors[1], 745.2, 345.0, 0.1, 0.05);
			}
		if(GetCVAR("screenblocks")<11)
			{
			if(levelinfo[0]==levelinfo[1]) fcolors[0] = CR_GREEN;
			if(levelinfo[0]<levelinfo[1])fcolors[0] = CR_WHITE;
			
			if(levelinfo[4]==levelinfo[5]) fcolors[1] = CR_GREEN;
			if(levelinfo[4]<levelinfo[5])fcolors[1] = CR_WHITE;
			
			SetFont("2DFONTP1");
			SetHUDSize(0,0,TRUE);
			
			HudMessage(s:"M: ", d:levelinfo[0], s:"%", d:levelinfo[1];
				HUDMSG_FADEOUT|HUDMSG_NOTWITHFULLMAP, 0, fcolors[0], 0.99, 0.945, 0.1, 0.05);
			HudMessage(s:"S: ", d:levelinfo[4], s:"%", d:levelinfo[5];
				HUDMSG_FADEOUT|HUDMSG_NOTWITHFULLMAP, 0, fcolors[1], 0.99, 1.0, 0.1, 0.05);
			}
		}

	}
}

#define TIMER_UPPER 163.1
#define TIMER_LOWER 171.1

script "GetSeconds" (void)	{	SetResultValue(seconds[0]);	}

script "LTimer" ENTER
{
//gamemode = 1;

If(gamemode==0) { seconds[PlayerNumber()] = 0; timer_tics = 0; }

int lump_name = StrParam(n:PRINTNAME_LEVEL);

Delay(1);
Until(level_ready==TRUE) Delay(1);	//Wait for the signal first.

if((gamemode==0&&(lump_name == "SPECSTG1"||lump_name == "SPECSTG2"||lump_name == "SPECSTG3"||lump_name == "SPECSTG4"||lump_name == "SPECSTG5"||lump_name == "SPECSTG6"||lump_name == "SPECSTG7"))||lump_name == "TITLE"||lump_name == "INTRO") Terminate;

While(ltime_control!=TIME_STOP)	//time_pause is temporary; Time_stop is used when exiting levels.
    {
		If(GetCVAR("screenblocks")==11&&gamemode==0)	//Fullscreen HUD
		{
			SetHUDSize(0,0,FALSE);
			SetFont("STIMEFNT");
			If(seconds[PlayerNumber()] % 60 >= 10)
			{
					HUDMessage (d:seconds[PlayerNumber()] / 60,s:":",d:seconds[PlayerNumber()] % 60;
				HUDMSG_FADEOUT, 20, CR_WHITE, 0.98,0.01, 60.0, 0.0, 0.0);   //Text
					HUDMessage (d:seconds[PlayerNumber()] / 60,s:":",d:seconds[PlayerNumber()] % 60;
				HUDMSG_FADEOUT, 20, CR_BLACK, 0.985,0.02, 60.0, 0.0, 0.0);//Shadow
			}
			Else
			{
					HUDMessage (d:seconds[PlayerNumber()] / 60,s:":0",d:seconds[PlayerNumber()] % 60;
				HUDMSG_FADEOUT, 20, CR_WHITE, 0.98,0.01, 60.0, 0.05, 0.05);
					HUDMessage (d:seconds[PlayerNumber()] / 60,s:":0",d:seconds[PlayerNumber()] % 60;
				HUDMSG_FADEOUT, 20, CR_BLACK, 0.985,0.02, 60.0, 0.05, 0.05);//Shadow
			}
		}
		Else If(GetCVAR("screenblocks")<11&&gamemode==0)	//Status Bar
		{
			SetHUDSize(320,200,TRUE);
			SetFont("BIG_TEXT");
			If(seconds[PlayerNumber()] % 60 >= 10)
			{
					HUDMessage (d:seconds[PlayerNumber()] / 60,s:":",d:seconds[PlayerNumber()] % 60;
				HUDMSG_FADEOUT, 20, CR_WHITE, 255.0,182.1, 60.0, 0.0, 0.0);   //Text
			}
			Else
			{
					HUDMessage (d:seconds[PlayerNumber()] / 60,s:":0",d:seconds[PlayerNumber()] % 60;
				HUDMSG_FADEOUT, 20, CR_WHITE, 255.0,182.1, 60.0, 0.0, 0.0);
			}
		}
		Delay(1);
		
		if(ltime_control==TIME_PLAY&&(gamemode>0||(gamemode==0&&seconds[PlayerNumber()]<599))) timer_tics++;
		ltime_control = TIME_PLAY;
		if(timer_tics>=35&&((gamemode==0&&seconds[PlayerNumber()]<599)||gamemode>0))	//Limit the timer to ten minutes (9:59).
		{
				timer_tics = 0;
				seconds[PlayerNumber()]++;
		}
	}
}

script "SpeedTimer" ENTER
{	//Don't appear in the campaign, 1-1 (for the Small Hut), or loading screens.
	If(gamemode==0||GetLevelInfo(LEVELINFO_LEVELNUM)==0||GetLevelInfo(LEVELINFO_LEVELNUM)>=CONST_TRANS_LEVELS_START) Terminate;
	Delay(2);
	Until(level_ready==TRUE) Delay(1);	//Wait for the signal first.
	If(StrParam(n:PRINTNAME_LEVEL)=="MAP2"&&gamemode==1)	//If in Time Attack, start off with a countdown!
	{
		ACS_NamedExecute("PlayerMovement",0,TRUE,FALSE,FALSE);
		ACS_NamedExecute("JaneMenuLock",0,35*3,0,0);
		cgem_count = 0;
		AmbientSound("misc/notify",255);
		Print(d:3);
		Delay(35);
		AmbientSound("misc/notify",255);
		Print(d:2);
		Delay(35);
		AmbientSound("misc/notify",255);
		Print(d:1);
		Delay(35);
		AmbientSound("troll/smash",255);
		Print(s:"GO!");
		ACS_NamedExecute("ResetPlayerForSpeedruns",0,0,0,0);
		Delay(1);
		GiveInventory("PowerupDamage",1);
		GiveInventory("PowerupWater",1);
		GiveInventory("PowerupNinja",1);
		ACS_NamedExecute("PlayerMovement",0,FALSE,FALSE,FALSE);
		ACS_Terminate("JaneMenuLock",0);
	}
	If(gamemode==3)	//Reset the timer at the beginning of all levels. Mode 3 is practice mode.
	{
		cgem_count = 7;	//All Chaos Bridges
		ACS_NamedExecute("ResetPlayerForSpeedruns",0,0,0,0);
		Delay(1);
		GiveInventory("PowerupDamage",2);
		GiveInventory("PowerupHeal",1);
		GiveInventory("PowerupNinja",1);
		GiveInventory("PowerupWater",2);
		GiveInventory("PowerupSpeed",2);	//Give some Powerup Coins that could be helpful to practice with.
	}
	
	SetFont("DBIGFONT");
	
	While(gamemode>0)
	{
		If(no_scripts[PlayerNumber()]==FALSE)
		{
			If(OpenInput[0] & BT_USER3 && !(OpenInput[MAX_PLAYERS] & BT_USER3))	//USER3 = Restart Run
			{
				If(gamemode==3) { ACS_NamedExecute("ExitTransition",0,0,0,0); Delay(35); }	//Practice Mode
				If(gamemode==1)
				{
					AmbientSound("menu/backup",256);
					Log(s:"Restarting run...");
					important_fade[PlayerNumber()] = TRUE;
					FadeTo(0,0,0,1.0,0.5);
					Delay(16);
					important_fade[PlayerNumber()] = FALSE;
					Delay(1);
					ChangeLevel("TMP2",0,CHANGELEVEL_NOINTERMISSION|CHANGELEVEL_PRERAISEWEAPON, GameSkill());
				}
			}
			
			If(seconds[0] % 60 < 10 && timer_tics * 2 >= 10)
			{
				HUDMessage (d:seconds[0] / 60,s:"\"0",d:seconds[0] % 60, s:".", d:timer_tics * 2;
					HUDMSG_FADEOUT, 20, CR_CREAM, 0.5,0.875, 0.01, 0.5, 0.0);
			}
			Else If(seconds[0] % 60 < 10 && timer_tics* 2 < 10)
			{
				HUDMessage (d:seconds[0] / 60,s:"\"0",d:seconds[0] % 60, s:".0", d:timer_tics * 2;
					HUDMSG_FADEOUT, 20, CR_CREAM, 0.5,0.875, 0.01, 0.5, 0.0);
			}
			Else If(seconds[0] % 60 >= 10 && timer_tics * 2 < 10)
			{
				HUDMessage (d:seconds[0] / 60,s:"\"",d:seconds[0] % 60, s:".0", d:timer_tics * 2;
					HUDMSG_FADEOUT, 20, CR_CREAM, 0.5,0.875, 0.01, 0.5, 0.0);
			}
			Else If(seconds[0] % 60 >= 10 && timer_tics * 2 >= 10)
			{
				HUDMessage (d:seconds[0] / 60,s:"\"",d:seconds[0] % 60, s:".", d:timer_tics * 2;
					HUDMSG_FADEOUT, 20, CR_CREAM, 0.5,0.875, 0.01, 0.5, 0.0);
			}
		}
		
		If(no_scripts[PlayerNumber()]==TRUE)
		{
			Delay(3);
			If(no_scripts[PlayerNumber()]==FALSE) { Delay(5); }
		}
		
		Delay(1);
	}
}

script "DisplayCoinTimers" ENTER
{
	SetFont("CONFONT");
	SetHUDSize(320,200,TRUE);
	int vposition = TIMER_LOWER;	//This is where the coin timers will be drawn vertically.

	While(1)
	{
		If((ACS_NamedExecuteWithResult("CheckSpecialStage",0,0,0,0)==TRUE||ACS_NamedExecuteWithResult("CheckSpecialStage",2,0,0,0)==TRUE) && (ninja_tics[PlayerNumber()]>0||water_tics[PlayerNumber()]>0||damage_tics[PlayerNumber()]>0||heal_tics[PlayerNumber()]>0||speed_tics[PlayerNumber()]>0||combo_tics[PlayerNumber()]>0))
		{
			HUDMessage (s:"COINS LOCKED";
				HUDMSG_FADEOUT, 0, CR_RED, 64.1,155.1, 0.01, 0.0, 0.0);
		}
		
		if(ninja_tics[PlayerNumber()]>0)
		{
			If(water_tics[PlayerNumber()]==0) vposition = TIMER_LOWER;
			Else vposition =  TIMER_UPPER;
			
			HUDMessage (s:"NINJA:";
				HUDMSG_FADEOUT, 0, CR_PURPLE, 254.2,vposition, 0.01, 0.0, 0.0);
			
			If((ninja_tics[PlayerNumber()]/35) % 60 >= 10) {
			HUDMessage (d:(ninja_tics[PlayerNumber()]/35) / 60,s:":",d:(ninja_tics[PlayerNumber()]/35) % 60;
				HUDMSG_FADEOUT, 0, CR_CREAM, 294.2,vposition, 0.01, 0.0, 0.0); }
			Else {
			HUDMessage (d:(ninja_tics[PlayerNumber()]/35) / 60,s:":0",d:(ninja_tics[PlayerNumber()]/35) % 60;
				HUDMSG_FADEOUT, 0, CR_CREAM, 294.2,vposition, 0.01, 0.0, 0.0); }
			
		}

		if(water_tics[PlayerNumber()]>0)
		{

			HUDMessage (s:"WATER:";
				HUDMSG_FADEOUT, 0, CR_BLUE, 254.2,TIMER_LOWER, 0.01, 0.0, 0.0);
			
			If((water_tics[PlayerNumber()]/35) % 60 >= 10) {
			HUDMessage (d:(water_tics[PlayerNumber()]/35) / 60,s:":",d:(water_tics[PlayerNumber()]/35) % 60;
				HUDMSG_FADEOUT, 0, CR_CYAN, 294.2,TIMER_LOWER, 0.01, 0.0, 0.0); }
			Else {
			HUDMessage (d:(water_tics[PlayerNumber()]/35) / 60,s:":0",d:(water_tics[PlayerNumber()]/35) % 60;
				HUDMSG_FADEOUT, 0, CR_CYAN, 294.2,TIMER_LOWER, 0.01, 0.0, 0.0); }
			
		}
		
		if(damage_tics[PlayerNumber()]>0)
		{
			If(heal_tics[PlayerNumber()]==0) vposition = TIMER_LOWER;
			Else vposition =  TIMER_UPPER;
			
			HUDMessage (s:"DAMAGE:";
				HUDMSG_FADEOUT, 0, CR_ORANGE, 164.2,vposition, 0.01, 0.0, 0.0);
			
			If((damage_tics[PlayerNumber()]/35) % 60 >= 10) {
			HUDMessage (d:(damage_tics[PlayerNumber()]/35) / 60,s:":",d:(damage_tics[PlayerNumber()]/35) % 60;
				HUDMSG_FADEOUT, 0, CR_YELLOW, 204.2,vposition, 0.01, 0.0, 0.0); }
			Else {
			HUDMessage (d:(damage_tics[PlayerNumber()]/35) / 60,s:":0",d:(damage_tics[PlayerNumber()]/35) % 60;
				HUDMSG_FADEOUT, 0, CR_YELLOW, 204.2,vposition, 0.01, 0.0, 0.0); }
			
		}

		if(heal_tics[PlayerNumber()]>0)
		{
		
			HUDMessage (s:"HEAL:";
				HUDMSG_FADEOUT, 0, CR_RED, 164.2,TIMER_LOWER, 0.01, 0.0, 0.0);
			
			If((heal_tics[PlayerNumber()]/35) % 60 >= 10) {
			HUDMessage (d:(heal_tics[PlayerNumber()]/35) / 60,s:":",d:(heal_tics[PlayerNumber()]/35) % 60;
				HUDMSG_FADEOUT, 0, CR_TAN, 204.2,TIMER_LOWER, 0.01, 0.0, 0.0); }
			Else {
			HUDMessage (d:(heal_tics[PlayerNumber()]/35) / 60,s:":0",d:(heal_tics[PlayerNumber()]/35) % 60;
				HUDMSG_FADEOUT, 0, CR_TAN, 204.2,TIMER_LOWER, 0.01, 0.0, 0.0); }
			
		}

		if(speed_tics[PlayerNumber()]>0)
		{
			If(combo_tics[PlayerNumber()]==0) vposition = TIMER_LOWER;
			Else vposition =  TIMER_UPPER;
			
			HUDMessage (s:"SPEED:";
				HUDMSG_FADEOUT, 0, CR_GREEN, 64.2,vposition, 0.01, 0.0, 0.0);
			
			If((speed_tics[PlayerNumber()]/35) % 60 >= 10) {
			HUDMessage (d:(speed_tics[PlayerNumber()]/35) / 60,s:":",d:(speed_tics[PlayerNumber()]/35) % 60;
				HUDMSG_FADEOUT, 0, CR_YELLOW, 104.2,vposition, 0.01, 0.0, 0.0); }
			Else {
			HUDMessage (d:(speed_tics[PlayerNumber()]/35) / 60,s:":0",d:(speed_tics[PlayerNumber()]/35) % 60;
				HUDMSG_FADEOUT, 0, CR_YELLOW, 104.2,vposition, 0.01, 0.0, 0.0); }
			
		}
		
		if(combo_tics[PlayerNumber()]>0)
		{
		
			HUDMessage (s:"COMBO:";
				HUDMSG_FADEOUT, 0, CR_YELLOW, 64.2,TIMER_LOWER, 0.01, 0.0, 0.0);
			
			If((combo_tics[PlayerNumber()]/35) % 60 >= 10) {
			HUDMessage (d:(combo_tics[PlayerNumber()]/35) / 60,s:":",d:(combo_tics[PlayerNumber()]/35) % 60;
				HUDMSG_FADEOUT, 0, CR_TAN, 104.2,TIMER_LOWER, 0.01, 0.0, 0.0); }
			Else {
			HUDMessage (d:(combo_tics[PlayerNumber()]/35) / 60,s:":0",d:(combo_tics[PlayerNumber()]/35) % 60;
				HUDMSG_FADEOUT, 0, CR_TAN, 104.2,TIMER_LOWER, 0.01, 0.0, 0.0); }
			
		}
	Delay(1);
	}
}

script "ResetPlayerForSpeedruns" (void)
{
	total_coins = 0;
	combo[0] = 0;
	combo[MAX_PLAYERS] = 0;
	combo[MAX_PLAYERS*2] = 0;
	TakeInventory("CoinSP",999);	//Take all coins
	If(gamemode==1) { level[0] = 34; level[1] = 34; level[2] = 33; }
	ACS_NamedExecute("GiveSRWeapons",0,-1,0,0);	//Give all weapons in Practice Mode. Change in the future for other modes.
	SetActorProperty(0, APROP_Health, 100);
	damage_tics[0] = 0;
	heal_tics[0] = 0;
	ninja_tics[0] = 0;
	water_tics[0] = 0;
	combo_tics[0] = 0;
	speed_tics[0] = 0;
	TakeInventory("PowerupDamage",99);
	TakeInventory("PowerupHeal",99);
	TakeInventory("PowerupNinja",99);
	TakeInventory("PowerupWater",99);
	TakeInventory("PowerupCombo",99);
	TakeInventory("PowerupSpeed",99);
	TakeInventory("Ball1",25);
	TakeInventory("Ball2",25);
	TakeInventory("Ball3",25);
	TakeInventory("InventoryTurret",25);
	
	TakeInventory("Wand_IntroDone",1);
	TakeInventory("MaryUmbrella_Intro",1);
	TakeInventory("Wand_Type",3);
	TakeInventory("MaryHammer_MidAirDone",1);
	TakeInventory("RequestBallThrow",3);
	
	If(gamemode==1) upgrades[0] = 0;
	Else upgrades[0] = 4;
	
	upgrades[1] = 100;	//The player only can collect 100 coins.
	seconds[0] = 0;
	timer_tics = 0;
	Delay(1);
	If(PlayerClass(0)==CHAR_MARY) UseInventory("MaryUmbrella");
	If(PlayerClass(0)==CHAR_XANE) UseInventory("XaneSword");
	Delay(1);
	If(PlayerClass(0)==CHAR_MARY) UseInventory("MaryUmbrella");
	If(PlayerClass(0)==CHAR_XANE) UseInventory("XaneSword");
	Delay(1);
	If(PlayerClass(0)==CHAR_MARY) UseInventory("MaryUmbrella");
	If(PlayerClass(0)==CHAR_XANE) UseInventory("XaneSword");
}

int jumps[MAX_PLAYERS];
int detected[MAX_PLAYERS];

int ramph[MAX_PLAYERS], rampv[MAX_PLAYERS];

script "Ramp" (int hpower, int vpower, int xspecial)
{
/*If(abs(GetActorVelX(0))>abs(GetActorVelY(0))) { If(abs(GetActorVelX(0)<9.9)) Terminate; }
Else { If(abs(GetActorVelY(0)<9.9)) Terminate; }*/

ramph[PlayerNumber()] = hpower;
rampv[PlayerNumber()] = vpower;
if(xspecial==1) ActivatorSound("misc/ramplaunch",96);	//(1) Play ramp boost sound.

jumps[PlayerNumber()] = 0;	//Prevent double/triple jumps from happening if a player lands shortly before this jump...

	Delay(3);
	
	jumps[PlayerNumber()] = 0;	//Prevent double/triple jump detection after landing from this jump.
	//ramph[PlayerNumber()] = 0;
	//rampv[PlayerNumber()] = 0;
}

script "PresetRamp" (int which)
{
	Switch(which)
	{
		Case 1:
			If(LineSide()==LINE_FRONT) ACS_NamedExecuteAlways("Ramp",0,5,3,0);
			If(LineSide()==LINE_BACK) ACS_NamedExecuteAlways("Ramp",0,2,4,0);
		Break;
		Default:
			Log(s:"ERROR: Invalid preset ramp number ", d:which, s:" was used!");
		Break;
	}
}

//Exit areas

bool results_final = FALSE;

script "ExitDetermineResults" (int line_id)
{
ACS_NamedTerminate("ExitLevelCounter",0);
If(gamemode!=0) Terminate;	//If this isn't the campaign, it's not encouraged to waste time killing monsters and finding secrets.
int monsters, secrets;

if(levelinfo[1]!=0)monsters = levelinfo[0] * 100 / levelinfo[1];
Else monsters = 100;
if(levelinfo[5]!=0)secrets = levelinfo[4] * 100 / levelinfo[5];
Else secrets = 100;
if(gamemode==0) ltime_control = TIME_STOP;
else ltime_control = TIME_PAUSE;
Line_SetBlocking(line_id,BLOCKF_PLAYERS,0);
results_final = TRUE;	//Don't let the player return to the level or get a worse score!
int stored_bonus;

int reward_100percents;	//Number of categories completed 100% (0-3)
int reward_lives = 0;

//Reward the player with extra lives if they complete the level with good enough completion percentage.
If(monsters==100) reward_100percents++;	//CONSTANT_1UP_100PERCENT_INITIAL;
If(secrets==100) reward_100percents++; //CONSTANT_1UP_100PERCENT_INC;

bool temp_reward_initial = false;

if(completed_levels[level[1]+1]==FALSE)
{
	While(reward_100percents>0)	//Calculate how many 1UP
	{
		if(temp_reward_initial==FALSE)
		{
			reward_lives = CONSTANT_1UP_100PERCENT_INITIAL;
			temp_reward_initial = TRUE;
		}
		else reward_lives += CONSTANT_1UP_100PERCENT_INC;
		
		reward_100percents--;
	}
}

if(reward_lives>0) ACS_NamedExecuteAlways("GiveExtraLife",0,reward_lives,0,0);

	if(monsters==100&&secrets==100)
	{
		PlaySound(GetCurrentPlayerTID(),"announcer/rating3",CHAN_WEAPON|CHAN_UI|CHAN_NOPAUSE,1.0);
		PrintBold(s:"AREA RESULTS:\n\nMONSTERS: ", d:monsters, s:"%\nSECRETS: ", d:secrets, s:"%\n\nPERFECT!");
		completed_levels[0]++;
		completed_levels[level[1]] = 300;
	}
	Else If(monsters+secrets>=100)
	{
		PlaySound(GetCurrentPlayerTID(),"announcer/rating2",CHAN_WEAPON|CHAN_UI|CHAN_NOPAUSE,1.0);
		PrintBold(s:"AREA RESULTS:\n\nMONSTERS: ", d:monsters, s:"%\nSECRETS: ", d:secrets, s:"%\n\nGOOD ENOUGH.");
		completed_levels[0]++;
		completed_levels[level[1]] = monsters+secrets;
	}
	
	Else { PlaySound(GetCurrentPlayerTID(),"announcer/rating1",CHAN_WEAPON|CHAN_UI|CHAN_NOPAUSE); PrintBold(s:"AREA RESULTS:\n\nMONSTERS: ", d:monsters, s:"%\nSECRETS: ", d:secrets, s:"%\n\nBETTER LUCK NEXT TIME..."); }
}

Script "ExitTransition" (void)
{
	fade = 1;	//Prepare the fade in for after the "loading" screen.
	fadeout = 6;	//Request a quick fade out to black for all players.
	
	Delay(17);
	
	If(GameType()==GAME_SINGLE_PLAYER&&CheckActorInventory(1000, "CoinSP")>0)
	{
		Print(s:"Sending ", d:CheckActorInventory(1000, "CoinSP"), s:" coins to your bank...");
		ACS_NamedExecute("DisplayTotalCoins",0,70+CheckActorInventory(1000, "CoinSP"),0,0);
		Delay(17);
		
		Until(CheckActorInventory(1000, "CoinSP")==0)
		{
			Print(s:"Sending ", d:CheckActorInventory(1000, "CoinSP"), s:" coins to your bank...");
			total_coins++;
			TakeActorInventory(1000, "CoinSP", 1);
			AmbientSound("coin/normal",256);
			Delay(2);
		}
		
		Delay(6);
	}

	If(gamemode!=3) { ChangeLevel(StrParam(s:"TMP", d:level[1]+2),0,CHANGELEVEL_NOINTERMISSION|CHANGELEVEL_PRERAISEWEAPON, GameSkill()); }//Level[1]+201 is the temporary level for the next level. This makes the game forget this level's state before advancing.
	Else ChangeLevel(StrParam(s:"TMP", d:level[1]+1),0,CHANGELEVEL_NOINTERMISSION|CHANGELEVEL_PRERAISEWEAPON, GameSkill());	//If in practice mode, restart the level when it's completed.
}

script "Disconnect"  (int arg0) DISCONNECT
{
	playersExit++;
	playersExitArray[arg0] = true;
}
/////////////////////
//TECHNICAL SCRIPTS//
/////////////////////
script "GetPlayerInformation" (int type)
{
	Switch(type)
	{
		Case 0: SetResultValue(GameSkill()); Break;
	}
}

bool shadow_slots[2];	//Whether a shadow is currently in use by a jumping enemy.
script "EnemyShadow" (void)
{
	If(GetCVAR("r_shadows")==FALSE) Terminate;
	
	int chosen_slot;
	
	If(shadow_slots[0] == FALSE) chosen_slot = 0;
	Else If(shadow_slots[1] == FALSE) chosen_slot = 1;
	Else chosen_slot = 2;
	
	if(chosen_slot<2) shadow_slots[chosen_slot] = TRUE;	//Claim this slot to prevent glitches, similar to rails.
	
	Until(GetActorZ(0)-GetActorFloorZ(0)>16.0) Delay(1);
	
	If(GetCVAR("vid_renderer")==TRUE) Thing_Activate(2024+chosen_slot);
	
	While(GetActorZ(0)-GetActorFloorZ(0)>16.0)
	{
		If(GetCVAR("vid_renderer")==TRUE&&GetCVAR("xane_voxelshadows")==FALSE) SetActorPosition(2024+chosen_slot,GetActorX(0),GetActorY(0),GetActorFloorZ(0),FALSE);
		Else SpawnForced("SWRendererShadow_Size2",GetActorX(0),GetActory(0),GetActorFloorZ(0),2024+chosen_slot,0);
		SetActorVelocity(2024+chosen_slot,GetActorVelX(0),GetActorVelY(0),0.0,FALSE, FALSE);		
		Delay(1);
	}
	
	If(GetCVAR("vid_renderer")==TRUE) Thing_Deactivate(2024+chosen_slot);
	if(chosen_slot<2) shadow_slots[chosen_slot] = FALSE;	//Indicate this slot is no longer occupied.
}

script "UpdatePlayerShadows" ENTER
{
	If(ThingCount(T_NONE,1000)==0||(GetCVAR("vid_renderer")==FALSE||(GetCVAR("vid_renderer")==TRUE&&GetCVAR("xane_voxelshadows")==TRUE))) { Thing_Remove(2000); Thing_Remove(2008); Thing_Remove(2016); }
	If(ThingCount(T_NONE,1001)==0||(GetCVAR("vid_renderer")==FALSE||(GetCVAR("vid_renderer")==TRUE&&GetCVAR("xane_voxelshadows")==TRUE))) { Thing_Remove(2001); Thing_Remove(2009); Thing_Remove(2017); }
	If(ThingCount(T_NONE,1002)==0||(GetCVAR("vid_renderer")==FALSE||(GetCVAR("vid_renderer")==TRUE&&GetCVAR("xane_voxelshadows")==TRUE))) { Thing_Remove(2002); Thing_Remove(2010); Thing_Remove(2018); }
	If(ThingCount(T_NONE,1003)==0||(GetCVAR("vid_renderer")==FALSE||(GetCVAR("vid_renderer")==TRUE&&GetCVAR("xane_voxelshadows")==TRUE))) { Thing_Remove(2003); Thing_Remove(2011); Thing_Remove(2019); }
	If(ThingCount(T_NONE,1004)==0||(GetCVAR("vid_renderer")==FALSE||(GetCVAR("vid_renderer")==TRUE&&GetCVAR("xane_voxelshadows")==TRUE))) { Thing_Remove(2004); Thing_Remove(2012); Thing_Remove(2020); }
	If(ThingCount(T_NONE,1005)==0||(GetCVAR("vid_renderer")==FALSE||(GetCVAR("vid_renderer")==TRUE&&GetCVAR("xane_voxelshadows")==TRUE))) { Thing_Remove(2005); Thing_Remove(2013); Thing_Remove(2021); }
	If(ThingCount(T_NONE,1006)==0||(GetCVAR("vid_renderer")==FALSE||(GetCVAR("vid_renderer")==TRUE&&GetCVAR("xane_voxelshadows")==TRUE))) { Thing_Remove(2006); Thing_Remove(2014); Thing_Remove(2022); }
	If(ThingCount(T_NONE,1007)==0||(GetCVAR("vid_renderer")==FALSE||(GetCVAR("vid_renderer")==TRUE&&GetCVAR("xane_voxelshadows")==TRUE))) { Thing_Remove(2007); Thing_Remove(2015); Thing_Remove(2023); }
	
	If(GetCVAR("vid_renderer")==TRUE&&GetCVAR("xane_voxelshadows")==FALSE)	//If on the OpenGL rendrer, hide the enemy shadows...
	{
		Thing_Deactivate(2024);
		Thing_Deactivate(2025);
		Thing_Deactivate(2026);
	}
	Else	//...otherwise, remove them.
	{
		Thing_Remove(2024);
		Thing_Remove(2025);
		Thing_Remove(2026);
	}
	
	While(1)
	{	
		If(GetCVAR("r_shadows")==TRUE)
		{
			If(GetCVAR("vid_renderer")==TRUE&&GetCVAR("xane_voxelshadows")==FALSE)	//OpenGL (dynamic light shadows)
			{
				If(GetActorZ(0)-GetActorFloorZ(0)>68.0) { If(SetActorPosition(2016+PlayerNumber(),GetActorX(0),GetActorY(0),GetActorFloorZ(0),FALSE)==TRUE) Thing_Activate(2016+PlayerNumber()); } //SetActorVelocity(2016+PlayerNumber(),GetActorVelX(0),GetActorVelY(0),0.0,FALSE, FALSE); }
				Else If(GetActorZ(0)-GetActorFloorZ(0)>42.0) { If(SetActorPosition(2008+PlayerNumber(),GetActorX(0),GetActorY(0),GetActorFloorZ(0),FALSE)==TRUE) Thing_Activate(2008+PlayerNumber()); } //SetActorVelocity(2008+PlayerNumber(),GetActorVelX(0),GetActorVelY(0),0.0,FALSE, FALSE); }
				Else If(GetActorZ(0)-GetActorFloorZ(0)>16.0) { If(SetActorPosition(2000+PlayerNumber(),GetActorX(0),GetActorY(0),GetActorFloorZ(0),FALSE)==TRUE) Thing_Activate(2000+PlayerNumber()); } //SetActorVelocity(2000+PlayerNumber(),GetActorVelX(0),GetActorVelY(0),0.0,FALSE, FALSE); }
				
				Delay(1);
				
				//Last, hide the shadows.
				Thing_Deactivate(2000+PlayerNumber());
				Thing_Deactivate(2008+PlayerNumber());
				Thing_Deactivate(2016+PlayerNumber());
			}
			Else	//Software (voxel-based shadows)
			{
				If(GetActorZ(0)-GetActorFloorZ(0)>68.0) { SpawnForced("SWRendererShadow_Size3",GetActorX(0),GetActory(0),GetActorFloorZ(0),2016+PlayerNumber(),0); SetActorVelocity(2016+PlayerNumber(),GetActorVelX(0),GetActorVelY(0),0.0,FALSE, FALSE); }
				Else If(GetActorZ(0)-GetActorFloorZ(0)>42.0) { SpawnForced("SWRendererShadow_Size2",GetActorX(0),GetActory(0),GetActorFloorZ(0),2008+PlayerNumber(),0); SetActorVelocity(2008+PlayerNumber(),GetActorVelX(0),GetActorVelY(0),0.0,FALSE, FALSE); }
				Else If(GetActorZ(0)-GetActorFloorZ(0)>16.0) { SpawnForced("SWRendererShadow_Size1",GetActorX(0),GetActory(0),GetActorFloorZ(0),2000+PlayerNumber(),0); SetActorVelocity(2000+PlayerNumber(),GetActorVelX(0),GetActorVelY(0),0.0,FALSE, FALSE); }
				
				Delay(1);
			}
		}
		Else Delay(1);
	}
}

global int 1:remjumps[];

script "TurnSuper" ENTER
{
While(1)
	{
	Delay(1);
	if(openInput[PlayerNumber()] & BT_USER1)
		{
		  If(1)
		  {
			If(cgem_count>=7||GetCVAR("debug_super")==TRUE)
			{
				If(CheckActorInventory(GetCurrentPlayerTID(),"SuperX")==0)
				  {
					If(CheckActorInventory(GetCurrentPlayerTID(),"CoinSP")>=CONSTANT_SCOIN_REQ||GetCVAR("debug_super")==TRUE)
						{
						If(GetActorZ(GetCurrentPlayerTID())-GetActorFloorZ(GetCurrentPlayerTID())>0)
							{
							force_detransform[PlayerNumber()] = FALSE;	//If a detransformation was queued, cancel that.
							int o1, o2;
							o1 = GetActorVelX(GetCurrentPlayerTID());
							o2 = GetActorVelY(GetCurrentPlayerTID());
							
							AmbientSound("misc/transform",64);	//The "YEEEE-AAH!" background chord. It sounds better if a yell is heard over it.
							ACS_NamedExecuteAlways("PlayerMovement",0,1,0,0);
							SetActorProperty(GetCurrentPlayerTID(),PROP_FLY,ON);
							SetActorState(GetCurrentPlayerTID(),"Transform",1);
							ActivatorSound("*super_yell",127);
							
							a[PlayerNumber()] =  GetActorAngle (GetCurrentPlayerTID());
						mmx[PlayerNumber()] = GetActorX (GetCurrentPlayerTID());
						y[PlayerNumber()] = GetActorY (GetCurrentPlayerTID());
						z[PlayerNumber()] = GetActorZ (GetCurrentPlayerTID()) + VIEW_HEIGHT;
						xyr =  r * cos (p) >> 16;	//Below is the transformation "cutscene".
						ACS_NamedExecuteAlways("SpawnCGems",0,0,0,0);	//Spawn the Chaos Bridges.
						SpawnForced("ChaseCam",mmx[PlayerNumber()]-cos(a[PlayerNumber()])*xyr, y[PlayerNumber()]-sin(a[PlayerNumber()])*xyr, z[PlayerNumber()], C_TID+PlayerNumber(), a[PlayerNumber()] >> 8);
						ChangeCamera(C_TID+PlayerNumber(),0,0);
						
							SetActorAngle(GetCurrentPlayerTID(),GetActorAngle(GetCurrentPlayerTID())-0.5);
						int super1 = 0;
						While(super1<38)
						{
							SetActorVelocity(GetCurrentPlayerTID(),0,0,0,0,1);
							super1++;
							Delay(1);
						}

							ActivatorSound("*super_grunt",127);

						GiveActorInventory(GetCurrentPlayerTID(),"SuperX",1);
						If(PlayerClass(PlayerNumber())==CHAR_MARY)
						{
							TakeInventory("WandType",2);
							GiveInventory("Wand_Type",2);	//Select the Heart Wand.
							GiveInventory("MaryWand",1);	//Give Magical Cutie Mary her wand.
							UseInventory("MaryWand");		//Force the wand out for every transformation.
						}
						
						While(super1<=78)
						{
							SetActorVelocity(GetCurrentPlayerTID(),0,0,0,0,1);
							super1++;
							Delay(1);
						}
						SetActorProperty(GetCurrentPlayerTID(),PROP_FLY,OFF);
							SetActorAngle(GetCurrentPlayerTID(),GetActorAngle(GetCurrentPlayerTID())+0.5);
						ChangeCamera(0,0,0);
						Thing_Remove(C_TID+PlayerNumber());
			ACS_NamedExecuteAlways("PlayerMovement",0,0,0,0);
			SetActorVelocity(GetCurrentPlayerTID(),o1,o2,0,0,1);
							}
							Else
							{
							Print(s:"You must be in the air to transform.");
							}
						}
					Else
						{
						Print(s:"You need ", d:CONSTANT_SCOIN_REQ-CheckActorInventory(GetCurrentPlayerTID(),"CoinSP"), s:" more coins to transform.");
						}
					}
				Else
				  {
				  Print(s:"You are already transformed.");
				  }
			  }
			Else
				{
				Print(s:"You need ", d:7-cgem_count, s:" more Chaos Bridges to transform.");
				}
		  }
		  Else
		  {
			Print(s:"You cannot transform during the removed 'race mode'.");
		  }
		}
	}
}

script "TurretUserVariables" (int which, int number)
{
	Switch(which)
	{
		Case 1:	//Initial angle
			SetUserVariable(0, "user_angle", number);
			int var = GetUserVariable(0, "user_angle");
		Break;
		Case 2:	//Stored angle
			SetUserVariable(0, "user_storedangle", number>>16/*GetActorAngle(0)>>16*/);
		Break;
		Default:
			Log(s:"Unknown turret user variable requested, ", d:which, s:"!");
		Break;
	}
}

script "CheckSuper" ENTER
{
int delayamount = 0;

While(1)
	{
		Delay(1);
		If(delayamount<CONSTANT_SCOIN_DEC)
		{
			If(no_scripts[PlayerNumber()]==FALSE)
			{
				delayamount++;
				If(force_detransform[PlayerNumber()]==TRUE) delayamount = CONSTANT_SCOIN_DEC;	//If detransformation is requested, do it immediately.
				If(CheckActorInventory(GetCurrentPlayerTID(),"SuperX")==1)
				{
					Spawn("SparkleSpawner",GetActorX(GetCurrentPlayerTID()),GetActorY(GetCurrentPlayerTID()),GetActorZ(GetCurrentPlayerTID())+24,0,GetActorAngle(GetCurrentPlayerTID())>>8);
				}
			}
	}
	If(delayamount>=CONSTANT_SCOIN_DEC)
		{
		delayamount = 0;
		If(cgem_count>=7||GetCVAR("debug_super")==TRUE)
			{
			
			If(CheckActorInventory(GetCurrentPlayerTID(),"SuperX")==1&&GetCVAR("debug__super")==FALSE&&force_detransform[PlayerNumber()]==FALSE) TakeActorInventory(GetCurrentPlayerTID(),"CoinSP",1);
			If(CheckActorInventory(GetCurrentPlayerTID(),"SuperX")==1&&GetCVAR("debug__super")==FALSE)
				{
				If(CheckActorInventory(GetCurrentPlayerTID(),"CoinSP")<=0||force_detransform[PlayerNumber()]==TRUE)
					{
					TakeActorInventory(GetCurrentPlayerTID(),"SuperX",1);
					
					//stored_velocity[0] = GetActorVelX(GetCurrentPlayerTID());
					//stored_velocity[1] = GetActorVelY(GetCurrentPlayerTID());
					//stored_velocity[2] = GetActorVelZ(GetCurrentPlayerTID());
					
					//UnMorphActor(GetCurrentPlayerTID(),TRUE);	//Unmorphing gets rid of the player's movement and weapons, stupid design choices.
					//SetActorVelocity(GetCurrentPlayerTID(),stored_velocity[0],stored_velocity[1],stored_velocity[2],FALSE,FALSE);
					//ACS_NamedExecuteAlways("GiveWeapons",0,0,0,0);
					
					//stored_velocity[0] = 0;	//Clear these variables or non-standard level transitions may use the velocities stored here!
					//stored_velocity[1] = 0;
					//stored_velocity[2] = 0;
					}
				}
			}
		Else
			{
			If(CheckActorInventory(GetCurrentPlayerTID(),"SuperX")==1)
				{
				If(GetCVAR("debug_super")==FALSE)
					{
					TakeActorInventory(GetCurrentPlayerTID(),"SuperX",1);
					Print(s:"You don't have enough Chaos Bridges to transform.");
					}
				Else
					{
					GiveActorInventory(GetCurrentPlayerTID(),"CoinSP",15);
					}
				}
			}
		}
	}
}

/////////////////////////
//CHECKPOINTS AND DEATH//
/////////////////////////

int amb_current[MAX_PLAYERS];

int checkpoint_id[MAX_PLAYERS+1];	//TID of checkpoint to respawn at. 9 (array index 8) is for monsters.
bool death_behavior[MAX_PLAYERS];	//What happens when the player loses all of their health. (0 = dies)
int check_ambience[MAX_PLAYERS];	//Ambience at checkpoint.
int check_weather[MAX_PLAYERS];		//The weather set at the checkpoint.
int check_music[MAX_PLAYERS];		//Music that should play when respawning at the checkpoint.
int check_angle[MAX_PLAYERS];		//The angle a player faced when setting a checkpoint if that argument was set.
int check_specbehav[MAX_PLAYERS+1];	//How the invisible special plane is treated. (0: Water, 1: Bottomless Pit, 2: Lava)
int check_specheight[MAX_PLAYERS+1] = { -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024, -1024 };	//The height of the invisible plane.
int check_deathbehav[MAX_PLAYERS];	//Each player's "death behavior" at the last checkpoint.
int check_windspeed[MAX_PLAYERS];	//How powerful the wind is. Wind pulls players and precipitation around.
int check_wind_dir[MAX_PLAYERS];	//Where the wind is blowing. By default, it moves through a list.
int check_disablewind[MAX_PLAYERS];	//Whether wind affects Mary/Xane. If they're indoors and hit a checkpoint, this will be something higher than 0.

script "HandleDeath" ENTER	//Check for possible death/arrest.
{
	int playertid_stored;
	
	If(GameType()==GAME_NET_DEATHMATCH||GameType()==GAME_TITLE_MAP) Terminate;
	
	If(lives==0)lives = CONSTANT_1UP_INITIAL;	//The player can't start a level with no lives!
	int tics_death = 0;
	While(1)
	{
		Delay(2);
		
		If(GetActorProperty(0, APROP_Health)<=1||force_death[PlayerNumber()]==TRUE)
		{
			important_fade[PlayerNumber()] = TRUE;	//Tell flashing scripts to stop changing colors.
			force_death[PlayerNumber()] = FALSE;	//Prevent additional forced deaths after this.
			force_detransform[PlayerNumber()] = TRUE;	//Force a detransformation.
			Delay(3);
			
			//SetPlayerProperty(FALSE,ON,PROP_INVULNERABILITY);
			
			Switch(death_behavior[PlayerNumber()])
			{
			Case 0:
				StopSound(GetCurrentPlayerTID(),CHAN_5);
				PlaySound(GetCurrentPlayerTID(),"lgirl/death",CHAN_ITEM,1.0);
				tp_to_last_ground_position[PlayerNumber()] = FALSE;	//Prevent teleporting to the last safe ground location, forcing the checkpoint location instead.
				
				if(gamemode==3) { GiveInventory("Health",100); ACS_NamedExecute("ExitTransition",0,0,0,0); }	//Restart the "area" if dying in practice mode.
				
				While(tics_death<35)
				{
					FadeTo(0,0,0,1.0,0.5);	//Fade out the screen.
					Delay(1);
					StopSound(GetCurrentPlayerTID(),CHAN_7);
					StopSound(GetCurrentPlayerTID(),CHAN_VOICE);
					tics_death++;
				}
				tics_death = 0;
				
				ACS_NamedExecuteAlways("ConvertCoinTicsToCoins",0,0,0,0);
				TakeInventory("CoinSP",CheckInventory("CoinSP")/2);	//Take all of the player's coins away as a punishment! This'll also guarantee the player de-transforms.
				
				ACS_NamedExecuteAlways("LoadCheckpointInfo",0,TRUE,0,0);	//Load all of the player's information stored at the last checkpoint and take a life away.
				
				Delay(2);
				
				If(lives<=0) { ACS_NamedExecuteAlways("PlayFMV",0,1,209,0); }
				
				Else While(tics_death<35)
				{
					FadeTo(0,0,0,0.0,0.5);	//Fade in the screen.
					Delay(1);
					StopSound(GetCurrentPlayerTID(),CHAN_7);
					StopSound(GetCurrentPlayerTID(),CHAN_VOICE);
					tics_death++;
				}  
				tics_death = 0;
				
				death_behavior[PlayerNumber()] = check_deathbehav[PlayerNumber()];	//Restore the player's death behavior last to prevent glitches.
				
				Autosave();
			Break;
			Case 1:	//HCPD Arrest (MAP1 only)
				force_death[PlayerNumber()] = TRUE;	//This is used to fix the "avoiding jail" glitch.
				ACS_NamedExecuteAlways("MoveBars",0,TRUE,0,0);
				While(tics_death<35)
				{
					FadeTo(0,0,0,1.0,0.5);	//Fade out the screen.
					Delay(1);
					tics_death++;
				}
				
				playertid_stored = GetCurrentPlayerTID();
				
				ACS_NamedExecuteAlways("StoreWantedLevel",0,ACS_NamedExecuteWithResult("GetWantedLevel",0,0,0,0),0,0);
				ACS_NamedExecuteAlways("ForceWantedLevel",0,0,0,1);
				SetActivator(1000, AAPTR_PLAYER1); { SetActorProperty(GetCurrentPlayerTID(),APROP_Health,100); ACS_NamedExecuteAlways("SetSpecial",0,1,-999,0); }
				SetActivator(1001, AAPTR_PLAYER2); { SetActorProperty(GetCurrentPlayerTID(),APROP_Health,100);  ACS_NamedExecuteAlways("SetSpecial",0,1,-999,0); }
				SetActivator(1002, AAPTR_PLAYER3); { SetActorProperty(GetCurrentPlayerTID(),APROP_Health,100);  ACS_NamedExecuteAlways("SetSpecial",0,1,-999,0); }
				SetActivator(1003, AAPTR_PLAYER4); { SetActorProperty(GetCurrentPlayerTID(),APROP_Health,100);  ACS_NamedExecuteAlways("SetSpecial",0,1,-999,0); }
				SetActivator(1004, AAPTR_PLAYER5); { SetActorProperty(GetCurrentPlayerTID(),APROP_Health,100);  ACS_NamedExecuteAlways("SetSpecial",0,1,-999,0); }
				SetActivator(1005, AAPTR_PLAYER6); { SetActorProperty(GetCurrentPlayerTID(),APROP_Health,100);  ACS_NamedExecuteAlways("SetSpecial",0,1,-999,0); }
				SetActivator(1006, AAPTR_PLAYER7); { SetActorProperty(GetCurrentPlayerTID(),APROP_Health,100);  ACS_NamedExecuteAlways("SetSpecial",0,1,-999,0); }
				SetActivator(1007, AAPTR_PLAYER8); { SetActorProperty(GetCurrentPlayerTID(),APROP_Health,100);  ACS_NamedExecuteAlways("SetSpecial",0,1,-999,0); }
				SetActorPosition(1000,GetActorX(45),GetActorY(45),GetActorFloorZ(45),FALSE);
				SetActorPosition(1001,GetActorX(46),GetActorY(46),GetActorFloorZ(46),FALSE);
				SetActorPosition(1002,GetActorX(47),GetActorY(47),GetActorFloorZ(47),FALSE);
				SetActorPosition(1003,GetActorX(48),GetActorY(48),GetActorFloorZ(48),FALSE);
				SetActorPosition(1004,GetActorX(49),GetActorY(49),GetActorFloorZ(49),FALSE);
				SetActorPosition(1005,GetActorX(50),GetActorY(50),GetActorFloorZ(50),FALSE);
				SetActorPosition(1006,GetActorX(51),GetActorY(51),GetActorFloorZ(51),FALSE);
				SetActorPosition(1007,GetActorX(52),GetActorY(52),GetActorFloorZ(52),FALSE);
				SetActorAngle(1000,GetActorAngle(45));
				SetActorAngle(1001,GetActorAngle(46));
				SetActorAngle(1002,GetActorAngle(47));
				SetActorAngle(1003,GetActorAngle(48));
				SetActorAngle(1004,GetActorAngle(49));
				SetActorAngle(1005,GetActorAngle(50));
				SetActorAngle(1006,GetActorAngle(51));
				SetActorAngle(1007,GetActorAngle(52));
				TakeActorInventory(1000,"Key3",1);
				TakeActorInventory(1001,"Key3",1);
				TakeActorInventory(1002,"Key3",1);
				TakeActorInventory(1003,"Key3",1);
				TakeActorInventory(1004,"Key3",1);
				TakeActorInventory(1005,"Key3",1);
				TakeActorInventory(1006,"Key3",1);
				TakeActorInventory(1007,"Key3",1);
				Spawn("JailGuard",4864.01,-10784.01,-191.01,1075);
				tics_death = 0;
				SetActivator(1000, AAPTR_PLAYER1); ACS_NamedExecuteAlways("JailCry",0,0,0,0);
				SetActivator(1001, AAPTR_PLAYER2); ACS_NamedExecuteAlways("JailCry",0,0,0,0);
				SetActivator(1002, AAPTR_PLAYER3); ACS_NamedExecuteAlways("JailCry",0,0,0,0);
				SetActivator(1003, AAPTR_PLAYER4); ACS_NamedExecuteAlways("JailCry",0,0,0,0);
				SetActivator(1004, AAPTR_PLAYER5); ACS_NamedExecuteAlways("JailCry",0,0,0,0);
				SetActivator(1005, AAPTR_PLAYER6); ACS_NamedExecuteAlways("JailCry",0,0,0,0);
				SetActivator(1006, AAPTR_PLAYER7); ACS_NamedExecuteAlways("JailCry",0,0,0,0);
				SetActivator(1007, AAPTR_PLAYER8); ACS_NamedExecuteAlways("JailCry",0,0,0,0);
				ACS_NamedExecuteAlways("MoveBars",0,FALSE,TRUE,0);
				SetActivator(1000, AAPTR_PLAYER1); ACS_NamedExecuteAlways("RequestAmbience",0,2,0,0);
				SetActivator(1001, AAPTR_PLAYER2); ACS_NamedExecuteAlways("RequestAmbience",0,2,0,0);
				SetActivator(1002, AAPTR_PLAYER3); ACS_NamedExecuteAlways("RequestAmbience",0,2,0,0);
				SetActivator(1003, AAPTR_PLAYER4); ACS_NamedExecuteAlways("RequestAmbience",0,2,0,0);
				SetActivator(1004, AAPTR_PLAYER5); ACS_NamedExecuteAlways("RequestAmbience",0,2,0,0);
				SetActivator(1005, AAPTR_PLAYER6); ACS_NamedExecuteAlways("RequestAmbience",0,2,0,0);
				SetActivator(1006, AAPTR_PLAYER7); ACS_NamedExecuteAlways("RequestAmbience",0,2,0,0);
				SetActivator(1007, AAPTR_PLAYER8); ACS_NamedExecuteAlways("RequestAmbience",0,2,0,0);
				
				SetActivator(1000, AAPTR_PLAYER1); ACS_ExecuteAlways(254,0,ACS_NamedExecuteWithResult("GetSoundTestSong",0,0,0,0),FALSE,0);
				SetActivator(1001, AAPTR_PLAYER2); ACS_ExecuteAlways(254,0,ACS_NamedExecuteWithResult("GetSoundTestSong",0,0,0,0),FALSE,0);
				SetActivator(1002, AAPTR_PLAYER3); ACS_ExecuteAlways(254,0,ACS_NamedExecuteWithResult("GetSoundTestSong",0,0,0,0),FALSE,0);
				SetActivator(1003, AAPTR_PLAYER4); ACS_ExecuteAlways(254,0,ACS_NamedExecuteWithResult("GetSoundTestSong",0,0,0,0),FALSE,0);
				SetActivator(1004, AAPTR_PLAYER5); ACS_ExecuteAlways(254,0,ACS_NamedExecuteWithResult("GetSoundTestSong",0,0,0,0),FALSE,0);
				SetActivator(1005, AAPTR_PLAYER6); ACS_ExecuteAlways(254,0,ACS_NamedExecuteWithResult("GetSoundTestSong",0,0,0,0),FALSE,0);
				SetActivator(1006, AAPTR_PLAYER7); ACS_ExecuteAlways(254,0,ACS_NamedExecuteWithResult("GetSoundTestSong",0,0,0,0),FALSE,0);
				SetActivator(1007, AAPTR_PLAYER8); ACS_ExecuteAlways(254,0,ACS_NamedExecuteWithResult("GetSoundTestSong",0,0,0,0),FALSE,0);
				
				While(tics_death<35)
				{
					FadeTo(0,0,0,0.0,0.5);	//Fade in the screen.
					Delay(1);
					tics_death++;
				}
				force_death[0] = FALSE;	//This must be set to "false" now or else the player will be kicked out of jail!
				force_death[1] = FALSE;
				force_death[2] = FALSE;
				force_death[3] = FALSE;
				force_death[4] = FALSE;
				force_death[5] = FALSE;
				force_death[6] = FALSE;
				force_death[7] = FALSE;
				Ceiling_LowerByValue(64,16,32);
				SetActorProperty(GetCurrentPlayerTID(),APROP_Health,100);
				tics_death = 0;
				ACS_NamedExecuteAlways("ShowTutorial",0,8,0,0);
				SetActivator(1000, AAPTR_PLAYER1); SetActorProperty(GetCurrentPlayerTID(),APROP_Health,100);
				SetActivator(playertid_stored);
			Break;
			Case 2:	//Arena "death"
				ACS_NamedExecute("ArenaResult",0,FALSE,0,0);	//Fail the arena.
				SetActorProperty(0, APROP_Health, 100);
				Delay(350);
			Break;
			}
			important_fade[PlayerNumber()] = FALSE;	//Tell flashing scripts to resume changing colors.
			
		}
	
	}

}

script "EnemyAutoJump" (int avoid, int dodges, int ticdelay)
/* This script makes enemies automatically jump over objects. Give "DisableAutoJump" to the enemy to prevent jumping.
 *
 * Make sure to use argument 1 properly, as flags. Add the numbers together to form the value which will determine what triggers the jumps.
 *
 * ANY PROJECTILE: No matter how weak, any of Mary's projectiles she shoots from her wand will make enemies avoid her.
 * STRONG PROJECTILES: Fireballs and deadly things like burning people will make this enemy avoid them.
 * PLAYERS: Just you approaching this enemy will make the enemy avoid you!
 * 1: Any; 2: Strong; 3: Players
 * 4: Any/Strong; 5: Any/Players
 * 6: Strong/Players; 7: All
 *
 * Argument 2 is the number of times a dodge can happen before they stop.
 * Argument 3 is the amount of tics inbetween each dodge.
 */
{
	If(avoid<0||dodges<-1||dodges==0) { Log(s:"ERROR: ", s:GetActorClass(0), s:" didn't specify dodging arguments in EnemyAutoJump!"); Terminate; }
	If(ticdelay<=0) ticdelay = 17;
	int dodged = 0;	//How many times this enemy has dodged an attack.
	bool just_dodged = FALSE;	//Whether this enemy just did a dodge.
	While(GetActorProperty(0, APROP_Health)>0)
	{
		While(CheckInventory("DisableAutoJump")==FALSE&&GetActorProperty(0, APROP_Health)>0)
		{
			If((CheckActorClass(0, "Cop1")||CheckActorClass(0, "Cop3")||CheckActorClass(0, "Cop4"))&&CheckInventory("Variable3")) { TakeInventory("Variable3",1); SetActorState(0, "Pain.Stun"); }
			If(ACS_NamedExecuteWithResult("DetermineAutoJump",avoid,0,0,0)==TRUE&&dodged<dodges)
			{
				If(CheckInventory("Projectile1"))		//Log(s:"Weak projectile detected.");
				TakeInventory("Projectile1",1);
				If(CheckInventory("Projectile2"))		//Log(s:"Strong projectile detected.");
				TakeInventory("Projectile2",1);
				If(CheckInventory("ProjectilePlayers"))	//Log(s:"Player detected!");
				TakeInventory("ProjectilePlayers",1);
				If(SetActorState(0, "Dodge")==0) { Delay(1); SetActorState(0, "Dodge"); }
				dodged++;
				just_dodged = TRUE;	//Mark this enemy as dodged.
				Delay(ticdelay);
			}
			Delay(1);
			if(just_dodged==FALSE&&dodged>0) { dodged--; Delay(3); }	//If the enemy didn't just dodge an attack, decrease the counter.
			just_dodged = FALSE;	//After the check, set the variable to FALSE.
		}
		Delay(1);
	}
}

script "DetermineAutoJump" (int avoid_carry, int dodges_carry)
{
	If((avoid_carry==1||avoid_carry==4||avoid_carry==5||avoid_carry==7)&&CheckInventory("Projectile1")) { SetResultValue(TRUE); If(dodges_carry==-1&&GetActorZ(0)-GetActorFloorZ(0)>4.5) SetResultValue(FALSE); }
	Else If((avoid_carry==2||avoid_carry==4||avoid_carry==6||avoid_carry==7)&&CheckInventory("Projectile2")) { SetResultValue(TRUE); If(dodges_carry==-1&&GetActorZ(0)-GetActorFloorZ(0)>4.5) SetResultValue(FALSE); }
	Else If((avoid_carry==3||avoid_carry==5||avoid_carry==6||avoid_carry==7)&&CheckInventory("ProjectilePlayers")) { SetResultValue(TRUE); If(dodges_carry==-1&&GetActorZ(0)-GetActorFloorZ(0)>4.5) SetResultValue(FALSE); }
	Else SetResultValue(FALSE);
}

script "SetCheckpoint" (int spawn_tid, int set_angle)
{
	If(checkpoint_id[PlayerNumber()]==spawn_tid) Terminate;
	if(set_angle) //check_angle[PlayerNumber()] = GetActorAngle(GetCurrentPlayerTID());
	{
		If(LineSide()==LINE_FRONT) check_angle[PlayerNumber()] = -1;
		Else check_angle[PlayerNumber()] = GetActorAngle(spawn_tid) + 0.5;
	}
	else check_angle[PlayerNumber()] = -1;
	
	checkpoint_id[PlayerNumber()] = spawn_tid;
	
	Autosave();
	Delay(5);
	if(spawn_tid!=616)
	{
		HUDMessageBold(l:"TXT_CHECKPOINT";
			HUDMSG_TYPEON, 1, CR_GOLD, 0.5, 0.33, 1.5, 0.025, 0.75);
		Delay(20);
		HUDMessageBold(l:"TXT_CHECKPOINT";
			HUDMSG_FADEINOUT, 0, CR_WHITE, 0.5, 0.33, 0.01, 0.175, 0.175);
	}
	
	checkpoint_id[MAX_PLAYERS] = spawn_tid;	//Set array index 8 for enemies to respawn from when falling in pits.

	check_weather[PlayerNumber()] = rain_mode[PlayerNumber()];
	check_ambience[PlayerNumber()] = amb_current[PlayerNumber()];
	wind_disabledelay[PlayerNumber()] = 0;
	check_wind_dir[PlayerNumber()] = direction[PlayerNumber()];
	check_windspeed[PlayerNumber()] = wind_power[PlayerNumber()];
	check_disablewind[PlayerNumber()] = disablewind[PlayerNumber()];
	
	check_specbehav[PlayerNumber()] = specialbehavior[PlayerNumber()];	//Store the player's current special plane behavior and its height.
	check_specheight[PlayerNumber()] = specialheight[PlayerNumber()];
	
	//Only store the current music if the player isn't drowning.
	If(ACS_ExecuteWithResult(256,0,0,0,0)!=11) check_music[PlayerNumber()] = ACS_ExecuteWithResult(256,0,0,0,0);

}

script "LoadCheckpointInfo" (int deathx)
{
	If(deathx==FALSE) ACS_ExecuteAlways(254,0,check_music[PlayerNumber()],FALSE,FALSE);
	Else ACS_ExecuteAlways(254,0,check_music[PlayerNumber()],FALSE,TRUE);
	specialbehavior[PlayerNumber()] = check_specbehav[PlayerNumber()];	//Restore the player's special plane behavior and height before teleporting them!
	specialheight[PlayerNumber()] = check_specheight[PlayerNumber()];
	specialbehavior[MAX_PLAYERS] = check_specbehav[PlayerNumber()];		//Also restore it for monsters.
	specialheight[PlayerNumber()] = check_specheight[PlayerNumber()];
	
	If(deathx==TRUE) lives--;	//If dying, take away a life.
	SetActorPitch(0, 0);	//Force the player to look directly ahead.
	
	if(checkpoint_id[PlayerNumber()]==0) { checkpoint_id[PlayerNumber()] = 616; checkpoint_id[MAX_PLAYERS] = 616; }
	If(tp_to_last_ground_position[PlayerNumber()]==FALSE) { Teleport(checkpoint_id[PlayerNumber()],0,FALSE); }	//After teleporting, load all info saved at the checkpoint!
	Else { If(SetActorPosition(0, last_ground_position[PlayerNumber()],last_ground_position[MAX_PLAYERS+PlayerNumber()],last_ground_position[(MAX_PLAYERS*2)+PlayerNumber()],FALSE)==FALSE) { Teleport(checkpoint_id[PlayerNumber()],0,FALSE); tp_to_last_ground_position[PlayerNumber()] = FALSE; } }
	If(tp_to_last_ground_position[PlayerNumber()]==TRUE) SetActorAngle(0, last_ground_position[(MAX_PLAYERS*3)+PlayerNumber()]);	//If returning from a Special Stage or Small Hut, make the player face the correct position!
	
	combo[PlayerNumber()] = 0;
	meter[PlayerNumber()] = 0;
	meter[PlayerNumber()+MAX_PLAYERS] = 0;
	meter[PlayerNumber()+(MAX_PLAYERS*2)] = 0;
	
	ACS_NamedExecuteAlways("SetWind",0,0,check_wind_dir[PlayerNumber()],0);	//Wind direction
	ACS_NamedExecuteAlways("SetWind",0,1,check_windspeed[PlayerNumber()],0);	//Wind speed/power
	disablewind[PlayerNumber()] = check_disablewind[PlayerNumber()];	//Disabled wind state
	If(deathx==TRUE)SetActorProperty(GetCurrentPlayerTID(),APROP_Health,100);
	
	if(check_angle[PlayerNumber()]!=-1&&tp_to_last_ground_position[PlayerNumber()]==FALSE) SetActorAngle(GetCurrentPlayerTID(), check_angle[PlayerNumber()]);	//Including stored angle, if set.
	
	ACS_NamedExecuteAlways("RequestAmbience",0,check_ambience[PlayerNumber()],0,0);
	ACS_ExecuteAlways(311,0,check_weather[PlayerNumber()],0,0);
	tp_to_last_ground_position[PlayerNumber()] = FALSE;	//Turn this of to prevent any glitches with later checkpoints.
}

//This script determines whether an enemy is touching a "special plane" like water, a bottomless pit, or lava.
//The third argument controls which it won't trigger for. 0: None, 1: Water, 2: Pit, 3: Lava.
script "GetSpecialStatus" (int depth, int mode, int immunity)	//Used for enemies and objects to check if they're even BARELY touching water, bottomless pits, and lava. Immunity determines which the activator won't be affected by.
{
	If(depth<=0) depth = 32;
	depth += 0.1;
	
	If(mode==FALSE)
	{
		If(GetActorZ(0)-depth<specialheight[MAX_PLAYERS]&&specialbehavior[MAX_PLAYERS]!=immunity-1) SetResultValue(3);	//3 due to cops checking for the water level. If making a new monster, make them check for > 0.
		Else SetResultValue(0);
	}
	Else
	{
		If(GetActorZ(0)-depth<specialheight[MAX_PLAYERS]&&specialbehavior[MAX_PLAYERS]==0) GiveInventory("Variable2",1);	//Tell the enemy they are in water.
	}
}

script "SpecialFall" (int native_type, int wlevel_death)	//-1 = kill by all, 0: Water enemy, 2: Lava enemy. wlevel_death is what water level will kill them on.
{
int divide = 5;
int mod_type = 9;

	If(native_type==1) native_type = -1;	//No monster can be "native" to bottomless pits!
	
	If(specialbehavior[MAX_PLAYERS]==native_type) Terminate;
	
	Switch(specialbehavior[MAX_PLAYERS])
	{
		Case 0:	//Water
			divide = 4;
			mod_type = 12;
			Thing_Damage(0, GetActorProperty(0, APROP_SpawnHealth)/4, mod_type);
		Break;
		Case 1:	//Bottomless Pit
			divide = 3;
			mod_type = 17;
			Thing_Damage(0, GetActorProperty(0, APROP_SpawnHealth)/2, mod_type);
		Break;
		Case 2:	//Lava
			divide = 4;
			mod_type = 14;
			Thing_Damage(0, GetActorProperty(0, APROP_SpawnHealth)/3, mod_type);
		Break;
		Default:
			Log(s:"An unknown special behavior is set, ", d:specialbehavior[MAX_PLAYERS], s:".");
		Break;
	}
	
	If(GetActorProperty(0, APROP_Health)>(GetActorProperty(0, APROP_SpawnHealth) / divide))
	{
		SetActorPosition(0, GetActorX(checkpoint_id[MAX_PLAYERS]), GetActorY(checkpoint_id[MAX_PLAYERS]), GetActorZ(checkpoint_id[MAX_PLAYERS]), FALSE);
		SetActorAngle(0, checkpoint_id[MAX_PLAYERS]);	//Teleport the monster if they have enough health left.
	}
	Else
	{
		If(specialbehavior[MAX_PLAYERS]==1) Thing_Remove(0);	//If this is a bottomless pit, remove the monster instead of killing them.
		Else Thing_Damage(0, GetActorProperty(0, APROP_Health), mod_type);	//If the monster is hurt enough, kill them instead.
	}
}

script "SetDeathBehavior" (int behavior) { death_behavior[PlayerNumber()] = behavior; }

script "GiveSRWeapons" (int set)	//Gives weapons for differsent parts of speedruns.
//-1: All weapons (practice). Time attack shouldn't use this in the future.
{
	For(int playaz = 0; playaz < PlayerCount(); playaz++)
	{
		TakeInventory("MaryUmbrella",1);
		TakeInventory("MaryHammer",1);
		TakeInventory("MaryWand",1);
		
		TakeInventory("XaneSword",1);
		
		Delay(1);
		
		Switch(PlayerClass(playaz))
		{
			Case CHAR_MARY:
				If(set==-1) GiveInventory("MaryWand",1);
				If(set==-1) GiveInventory("MaryHammer",1);
				GiveInventory("MaryUmbrella",1);
			Break;
			Case CHAR_XANE:
				GiveInventory("XaneSword",1);
			Break;
		}
	}
}

//////////////////////////////
//Mary's hammer and umbrella//
//////////////////////////////

bool mhammer_spin_spd[MAX_PLAYERS];	//Current spinning speed.
int walldetected[MAX_PLAYERS];
bool flight_mode[MAX_PLAYERS];/* The current mode of umbrella flight.
					 *
					 * FALSE: Flying with umbrella up.
					 * TRUE: Flying with umbrella down.
					 */
bool flight_script_running[MAX_PLAYERS];	//Indicates whether the flight script is still running.
bool updateUmbrellaFlightVelocity[MAX_PLAYERS];
bool flight_mod[MAX_PLAYERS];

script "MaryHammer_AltFire" (int mode, int set)
{
Switch(mode)
	{
	Case 0:	//Set variable
	
	If(set==0)
	{
		ACS_NamedExecuteAlways("MaryHammer_DetermineDirection",0,0,0,0);
	}
	
	if(set==5) { flight_mod[PlayerNumber()] = 1; set = 2; }
	
	If(set==2)
	{ 
		
		If(flight_mode[PlayerNumber()]==TRUE&&flight_script_running[PlayerNumber()]==TRUE) { flight_mode[PlayerNumber()] = FALSE; updateUmbrellaFlightVelocity[PlayerNumber()] = TRUE; }	//Indicate Mary's umbrella is up.
		Else { flight_mode[PlayerNumber()] = FALSE; ACS_NamedExecuteAlways("MaryHammer_HandleMidAir",0,0,0,0); }	//Execute the script if needed.
	}
	
	If(set==3) { flight_mode[PlayerNumber()] = TRUE; updateUmbrellaFlightVelocity[PlayerNumber()] = TRUE; }
	
	If(set==4) hammermove[PlayerNumber()] = 13; spring[PlayerNumber()] = TRUE;
	
	Break;
	Case 1:	//Return a value.
	if(set==1)
		{
		If(abs(GetActorVelX(GetCurrentPlayerTID()))>6.0||abs(GetActorVelY(GetCurrentPlayerTID()))>6.0) SetResultValue(TRUE);
		Else SetResultValue(FALSE);
		}
	Break;
	}
}

int umbvel_raised[2] = { -4.25, -3.5 };
int umbvel_lowered[2] = { -12.5, -10.75 };
int umbvel_change[2] = { 0.25, 0.23 };

script "MaryHammer_HandleMidAir" (void)	//This script is used by the umbrella, contrary to its name.
{
updateUmbrellaFlightVelocity[PlayerNumber()] = FALSE;
bool bounced = FALSE;	//If Mary has hit a ceiling during her current flight.
bool up_or_down = TRUE;	//Whether the player is going up (TRUE) or down (FALSE).
if(walljumping[PlayerNumber()]>0) { GiveActorInventory(GetCurrentPlayerTID(),"MaryHammer_MidAirDone",1); flight_script_running[PlayerNumber()] = FALSE; Terminate; }
hammermove[PlayerNumber()] = 5;
detected[PlayerNumber()] = 2;	//Disable Mary's Air Dash as it makes no sense when using her umbrella.
flight_script_running[PlayerNumber()] = TRUE;	//Let the calling script above know we're now flying.
SetActorProperty(GetCurrentPlayerTID(),APROP_Gravity,GetActorProperty(GetCurrentPlayerTID(),APROP_Gravity)/2);
SetAirControl(0.34);
ACS_NamedExecuteAlways("PlayWindSound",0,GetCurrentPlayerTID(),0,0);
TakeInventory("MaryUmbrella_Air",1);

int velocity[3] = { 0.01, 0.01, 0.01 };	//Velocities; [0]: Current, [1] = Requested, [2] Currently reaching
SetActorVelocity(GetCurrentPlayerTID(),GetActorVelX(GetCurrentPlayerTID()),GetActorVelY(GetCurrentPlayerTID()),GetActorVelZ(GetCurrentPlayerTID()),FALSE,TRUE);

If(flight_mod[PlayerNumber()]==0)
{
	If(GetActorVelZ(0)>=-15.25) { velocity[0] = abs(GetActorVelZ(GetCurrentPlayerTID()))/2; velocity[2] = 5.25; }	//Upward momentum
	Else { velocity[0] = GetActorVelZ(GetCurrentPlayerTID())/3; velocity[2] = (abs(GetActorVelZ(0))+GetActorVelZ(0)/7)/2; }	//"Swoop"
}
Else If(flight_mod[PlayerNumber()]==1) { velocity[0] = 9.5; velocity[1] = 15.25; velocity[1] = 15.25; }

Delay(1);

While(GetActorZ(GetCurrentPlayerTID())-GetActorFloorZ(GetCurrentPlayerTID())>16.0&&CheckActorInventory(GetCurrentPlayerTID(),"MaryHammer_Water")==FALSE)
	{
	Delay(1);
	hammermove[PlayerNumber()] = 5;
	If(wind_power[PlayerNumber()]>2&&disablewind[PlayerNumber()]==FALSE) no_movement[PlayerNumber()] = 2;	//If the wind is strong, don't let Mary push against it...humans can't do that!	If wind is disabled, don't care about the wind!
	
	If(WaterLevel(0)>0) GiveActorInventory(GetCurrentPlayerTID(),"MaryHammer_Water",1);
		
	If(CheckInventory("MaryUmbrella_Air")&&flight_mode[PlayerNumber()]==FALSE)	//Air current
	{
		velocity[1] = 2.5+(abs(umbvel_raised[CheckInventory("SuperX")]));
		TakeInventory("MaryUmbrella_Air",1);
	}
	Else
	{
		If(CheckActorInventory(GetCurrentPlayerTID(),"SuperX")==FALSE)	//Flying (untransformed)
		{
		If(flight_mode[PlayerNumber()]==FALSE) velocity[1] = umbvel_raised[CheckInventory("SuperX")];
		Else  velocity[1] = umbvel_lowered[CheckInventory("SuperX")];
		}
		Else	//Flying (transformed)
		{
		If(flight_mode[PlayerNumber()]==FALSE) velocity[1] = umbvel_raised[CheckInventory("SuperX")]-1.05;
		Else  velocity[1] = umbvel_lowered[CheckInventory("SuperX")]-0.5;
		}
	}
	
	//PrintBold(s:"CUR: ", f:velocity[0], s:"\nEXPECT: ", f:velocity[2], s:"\nREQ: ", f:velocity[1]);
	
	If(velocity[0]<velocity[2]) { velocity[0] += umbvel_change[CheckInventory("SuperX")]+0.1; up_or_down = TRUE; }	//Up
	Else /*If(velocity[0]>velocity[2])*/ { velocity[0] -= umbvel_change[CheckInventory("SuperX")]; up_or_down = FALSE; }	//Down
	
	If(up_or_down==TRUE&&velocity[0]>=velocity[2]) velocity[2] = velocity[1];
	If((up_or_down==FALSE&&velocity[0]<=velocity[2])||(velocity[0]<-2.25&&CheckInventory("MaryUmbrella_Air")==TRUE)) velocity[2] = velocity[1];
	
	If(GetActorCeilingZ(0)-GetActorZ(0)<64.5&&GetActorVelZ(0)>1.25&&bounced==FALSE) { bounced = TRUE; velocity[0] = -(GetActorVelZ(0))/2; updateUmbrellaFlightVelocity[PlayerNumber()] = TRUE; PlaySound(GetCurrentPlayerTID(), "misc/hit_ceiling", CHAN_WEAPON, 0.8, FALSE, 0.8); }
	If(updateUmbrellaFlightVelocity[PlayerNumber()]) { velocity[2] = velocity[1]; updateUmbrellaFlightVelocity[PlayerNumber()] = FALSE; }
	
	//if(bounced_tics>0) bounced_tics--;
	
	SetActorVelocity(GetCurrentPlayerTID(),GetActorVelX(GetCurrentPlayerTID()),GetActorVelY(GetCurrentPlayerTID()),velocity[0],FALSE,TRUE);
	If(GetActorVelX(GetCurrentPlayerTID())>12.0) SetActorVelocity(GetCurrentPlayerTID(),GetActorVelX(GetCurrentPlayerTID())-0.25,GetActorVelY(GetCurrentPlayerTID()),GetActorVelZ(GetCurrentPlayerTID()),FALSE,TRUE);
	If(GetActorVelX(GetCurrentPlayerTID())<-12.0) SetActorVelocity(GetCurrentPlayerTID(),GetActorVelX(GetCurrentPlayerTID())+0.25,GetActorVelY(GetCurrentPlayerTID()),GetActorVelZ(GetCurrentPlayerTID()),FALSE,TRUE);
	If(GetActorVelY(GetCurrentPlayerTID())>12.0) SetActorVelocity(GetCurrentPlayerTID(),GetActorVelX(GetCurrentPlayerTID()),GetActorVelY(GetCurrentPlayerTID())-0.25,GetActorVelZ(GetCurrentPlayerTID()),FALSE,TRUE);
	If(GetActorVelY(GetCurrentPlayerTID())<-12.0) SetActorVelocity(GetCurrentPlayerTID(),GetActorVelX(GetCurrentPlayerTID()),GetActorVelY(GetCurrentPlayerTID())+0.25,GetActorVelZ(GetCurrentPlayerTID()),FALSE,TRUE);
	}

flight_mod[PlayerNumber()] = 0;
hammermove[PlayerNumber()] = 5;
SetActorProperty(GetCurrentPlayerTID(),APROP_Gravity,GetActorProperty(GetCurrentPlayerTID(),APROP_Gravity)*2);
SetAirControl(0.00390625);
TakeActorInventory(GetCurrentPlayerTID(),"MaryHammer_Water",1);

ACS_NamedExecuteAlways("PlayWindSound",0,GetCurrentPlayerTID(),1,0);
flight_script_running[PlayerNumber()] = FALSE;	//Now we're done flying!
}

script "MaryHammer_DetermineDirection" (void)
{
	mhammer_spin_spd[PlayerNumber()] = -0.03;
	SetActorAngle(GetCurrentPlayerTID(),GetActorAngle(GetCurrentPlayerTID())+mhammer_spin_spd[PlayerNumber()]);
	Delay(1);
	mhammer_spin_spd[PlayerNumber()] = -0.07;
	SetActorAngle(GetCurrentPlayerTID(),GetActorAngle(GetCurrentPlayerTID())+mhammer_spin_spd[PlayerNumber()]);
	Delay(1);
	mhammer_spin_spd[PlayerNumber()] = -0.12;
	SetActorAngle(GetCurrentPlayerTID(),GetActorAngle(GetCurrentPlayerTID())+mhammer_spin_spd[PlayerNumber()]);
	Delay(1);
	mhammer_spin_spd[PlayerNumber()] = -0.15;
	SetActorAngle(GetCurrentPlayerTID(),GetActorAngle(GetCurrentPlayerTID())+mhammer_spin_spd[PlayerNumber()]);
	Delay(1);
	
	Until(CheckInventory("MaryHammer_MidAirDone"))
	{
		mhammer_spin_spd[PlayerNumber()] += 0.003;
		SetActorAngle(GetCurrentPlayerTID(),GetActorAngle(GetCurrentPlayerTID())+mhammer_spin_spd[PlayerNumber()]);
		Delay(1);
		
		if(mhammer_spin_spd[PlayerNumber()]>-0.025) GiveActorInventory(GetCurrentPlayerTID(),"MaryHammer_MidAirDone",1);
	}
	
	SetActorAngle(GetCurrentPlayerTID(),GetActorAngle(GetCurrentPlayerTID())+mhammer_spin_spd[PlayerNumber()]);
}

///////////////
//XANE'S CLAW//
///////////////

#define MAX_CHAINS 50

int parts_spawned[MAX_PLAYERS];
bool clawGrabbingWall = FALSE;
int wjtics[MAX_PLAYERS];
script "ClawGenerate" (int player_number)	//Called by the "claw" to spawn parts behind it that the player will use when moving towards the end.
{
	int old_gravity,  play_x, play_y, play_z;	//Gravity before the claw activated.
	play_x = GetActorX(1000+player_number);
	play_y = GetActorY(1000+player_number);
	play_z = GetActorZ(1000+player_number);
	//if(clawGrabbingWall) { ACS_NamedTerminate("ClawGrabWall",0); clawGrabbingWall = FALSE; }	//This script breaks claw functionality.
	/*else*/ old_gravity = GetActorProperty(0, APROP_Gravity);
	
	SetActorPosition(1000+player_number, play_x, play_y, play_z, FALSE);
	SetActorVelocity(1000+player_number, 0.001, 0.001, 0.001, FALSE, FALSE);
	
	int claw_tid = UniqueTID;	//Generate a thing ID for the claw.
	Thing_ChangeTID(0, claw_tid);	//Change the claw's thing ID.
	
	SetActivator(1000+player_number, AAPTR_DEFAULT);	//Change to detect based on claw in the final.
	ACS_NamedExecuteAlways("PlayerMovement",0,TRUE,FALSE,FALSE);	//Lock the player in place while this happens...
	SetActorProperty(0, APROP_Gravity, 0.0); //...and get rid of their gravity.
	
	//SetActivator(claw_tid, AAPTR_DEFAULT);	//Change to detect based on claw in the final.
	bool not_moved = FALSE, continue_x = TRUE, enemy = FALSE;
	int previous_x;
	While(parts_spawned[PlayerNumber()]<MAX_CHAINS&&not_moved==FALSE)
	{
		SpawnForced("ClawChain",GetActorX(claw_tid),GetActorY(claw_tid),GetActorZ(claw_tid),UniqueTID(1500+(MAX_CHAINS*player_number),MAX_CHAINS),GetActorAngle(claw_tid)>>8);
		//previous_x = GetActorX(claw_tid);	//Store this to see if the chain stops.
		parts_spawned[PlayerNumber()]++;	//Spawn each chain piece and keep track of them.
		SetActorPosition(1000+player_number, play_x, play_y, play_z, FALSE);
		SetActorVelocity(1000+player_number, 0.001, 0.001, 0.001, FALSE, FALSE);
		Delay(1);
		If(GetActorVelX(claw_tid)==0.0||GetActorVelY(claw_tid)==0.0||GetActorVelZ(claw_tid)==0.0) not_moved = TRUE;	//If its X position is identical, it might have stopped!
		//if(GetActorX(claw_tid)==previous_x) not_moved = TRUE;	//If its X position is identical, it might have stopped!
	}
	Delay(1);
	If(ThingCount(T_NONE,1010)>0) { enemy = TRUE; Log(s:"ERROR: Hostile enemy detected!"); }	//An enemy was hurt if a TID of 1010 exists.
	
	If(parts_spawned[PlayerNumber()]>=MAX_CHAINS||enemy==TRUE)
	{
		If(1/*GetActorVelX(claw_tid)!=0.0||GetActorVelY(claw_tid)!=0.0||GetActorVelZ(claw_tid)!=0.0*/)
		{
			If(enemy==TRUE) { GiveActorInventory(claw_tid, "Variable1", 1);  }
			For(int clawparts = 1500+(MAX_CHAINS*player_number)+parts_spawned[player_number]; clawparts >= 1500+(MAX_CHAINS*(player_number)); clawparts--)
			{
				SetActorPosition(1000+player_number, play_x, play_y, play_z, FALSE);
				SetActorVelocity(1000+player_number, 0.001, 0.001, 0.001, FALSE, FALSE);
				
				Thing_Remove(clawparts);
				Delay(1);
			}
			continue_x = FALSE;	//Don't run the rest of the code.
		}
	}
	
	SetActivator(1000+player_number, AAPTR_DEFAULT);	//Change to detect based on claw in the final.
	
	If(continue_x==TRUE)	//If the claw didn't reach its limit or hit an enemy...
	{
		Delay(2);	//...after a delay, drag the player along the chain as each "link" is removed.
		
		For(int clawparts_follow = 1500+(25*player_number); clawparts_follow < 1500+(25*(player_number))+parts_spawned[PlayerNumber()]; clawparts_follow++)
		{
			If(clawparts_follow<1500+(25*(player_number))+(parts_spawned[PlayerNumber()]-1)) { SetActorPosition(0, GetActorX(clawparts_follow), GetActorY(clawparts_follow), GetActorZ(clawparts_follow), FALSE); SetActorAngle(0, GetActorAngle(clawparts_follow)); }
			Else If(enemy==TRUE) { GiveInventory("BounceRequested",1); }
			//If(clawparts_follow<1500+(25*(player_number))+(parts_spawned[PlayerNumber()])) ThrustThing(GetActorAngle(0) >> 8, 4, TRUE, 0);	//If on the last chain set, send the player towards the wall they SHOULD be facing.
			Thing_Remove(clawparts_follow);
			Delay(1);
		}
		
		Delay(1);
		//If(abs(GetActorZ(0)-GetActorFloorZ(0))>48.5) ACS_NamedExecute("ClawGrabWall",0,0,0,0);
	}
	
	If(old_gravity>0) SetActorProperty(0, APROP_Gravity, old_gravity);	//Restore the player's gravity.
	Else SetActorProperty(0, APROP_Gravity, 1.0);
	//SetActivator(claw_tid, AAPTR_DEFAULT);	//Change to detect based on claw in the final.
	Thing_Remove(claw_tid);	//Also, remove the claw.
	
	If(continue_x==TRUE)
	{
		SetActorVelocity(0, 0.0, 0.0, 0.0, FALSE, FALSE);
		ThrustThingZ(0, 15, FALSE, TRUE);
		Delay(1);
		ThrustThingZ(0, 12, FALSE, TRUE);
		Delay(1);
		ThrustThingZ(0, 10, FALSE, TRUE);
		Delay(1);
		ThrustThingZ(0, 9, FALSE, TRUE);
		Delay(1);
		ThrustThingZ(0, 8, FALSE, TRUE);
		Delay(2);
		ThrustThing(GetActorAngle(0)>>8, 7, FALSE, 0);
	}
	ACS_NamedExecuteAlways("PlayerMovement",0,FALSE,FALSE,FALSE);	//Unlock the player.
	//hammermove[PlayerNumber()] = 35;
	parts_spawned[PlayerNumber()] = 0;	//Reset this or the claw will never function again!
}

script "ClawCancel" (int claw_tid)
{
	Thing_Remove(claw_tid);	//Also, remove the claw.
	ACS_NamedExecuteAlways("PlayerMovement",0,FALSE,FALSE,FALSE);	//Unlock the player.
	For(int clawparts = 1500+(MAX_CHAINS*PlayerNumber()); clawparts < 1500+(MAX_CHAINS*(PlayerNumber()+1)); clawparts++) Thing_Remove(clawparts);
}

/*script "ClawGrabWall" (void)
{
	int cx = GetActorX(0), cy = GetActorY(0), cz = GetActorZ(0), i = 70;
	clawGrabbingWall = TRUE;
	While(i>0) { SetActorProperty(0, APROP_Gravity, 0.0); If(movement[MAX_PLAYERS+PlayerNumber()]>0) i = 0; SetActorPosition(0, cx, cy, cz, FALSE); i--; Delay(1); }
	SetActorProperty(0, APROP_Gravity, 1.0);
	SetActorVelocity(0,0.0,0.0,0.0,FALSE,FALSE);
	clawGrabbingWall = FALSE;
}*/

script "CheckClawUse" (void)
{
	SetResultValue(TRUE);	//Initially allow the claw, but then check for problems.
	If(GetActorZ(0)-GetActorFloorZ(0)>0.01) { Log(s:"\c[Brick]The claw can't be used in the air."); LocalAmbientSound("misc/buzzer",255); SetResultValue(FALSE); }
	Else If(abs(GetActorVelX(0))>2.5||abs(GetActorVelY(0))>2.5) { Log(s:"\c[Brick]The claw can't be used while moving."); LocalAmbientSound("misc/buzzer",255); SetResultValue(FALSE); }
}

int claw_verify_tics = 0;

script "ClawVerify" (int mode)
{
	//0: Verify attachment to a valid "hook" point
	//1: Check whether said verification occurred
	//2: Temporarily stop the player.
	
	Switch(mode)
	{
		Case 0: claw_verify_tics = 25; Break;
		Case 1: If(claw_verify_tics>0) { SetResultValue(TRUE); } Else SetResultValue(FALSE); Log(d:claw_verify_tics, s:" tics"); Break;
		Case 2:
			SetActorVelocity(0, 0.0, 0.0, 0.0, FALSE, FALSE);
			ACS_NamedExecute("PlayerMovement",0,TRUE,FALSE,0);	//Temporarily stop the player from moving.
		Break;
	}
}

script "GiveUpgrade" (int which)
{
	If(which<0) which = 0;
	If(which>3) which = 3;
	
	if(which==0) if(upgrades[0]<CONST_MAXUPGRADES_HAMMER) upgrades[0]++;	//Hammer (Mary) upgrade
	if(which==1) upgrades[1] += CONST_MAXCOIN_INCAMOUNT;	//Max coin limit increase
	if(which==2) if(upgrades[2]<CONST_MAXUPGRADES_UMBRELLA) upgrades[2]++;	//Umbrella (Mary) upgrade
	if(which==3) if(upgrades[3]<CONST_MAXUPGRADES_SWORD) upgrades[3]++;	//Sword (Xane) upgrade
}

script "WJ_Button" ENTER
{
While(1)
	{	
	if(movement[PlayerNumber()]>0&&speed_tics[PlayerNumber()]==0&&wjtics[PlayerNumber()]<2) wjtics[PlayerNumber()] = 2;
	
	if(openInput[PlayerNumber()] & BT_USE&&wjtics[PlayerNumber()]<35) wjtics[PlayerNumber()] = 35;
	
	if(wjtics[PlayerNumber()]>0&&framecount % 2 == 1) wjtics[PlayerNumber()]--;
	
	Delay(1);
	}
}

int groundtics[MAX_PLAYERS];
int wangles;

script "HammermoveTimer" ENTER
{
While(1)
	{
	Delay(1);
	If(hammermove[PlayerNumber()]>0)
		{
		hammermove[PlayerNumber()]--;
		GiveInventory("NoHammer",1);
		}
	Else TakeInventory("NoHammer",1);

	}
}

//JUMP-THROUGH PLATFORMS
script "JumpThroughPlatform" (void)
{
	If(flight_script_running[PlayerNumber()]==FALSE)
	{
		SetActorPosition(0, GetActorX(0), GetActorY(0), GetActorZ(0)+32.5, FALSE);
		If(last_ground_position[(MAX_PLAYERS*4)+PlayerNumber()]>8.5) SetActorVelocity(0, GetActorVelX(0), GetActorVelY(0), last_ground_position[(MAX_PLAYERS*4)+PlayerNumber()],FALSE,FALSE);
		Else SetActorVelocity(0, GetActorVelX(0), GetActorVelY(0), 8.5,FALSE,FALSE);
	}
}

int moved_up_wall[MAX_PLAYERS];	//Tics left until player isn't detected to have moved up the wall before disconnecting.
script "WallJump" ENTER
{
int prevx[MAX_PLAYERS];
int prevy[MAX_PLAYERS];

While(1)
	{
		Delay(1);
		
		walldetected[PlayerNumber()] = FALSE;
		
		Until(GetActorZ(0)-GetActorFloorZ(0)>24.1&&hammermove[PlayerNumber()]==0) Delay(1);

		Until(walldetected[PlayerNumber()]==TRUE || GetActorZ(0)-GetActorFloorZ(0)<12.1 || GetActorProperty(0,APROP_Waterlevel)>0)
		{
		prevx[PlayerNumber()] = GetActorVelX(0);
		prevy[PlayerNumber()] = GetActorVelY(0);
		Delay(1);
		
		if(wjtics[PlayerNumber()] && WaterLevel(0) == 0 && (abs(prevx[PlayerNumber()]) - abs(GetActorVelX(0)) > 5.0 || abs(prevy[PlayerNumber()]) - abs(GetActorVelY(0)) > 5.0) )
			{	//Do one quick test for a wall...
			
			SetActorState(GetCurrentPlayerTID(),"WJDetect",FALSE);
			
			If(walljumping[PlayerNumber()]>0) walljumping[PlayerNumber()]--;
			
			Delay(2);	//Wait at least two tics; One tic is not enough to prevent two false positives.
			
			If(!CheckActorInventory(GetCurrentPlayerTID(),"NoWall"))
				{
				if(hammermove[PlayerNumber()]==0) remjumps[PlayerNumber()] = 0;
				if(hammermove[PlayerNumber()]==0) detected[PlayerNumber()] = 10;
				if(hammermove[PlayerNumber()]==0) walldetected[PlayerNumber()] = TRUE;	//A wall was detected! Prepare to stick to wall!
				}
			Else TakeActorInventory(GetCurrentPlayerTID(),"NoWall",1);
			}
			
		}
		
		if(walldetected[PlayerNumber()]==TRUE && hammermove[PlayerNumber()]==0)	//This area is separate because ending that loop prematurely means no walls.
		{
			prevx[PlayerNumber()] = GetActorX(GetCurrentPlayerTID());	//Set these to the position the player stuck to the wall at.
			prevy[PlayerNumber()] = GetActorY(GetCurrentPlayerTID());	//If they move from this position when dying or teleporting, they will be forced off.
			
			walldetected[PlayerNumber()] = -1;	//This variable is used for detecting jumping off walls as well.

			SetActorProperty(GetCurrentPlayerTID(),APROP_Gravity,0.0);
			SetPlayerProperty(0,ON,PROP_FROZEN);

			SetActorAngle(GetCurrentPlayerTID(),GetActorAngle(GetCurrentPlayerTID())+0.5);
			ACS_NamedExecuteAlways("PlayFootstepSound",0,0,0,0);	
			
			//wangles = GetActorAngle(GetCurrentPlayerTID()) >> 8;
			
			SetActorAngle(GetCurrentPlayerTID(),GetActorAngle(GetCurrentPlayerTID())+wangles);
			
			wangles = 0;
			
			int vel;
			int input_wd;
			
			cancelJump[PlayerNumber()] = TRUE;	//Cancel the player's jump.
			vel = GetActorVelZ(0)/6+1.6;
			
			Delay(1);
			
			SetActorState(GetCurrentPlayerTID(),"WallJump");
			
			input_wd = 0;
			
			Until((walldetected[PlayerNumber()] == TRUE || ( movement[MAX_PLAYERS+PlayerNumber()]>0 && !(openInput[PlayerNumber()] & BT_USE) ) || prevx[PlayerNumber()] == -13.617) || CheckActorInventory(GetCurrentPlayerTID(),"NoWall")==TRUE || WaterLevel(0) != 0 /*|| GetActorZ(0) - GetActorFloorZ(0) < 12.0*/)
				{
					Delay(1);
					walljumping[PlayerNumber()] = 5;
					fspeed[PlayerNumber()] = 0.0;
					fscreamed[PlayerNumber()] = FALSE;

					input_wd = GetPlayerInput(PlayerNumber(),INPUT_BUTTONS);
					
					if(GetActorX(0)<prevx[PlayerNumber()]-20.5||GetActorX(0)>prevx[PlayerNumber()]+20.5||GetActorY(0)<prevy[PlayerNumber()]-20.5||GetActorY(0)>prevy[PlayerNumber()]+20.5) prevx[PlayerNumber()] = -13.617;
					
					If(ninja_tics[PlayerNumber()]>0 && movement[PlayerNumber()]>0 && openInput[PlayerNumber()] & BT_USE )
					{
						if(vel < 1.8) vel += 0.1;
						else vel = 1.8;
						moved_up_wall[PlayerNumber()] = 5;
						ninja_tics[PlayerNumber()] -= 2;
					}
					Else If( ninja_tics[PlayerNumber()]==0 || (ninja_tics[PlayerNumber()]>0 && ( movement[MAX_PLAYERS+PlayerNumber()]>0 && openInput[PlayerNumber()] & BT_USE ) ) && vel > -3.75) vel -= 0.05;

					Else If(ninja_tics[PlayerNumber()]>0 && movement[PlayerNumber()]==0 && movement[MAX_PLAYERS+PlayerNumber()]==0)
					{
						vel = 0.001;
					}
					
					if(!input_wd & BT_JUMP) walldetected[PlayerNumber()] = FALSE;
					if(input_wd & BT_JUMP)
						{
						If(walldetected[PlayerNumber()] == FALSE) walldetected[PlayerNumber()] = TRUE;
						}
					else walldetected[PlayerNumber()] = FALSE;
					SetActorVelocity(GetCurrentPlayerTID(),0.0,0.0,vel,FALSE,FALSE);
				}
			
			If(moved_up_wall[PlayerNumber()]>0)
			{
				ThrustThingZ(GetCurrentPlayerTID(),12, 0, TRUE);
				Delay(3);
				ThrustThing((GetActorAngle(GetCurrentPlayerTID())+0.5)>>8, 4, TRUE, GetCurrentPlayerTID());
				Delay(1);
			}
			
			SetActorProperty(GetCurrentPlayerTID(),APROP_Gravity,1.0);
			SetPlayerProperty(0,OFF,PROP_FROZEN);
						
			Delay(1);
			walljumping[PlayerNumber()] = 6;

			SetActorState(GetCurrentPlayerTID(),"EndWallJump");
			ACS_NamedExecuteAlways("RemoveNoWall",0,0,0,0);	//Take away the NoWall's to prevent 

			if(walldetected[PlayerNumber()] == TRUE)
			{
			//ACS_NamedExecuteAlways("PlaySoundX",0,2,0,0);
			ThrustThing(GetActorAngle(GetCurrentPlayerTID())>>8,15,1,GetCurrentPlayerTID());
			SetActorVelocity(GetCurrentPlayerTID(),GetActorVelX(0),GetActorVelY(0),12.25,FALSE,TRUE);
			ActivatorSound("misc/walljump",256);
			ActivatorSound("misc/walljump",256);
			wjtics[PlayerNumber()] = 35;
			walljumping[PlayerNumber()] = 2;	//Let other scripts know not to interfere with this.
			walldetected[PlayerNumber()] = -1;
			jumps[PlayerNumber()] = 1;
			groundtics[PlayerNumber()] = 12;
			}
			else
			{
			//wjtics[PlayerNumber()] = 0;
			}
			
		}
		
	}
}

script "RemoveNoWall" (void)
{
	For(int iba = 6; iba > 0; iba--)
	{
	TakeActorInventory(GetCurrentPlayerTID(),"NoWall",1);
	Delay(1);
	}
}

script "GetGroundStatus" ENTER	
{
	bool was_on_ground = FALSE, freeze_bob = FALSE;
	
	While(1)
	{
		OldVelZ[PlayerNumber()] = GetActorVelZ(0);
		
		Delay(1);
		
		TakeInventory("FloorDetected",1);
		TakeInventory("NearFloor",1);	//NearFloor checks if the player is on an object or less than a story above the ground, independently checked.
		
		If(PlayerClass(PlayerNumber())==CHAR_MARY) { If(GetActorZ(0)-GetActorFloorZ(0)<128.5 || (GetActorZ(0)-GetActorFloorZ(0)>=128.5&&GetActorVelZ(0)==0.0&&OldVelZ[PlayerNumber()]==0.0) ) { freeze_bob = TRUE; GiveInventory("NearFloor",1); } }	//Mary (128 off ground)
		Else { If(GetActorZ(0)-GetActorFloorZ(0)<256.5 || (GetActorZ(0)-GetActorFloorZ(0)>=256.5&&GetActorVelZ(0)==0.0&&OldVelZ[PlayerNumber()]==0.0) ) { freeze_bob = TRUE; GiveInventory("NearFloor",1); } }	//Xane (256 off ground)
		
		If(GetActorZ(0)-GetActorFloorZ(0)<6.9 || (GetActorZ(0)-GetActorFloorZ(0)>=3.9&&GetActorVelZ(0)==0.0&&OldVelZ[PlayerNumber()]==0.0) )
		{
			freeze_bob = FALSE;
			GiveInventory("FloorDetected",1);
			ACS_ExecuteAlways(66,0,0,0,0);
			was_on_ground = TRUE;
		}
		Else If(was_on_ground==TRUE)	//HACK: Force "on ground" for one tic after "leaving the ground".
		{
			freeze_bob = TRUE;
			GiveInventory("FloorDetected",1);
			If(GetCVAR("debug_floor")) Log(s:"\c[Orange]Forced \"on ground\".");
			was_on_ground = FALSE;
		}
		
		If(GetCVAR("debug_floor"))
		{
			If(CheckInventory("FloorDetected")) Print(s:"ON GROUND.\n\nOLD: ", f:OldVelZ[PlayerNumber()], s:"\nNEW: ", f:GetActorVelZ(0));
			Else Print(s:"FLOATING ABOVE FLOOR.\n\nOLD: ", f:OldVelZ[PlayerNumber()], s:"\nNEW: ", f:GetActorVelZ(0));
		}
		
		If(freeze_bob) SetActorVelocity(GetCurrentPlayerTID(), GetActorVelX(0), GetActorVelY(0), GetActorVelZ(0), FALSE, FALSE);
	}
}

script "VarJumpHeights" ENTER
{	//The order for these arrays is Mary, Xane, then the adult scale test.
	int var_remaining_tics[3] = { 13, 11, 13 };
	int var_velocity[3] = { 1.999, 1.85, 1.999 };
	int var_decrease_velocity[3] = { 0.15, 0.18, 0.15 };
	int remaining_tics;
	int velocity;
	While(1)
	{ 
		if(no_scripts[PlayerNumber()]==FALSE&&no_variable_jumping[PlayerNumber()]==FALSE&&GetActorZ(0)-GetActorFloorZ(0)>0.0&&GetActorZ(0)-GetActorFloorZ(0)<24.5&&openInput[PlayerNumber()] & BT_JUMP&&GetActorVelZ(0)==3.75)
		{
			//Print(f:GetActorVelZ(0));
			//Log(s:"A jump has started!");
			remaining_tics = var_remaining_tics[PlayerClass(PlayerNumber())];
			velocity = var_velocity[PlayerClass(PlayerNumber())];
			cancelJump[PlayerNumber()] = FALSE;
			
			Until(remaining_tics==0|| ( (StrParam(l:"MOBILE")!="YES"||GetCVAR("cl_demo")==TRUE) &&!(openInput[PlayerNumber()] & BT_JUMP) )||cancelJump[PlayerNumber()]==TRUE||no_variable_jumping[PlayerNumber()]==TRUE||spring[PlayerNumber()]>0)
			{
				//Log(s:"A jump is in progress supposedly!");
				//Print(s:"REMAINING: ", d:remaining_tics, s:"\nVELOCITY ADDED: ", f:velocity);
				remaining_tics--; 
				velocity -= var_decrease_velocity[PlayerClass(PlayerNumber())];
				SetActorVelocity(GetCurrentPlayerTID(),0.0,0.0,velocity,TRUE,FALSE);
				Delay(1);
			}
			
			//If(cancelJump[PlayerNumber()]==TRUE) Log(s:"Cancelled the jump.");
			cancelJump[PlayerNumber()] = FALSE;
			
			Until(GetActorVelZ(0)==0.0||GetActorZ(0)-GetActorFloorZ(0)==0.0) Delay(1);
		}
		
		Delay(1);
	}
}

script "HandleOpenInput" ENTER
{
	While(1)
	{
		openInput[PlayerNumber()] = GetPlayerInput(PlayerNumber(),MODINPUT_BUTTONS);
		openInput[MAX_PLAYERS+PlayerNumber()] = GetPlayerInput(PlayerNumber(),MODINPUT_OLDBUTTONS);
		openInput[MAX_PLAYERS*2+PlayerNumber()] = GetPlayerInput(PlayerNumber(),MODINPUT_FORWARDMOVE);
		openInput[MAX_PLAYERS*3+PlayerNumber()] = GetPlayerInput(PlayerNumber(),MODINPUT_SIDEMOVE);
		openInput[MAX_PLAYERS*4+PlayerNumber()] = GetPlayerInput(PlayerNumber(),INPUT_BUTTONS);
		openInput[MAX_PLAYERS*5+PlayerNumber()] = GetPlayerInput(PlayerNumber(),INPUT_OLDBUTTONS);
		Delay(1);
	}
}

script "RequestJumpCancel" (void) { cancelJump[PlayerNumber()] = TRUE; }	//This is for DECORATE weapons.

#define CONTROLLER_DEADZONE 0.0125	//How far a analog stick must move to be counted. Not to be confused with the in-game settings.
#define CONTROLLER_RUNZONE 0.065	//How far a analog stick must move for the player to be refistered as "running".
script "UpdateMovementDetection" ENTER
{
	While(1)
	{
		movement[PlayerNumber()] = 0;
		movement[MAX_PLAYERS+PlayerNumber()] = 0;
		movement[(MAX_PLAYERS*2)+PlayerNumber()] = 0;
		movement[(MAX_PLAYERS*3)+PlayerNumber()] = 0;
		
		//Keyboard checks
		If(openInput[PlayerNumber()] & BT_FORWARD) { movement[PlayerNumber()] = 1; If(openInput[PlayerNumber()] & BT_SPEED) movement[PlayerNumber()] = 2; }
		If(openInput[PlayerNumber()] & BT_BACK) { movement[MAX_PLAYERS+PlayerNumber()] = 1; If(openInput[PlayerNumber()] & BT_SPEED) movement[MAX_PLAYERS+PlayerNumber()] = 2; }
		If(openInput[PlayerNumber()] & BT_MOVELEFT) { movement[(MAX_PLAYERS*2)+PlayerNumber()] = 1; If(openInput[PlayerNumber()] & BT_SPEED) movement[(MAX_PLAYERS*2)+PlayerNumber()] = 2; }
		If(openInput[PlayerNumber()] & BT_MOVERIGHT) { movement[(MAX_PLAYERS*3)+PlayerNumber()] = 1; If(openInput[PlayerNumber()] & BT_SPEED) movement[(MAX_PLAYERS*3)+PlayerNumber()] = 2; }
		
		//Controller checks
		If(movement[PlayerNumber()]==0&&movement[MAX_PLAYERS+PlayerNumber()]==0&&movement[(MAX_PLAYERS*2)+PlayerNumber()]==0&&movement[(MAX_PLAYERS*3)+PlayerNumber()]==0)
		{
			If(openInput[MAX_PLAYERS*2+PlayerNumber()]>CONTROLLER_DEADZONE) { movement[PlayerNumber()] = 1; If(openInput[MAX_PLAYERS*2+PlayerNumber()]>CONTROLLER_RUNZONE) movement[PlayerNumber()] = 2; }
			If(openInput[MAX_PLAYERS*2+PlayerNumber()]<-(CONTROLLER_DEADZONE)) { movement[MAX_PLAYERS+PlayerNumber()] = 1; If(openInput[MAX_PLAYERS*2+PlayerNumber()]<-(CONTROLLER_RUNZONE)) movement[MAX_PLAYERS+PlayerNumber()] = 2; }
			If(openInput[MAX_PLAYERS*3+PlayerNumber()]>CONTROLLER_DEADZONE) { movement[(MAX_PLAYERS*2)+PlayerNumber()] = 1; If(openInput[MAX_PLAYERS*3+PlayerNumber()]>CONTROLLER_RUNZONE) movement[(MAX_PLAYERS*2)+PlayerNumber()] = 2; }
			If(openInput[MAX_PLAYERS*3+PlayerNumber()]<-(CONTROLLER_DEADZONE)) { movement[(MAX_PLAYERS*3)+PlayerNumber()] = 1; If(openInput[MAX_PLAYERS*3+PlayerNumber()]<-(CONTROLLER_RUNZONE)) movement[(MAX_PLAYERS*3)+PlayerNumber()] = 2; }
		}
		
		//Print(s:"FWD: ", d:forward[0], s:"\nBACK: ", d:backward[0], s:"\nL: ", d:left[0], s:"\nR: ", d:right[0]);
		Delay(1);
	}
}

script "AddCPowerupTics" (int which)
{
	Switch(which)
	{
		Case 0: ninja_tics[PlayerNumber()] += 35*CONST_SECS_NINJA; Break;
		Case 1: water_tics[PlayerNumber()] += 35*CONST_SECS_WATER; Break;
		Case 2: damage_tics[PlayerNumber()] += 35*CONST_SECS_DAMAGE; Break;
		Case 3: heal_tics[PlayerNumber()] += 35*CONST_SECS_HEAL; Break;
		Case 4: combo_tics[PlayerNumber()] += 35*CONST_SECS_COMBO; Break;
		Case 5: speed_tics[PlayerNumber()] += 35*CONST_SECS_SPEED; Break;
	}
}

script 66 (int value) { detected[PlayerNumber()] = value; }

//bool kjumped[MAX_PLAYERS];

script 67 ENTER
{
int esc_loop = 0;	//1 = jumped; 2 = landed.
While(1)
    {
if(no_scripts[PlayerNumber()] == TRUE) Delay(3);
if(no_scripts[PlayerNumber()] == FALSE)
{
esc_loop = 0;	//Force esc_loop to 0 to prevent restart loop or constant ability use.

Until(GetActorZ(GetCurrentPlayerTID())-GetActorFloorZ(GetCurrentPlayerTID())>16.0)	{	Delay(1);	}

  if(detected[PlayerNumber()]==0)
  {
  detected[PlayerNumber()] = 1;
  Delay(1);
  Restart;
  }

  openInput[PlayerNumber()] = GetPlayerInput(PlayerNumber(),INPUT_BUTTONS);

  While(openInput[PlayerNumber()] & BT_JUMP)	//If the player's holding jump, don't count it!
  {
  
  //if(no_scripts[PlayerNumber()] == FALSE) input[PlayerNumber()] = GetPlayerInput(PlayerNumber(),INPUT_BUTTONS);
  Delay(1);
  }
  
  Until(esc_loop != 0)
  {
  //if(no_scripts[PlayerNumber()] == FALSE) input[PlayerNumber()] = GetPlayerInput(PlayerNumber(),INPUT_BUTTONS);
  if(openInput[PlayerNumber()] & BT_JUMP) esc_loop = 1;
  if(GetActorZ(0)-GetActorFloorZ(0) < 4.0) esc_loop = 2;
  Delay(1);
  }

  if(esc_loop == 2) Restart;
  detected[PlayerNumber()]++;
  If(detected[PlayerNumber()]>1) cancelJump[PlayerNumber()] = TRUE;	//If an ability is about to be used, cancel the playr's jump. This only matters on mobile.
		If(detected[PlayerNumber()]>=2&&PlayerClass(PlayerNumber())==CHAR_XANE)	//Air Puff
        {
			//PrintBold(d:detected[PlayerNumber()]);
			
			if(detected[PlayerNumber()]>=2)
			{
				if(detected[PlayerNumber()]==2) { ActivatorSound("xane/jump1",127); remjumps[PlayerNumber()] = 5; ACS_NamedExecuteAlways("Xane_TempAirControlChange",0,0,0,0); }
				if(detected[PlayerNumber()]==3) ActivatorSound("xane/jump2",127);
				if(detected[PlayerNumber()]==4) ActivatorSound("xane/jump3",127);
				if(detected[PlayerNumber()]==5) ActivatorSound("xane/jump4",127);
				if(detected[PlayerNumber()]==6) ActivatorSound("xane/jump5",127);
				
				if(remjumps[PlayerNumber()]>0&&detected[PlayerNumber()]>1)
				{
					SetActorVelocity(GetCurrentPlayerTID(),GetActorVelX(GetCurrentPlayerTID()),GetActorVelY(GetCurrentPlayerTID()),10.625,FALSE,FALSE);
					//SetActorVelocity(GetCurrentPlayerTID(),FixedMul(GetActorVelX(GetCurrentPlayerTID()),1.15),FixedMul(GetActorVelY(GetCurrentPlayerTID()),1.15),10.625,FALSE,FALSE);
					//kjumped[PlayerNumber()] = 30;
					remjumps[PlayerNumber()]--;
					//meter[PlayerNumber()] -= 20;
					jumps[PlayerNumber()] = 0;
				}
				//Delay(1);
			}
			//Delay(1);
		}
		if(detected[PlayerNumber()]==2 && (PlayerClass(PlayerNumber())==CHAR_MARY||PlayerClass(PlayerNumber())==CHAR_SCALETEST) )	//Air Dash
            {
				GiveInventory("Animation1",1);	//Force Mary into her Air Dash pose/state.
				LocalAmbientSound("sonic/thok",127);
				//kjumped[PlayerNumber()] = 70;
				hammermove[PlayerNumber()] = 3;
				jumps[PlayerNumber()] = 0;
				SetActorVelocity(GetCurrentPlayerTID(),0,0,0,FALSE,TRUE);
				If(CheckActorInventory(GetCurrentPlayerTID(),"SuperX")==0) ThrustThingZ(GetCurrentPlayerTID(),13,0,1);
				If(CheckActorInventory(GetCurrentPlayerTID(),"SuperX")==0) ThrustThing(GetActorAngle(GetCurrentPlayerTID())>>8,30,0,GetCurrentPlayerTID());
				If(CheckActorInventory(GetCurrentPlayerTID(),"SuperX")==1) ThrustThingZ(GetCurrentPlayerTID(),20,0,1);
				If(CheckActorInventory(GetCurrentPlayerTID(),"SuperX")==1) ThrustThing(GetActorAngle(GetCurrentPlayerTID())>>8,45,0,GetCurrentPlayerTID());
				
				SetActorState(GetCurrentPlayerTID(),"AllowJumps",TRUE);	//Required to allow the Air Dash state.	
				
                remjumps[PlayerNumber()]--;
                Delay(12);
            }
            Delay(1);
            }
		
		While(openInput[PlayerNumber()] & BT_JUMP)
		{
		Delay(1);
		}

		Restart;
		
        Delay(1);
		}
	  Delay(1);
	  }

script "Xane_TempAirControlChange" (void)
{
	SetAirControl(0.35);
	
	While(GetActorZ(0)-GetActorFloorZ(0)>8.0 && ( (GetActorCeilingZ(0)-GetActorZ(0)>=64.5 && GetActorVelZ(0)!=0.0)|| (GetActorCeilingZ(0)-GetActorZ(0)<64.5) ) ) Delay(1);
	
	ACS_NamedExecuteAlways("RememberGravity",0,0,0,0);
}

script "DisableVarJumpHeightsUntilGroundHit" (void)
{
	no_variable_jumping[PlayerNumber()] = TRUE; 
	
	Delay(2);
	
	While(GetActorZ(0)-GetActorFloorZ(0)>8.0 && ( (GetActorCeilingZ(0)-GetActorZ(0)>=64.5 && GetActorVelZ(0)!=0.0)|| (GetActorCeilingZ(0)-GetActorZ(0)<64.5) ) ) Delay(1);
	
	no_variable_jumping[PlayerNumber()] = FALSE; 
}

script "ComboMeter" ENTER
{
	If(ACS_NamedExecuteWithResult("CheckSpecialStage",0,0,0,0)==TRUE) Terminate;
	
	int timerx = 0;
	int prev_coins;

	While(1)
	{	
		If(CheckInventory("IncreaseCombo")>0)
		{
		LocalAmbientSound("misc/combo2",256);
		If(combo[PlayerNumber()]==2)LocalAmbientSound("announcer/combo1",256);
		If(combo[PlayerNumber()]==5)LocalAmbientSound("announcer/combo2",256);
		TakeInventory("IncreaseCombo",1);
		if(combo[PlayerNumber()]<9) combo[PlayerNumber()]++;
		meter[PlayerNumber()] = 100;
		}
		
		timerx++;
		if(timerx>1) timerx = 0;
		
		prev_coins = ThingCountName("CoinSP_Dummy",0);
		
		Delay(1);
		
		if(ThingCountName("CoinSP_Dummy",0)<prev_coins)	//Compare the number of coins in the area...
		{	//...and if there's less than there was a tic ago, the player must've collected one!			
			HealThing(2, 50);	//Always heal the player if they're low on health.
			//total_coins++;	//Add this coin to the player's total coins for purchases!
			//totalcointics = CONSTANT_TCOINDISPTICS;
		}
		
		If(combo[PlayerNumber()]>0)	//If the player has a combo...
		{
			if(ThingCountName("CoinSP_Dummy",0)<prev_coins&&combo_tics[PlayerNumber()]==0)	//Compare the number of coins in the area...
			{
				meter[PlayerNumber()] += CONSTANT_COIN_METERINC;
				If(meter[PlayerNumber()]>100) meter[PlayerNumber()] = 100;
			}
			
			if(combo[PlayerNumber()+(MAX_PLAYERS*3)]>0) combo[PlayerNumber()+(MAX_PLAYERS*3)]--;
			else combo[PlayerNumber()+(MAX_PLAYERS*2)] = 0;
			
			if(timerx==0&&no_scripts[PlayerNumber()]==FALSE) { If(combo_tics[PlayerNumber()]==0) { /*If(framecount % 2 == 1)*/ meter[PlayerNumber()]--; } }
			if(meter[PlayerNumber()]<=0)
			{
				combo[PlayerNumber()]--;
				If(combo[PlayerNumber()]==0) LocalAmbientSound("announcer/combo3",255);
				if(combo[PlayerNumber()]>0) meter[PlayerNumber()] = 100;
			}
		}
		Else	//Make sure the meter is empty.
		{
			meter[PlayerNumber()] = 0;
			combo[PlayerNumber()] = 0;
		}
		
	}
}

bool wand_var[MAX_PLAYERS];	//Used for multiple purposes, like to signal the shield wand to stop healing.

script "Wand_Special" (int which)
{
	Switch(which)
	{
	Case 0:		//Shield healing starts
		While(wand_var[PlayerNumber()]==FALSE)
		{
			Delay(5);
			
			HealThing(1, 100);
		}
		
		wand_var[PlayerNumber()] = FALSE;
		Break;

	Case 1:		//Shield healing stops
		wand_var[PlayerNumber()] = TRUE;
	Break;
	}
}

Script "XaneAntiCheat" ENTER //XAC (Xane Anti-Cheat)
{
	int floorHeight;
	While(1)
	{
		Delay(1);
		While(GetCVAR("xane_controltype")==FALSE)	//FALSE here means mouse/keyboard. TRUE is for controllers and mobile devices.
		{
			Delay(1);
			If(no_scripts[PlayerNumber()]==FALSE)
			{
				If((movement[PlayerNumber()]==2&&(movement[(MAX_PLAYERS*2)+PlayerNumber()]>0||movement[(MAX_PLAYERS*3)+PlayerNumber()]>0)) || (movement[MAX_PLAYERS+PlayerNumber()]==2&&(movement[(MAX_PLAYERS*2)+PlayerNumber()]>0||movement[(MAX_PLAYERS*3)+PlayerNumber()]>0)))
				{
					//Player is pushing all of the required buttons and therefore must be straferunning; "Punish" them.
					
					floorHeight = GetActorZ(0) - GetActorFloorZ(0);
					
					If(floorHeight==0.0&&WaterLevel(0)<2)
					{
						ThrustThing(GetActorAngle(GetCurrentPlayerTID())-0.5>>8,1,0,GetCurrentPlayerTID());
					}
					Else If(floorHeight==0.0&&WaterLevel(0)>=2)
					{
						ThrustThing(GetActorAngle(GetCurrentPlayerTID())-0.5>>8,1,0,GetCurrentPlayerTID());
						ThrustThing(GetActorAngle(GetCurrentPlayerTID())>>8,1,0,GetCurrentPlayerTID());
					}
				}
			//TODO: Add backward equivalents; Players can still straferun backwards!
			}
		}
	}
}
	//SOUND CHANNELS:
	
	//ITEM: Wind/item pickup
	//5: Wind/extra ambient sound
	//6: Looping ambient noise
	//7: Unused(?)
script "PlayWindSound" (int tid, int mode)
{
Switch(mode)
	{
	Case 0:
	PlaySound(tid,"misc/wind",CHAN_ITEM,5,1);
	Delay(5);
	PlaySound(tid,"misc/wind",CHAN_5,0.5,1);
	Delay(5);
	Break;
	Case 1:
	StopSound(tid,CHAN_ITEM);
	Delay(5);
	StopSound(tid,CHAN_5);
	Delay(5);
	Break;
	}
}

bool amb_force[MAX_PLAYERS];	//Used when fading between ambiences.

script "RequestAmbience" (int front, int back) { If(LineSide()==LINE_FRONT) { amb_current[PlayerNumber()] = front; } If(LineSide()==LINE_BACK) { amb_current[PlayerNumber()] = back; } amb_force[PlayerNumber()] = TRUE; }

script "Ambience" ENTER
{
//Info
int amb_info_delays[14] = { 0, 0, 	//Minimum then max.
						200, 400,
						350, 575,
						275, 525,
						200, 425,
						375, 575,
						400, 550};
int	amb_info_sounds[14] = { 0, 0,
						1, 6,
						4, 12,
						15, 18,
						19, 23,
						24, 29,
						14, 17};

int amb_msound[MAX_PLAYERS];
int amb_lastsnd[MAX_PLAYERS];
int amb_lastplayed[MAX_PLAYERS];
int amb_tics[MAX_PLAYERS*2];
While(1)
	{
	Until(amb_current[PlayerNumber()]!=0||(amb_current[PlayerNumber()]>0&&amb_force[PlayerNumber()]!=TRUE)) Delay(17);
	
	amb_force[PlayerNumber()] = FALSE;
	amb_tics[(PlayerNumber()*2)+1] = Random(amb_info_delays[(amb_current[PlayerNumber()]*2)],amb_info_delays[(amb_current[PlayerNumber()]*2)+1]);	//Get the pair of min/max delays betwee minor sounds.
	amb_msound[PlayerNumber()] = Random(amb_info_sounds[(amb_current[PlayerNumber()]*2)],amb_info_sounds[(amb_current[PlayerNumber()]*2)+1]);
	//Ambience is needed! Fade in the requested looping background noise!
	Switch(amb_current[PlayerNumber()])	//First, play a short fading in sample.
		{
		Case 1: PlaySound(GetCurrentPlayerTID(),"ambience/police_start",CHAN_6,0.5,TRUE,ATTN_NONE); Break;
		Case 2: PlaySound(GetCurrentPlayerTID(),"ambience/jail_start",CHAN_6,0.5,TRUE,ATTN_NONE); Break;
		Case 3: PlaySound(GetCurrentPlayerTID(),"ambience/city_start",CHAN_6,0.75,TRUE,ATTN_NONE); Break;
		Case 4: PlaySound(GetCurrentPlayerTID(),"ambience/rain_start",CHAN_6,0.75,TRUE,ATTN_NONE); Break;
		Case 5: PlaySound(GetCurrentPlayerTID(),"ambience/creepy_start",CHAN_6,1.0,TRUE,ATTN_NONE); Break;
		Case 6: PlaySound(GetCurrentPlayerTID(),"ambience/cityday_start",CHAN_6,1.0,TRUE,ATTN_NONE); Break;
		}
		
	Delay(35);
	
	Switch(amb_current[PlayerNumber()])	//Play the looping section of the ambience.
		{
		Case 1: PlaySound(GetCurrentPlayerTID(),"ambience/police",CHAN_6,0.5,TRUE,ATTN_NONE); Break;
		Case 2: PlaySound(GetCurrentPlayerTID(),"ambience/jail",CHAN_6,0.5,TRUE,ATTN_NONE); Break;
		Case 3: PlaySound(GetCurrentPlayerTID(),"ambience/city",CHAN_6,0.75,TRUE,ATTN_NONE); Break;
		Case 4: PlaySound(GetCurrentPlayerTID(),"ambience/rain",CHAN_6,0.75,TRUE,ATTN_NONE); Break;
		Case 5: PlaySound(GetCurrentPlayerTID(),"ambience/creepy",CHAN_6,1.0,TRUE,ATTN_NONE); Break;
		Case 6: PlaySound(GetCurrentPlayerTID(),"ambience/cityday",CHAN_6,1.0,TRUE,ATTN_NONE); Break;
		}
	
	amb_lastplayed[PlayerNumber()] = amb_current[PlayerNumber()];
	amb_tics[PlayerNumber()*2] = 0;	//Set the player's tics to 0 to make sure no sounds glitch!
	
	Until(amb_force[PlayerNumber()]==TRUE)
		{
		Delay(1);
		Until(amb_tics[PlayerNumber()*2]==amb_tics[(PlayerNumber()*2)+1]||amb_force[PlayerNumber()]==TRUE)
		{
		Delay(1);
		amb_tics[PlayerNumber()*2]++;
		}
		
		if(amb_msound[PlayerNumber()]==amb_lastsnd[PlayerNumber()])
		{
			If(amb_msound[PlayerNumber()]==amb_info_sounds[(amb_current[PlayerNumber()]*2)+1])	amb_msound[PlayerNumber()]--;
			Else amb_msound[PlayerNumber()]++;
		}
		
		if(amb_force[PlayerNumber()]!=TRUE) { LocalAmbientSound(StrParam(s:"ambient/", d:amb_msound[PlayerNumber()]),127); amb_lastsnd[PlayerNumber()] = amb_msound[PlayerNumber()]; }
		
		amb_tics[(PlayerNumber()*2)+1] = Random(amb_info_delays[(amb_current[PlayerNumber()]*2)],amb_info_delays[(amb_current[PlayerNumber()]*2)+1]);	//Get the pair of min/max delays between minor sounds.
		amb_tics[PlayerNumber()*2] = 0;	//Set the player's tics back to 0 so another sound can play!
		amb_msound[PlayerNumber()] = Random(amb_info_sounds[(amb_current[PlayerNumber()]*2)],amb_info_sounds[(amb_current[PlayerNumber()]*2)+1]);
		}
		
	StopSound(GetCurrentPlayerTID(), CHAN_6);	//Stop the looping ambience to prevent weird overlap.
		
	Switch(amb_lastplayed[PlayerNumber()])	//Play a sample of the ambience fading out.
	{
		Case 1: PlaySound(GetCurrentPlayerTID(),"ambience/police_end",CHAN_7,0.5,FALSE,ATTN_NONE); Break;
		Case 2: PlaySound(GetCurrentPlayerTID(),"ambience/jail_end",CHAN_7,0.5,FALSE,ATTN_NONE); Break;
		Case 3: PlaySound(GetCurrentPlayerTID(),"ambience/city_end",CHAN_7,0.75,FALSE,ATTN_NONE); Break;
		Case 4: PlaySound(GetCurrentPlayerTID(),"ambience/rain_end",CHAN_7,0.75,FALSE,ATTN_NONE); Break;
		Case 5: PlaySound(GetCurrentPlayerTID(),"ambience/creepy_end",CHAN_7,1.0,FALSE,ATTN_NONE); Break;
		Case 6: PlaySound(GetCurrentPlayerTID(),"ambience/cityday_end",CHAN_7,1.0,FALSE,ATTN_NONE); Break;
	}	
	
	//Delay(35);
	}
}
script "PlayFMV" (int number, int frames)	//The script number and "ID" is "number" here.
{
//Add to new cutscene script when made: if((event_completed[number-1]==TRUE||GetCVAR("xane_cutscenes")==FALSE||gamemode!=0)&&number!=1) { ACS_Execute(number,0,0,0,0); Terminate; }	//The player's already seen this event; Just skip to the after-events.

int current = 0, fmv_framecount = 0, milliseconds = 0;

If(number==1)
{
	SetFont("CUTF_BOX");
	SetHUDSize(180,135,FALSE);

	While(current<35)
	{
		HUDMessageBold(s:"A";
			HUDMSG_PLAIN, 0, CR_UNTRANSLATED, -30.1, 0.1, 1.1, 0.5);
		current++;
		Delay(1);
	}

	StopSound(GetCurrentPlayerTID(),CHAN_7);
}

SetHUDSize(180,135,FALSE);

GiveInventory("Cutscene",1);	//Freeze everything during the video.
ACS_NamedExecuteAlways("PlayerMovement",0,TRUE,TRUE,TRUE);

if(number==3) ACS_NamedExecute("TitleOverlay",0,0,0,0);

current = 1;
PlaySound(0, StrParam(s:"cutscene/", d:number), CHAN_ITEM|CHAN_NOPAUSE|CHAN_UI, 1.0);
force_detransform[PlayerNumber()] = TRUE;	//Force a detransformation.

	While(current<frames)
	{

	SetFont(StrParam(s:"C", d:number, s:"_", d:current));
	HUDMessageBold(s:"A";
		HUDMSG_PLAIN, 0, CR_UNTRANSLATED, -30.1, 0.1, 0.2, 1.0);
	Delay(1);
	If(fmv_framecount==5||fmv_framecount==10||fmv_framecount==15||fmv_framecount==20||fmv_framecount==25/*||milliseconds>0.999*/) Delay(1);	//If it's certain tics/frames, pause more to make it 30 FPS instead of 35. Also...
	If(milliseconds>0.999) milliseconds -= 1.0;	//...if it's built up over a second of milliseconds, delay. Unsure if this'll help anything.
	
	current++;
	fmv_framecount++;
	milliseconds += 0.028;	//add milliseconds to detect when this goes over a second.
	if(fmv_framecount>29) fmv_framecount = 0;	//If 30 frames have been displayed, reset this variable.
	}
	
HUDMessageBold(s:"A";
	HUDMSG_FADEOUT, 0, CR_UNTRANSLATED, -30.1, 0.1, 0.0, 1.0);
TakeInventory("PowerTimeFreezer",1);
ACS_NamedExecuteAlways("PlayerMovement",0,FALSE,TRUE,TRUE);

//FadeTo(0,0,0,0.0,1.0);	//Fade the screen back in when returning from the FMV.

//Same here: event_completed[number-1] = TRUE;

//Not this, though. Use StrParam for named scripts. ACS_Execute(number,0,0,0,0);	//Run the script with the same number as the FMV number/ID.
}

script 1 (void)	//EVENT ID #1: Game Over
{
	event_completed[0] = FALSE;	//The game over FMV must always play.
	lives = CONSTANT_1UP_INITIAL;
	if(PlayerNumber()>-1) score[PlayerNumber()] = score[PlayerNumber()] / 2;
	fade = 1;
	If(gamemode==0)
	{	//If the player has made it to 1-2, 1-3, or 1-4 then gets a game over...
		if(GetLevelInfo(LEVELINFO_WORLDNUMBER)==1&&GetLevelInfo(LEVELINFO_WORLDLEVEL)>1) ChangeLevel("TMP2",0,CHANGELEVEL_NOINTERMISSION|CHANGELEVEL_PRERAISEWEAPON, GameSkill());	//...don't make them have to redo that first level again.
		else ChangeLevel(StrParam(s:"TMP", d:level[2])+1,0,CHANGELEVEL_NOINTERMISSION|CHANGELEVEL_PRERAISEWEAPON, GameSkill());
	}
	Else
	{
		ss_position = 3;
		level[0] = 0;
		level[1] = 0;
		level[2] = 0;
		ChangeLevel("AREA1",0,CHANGELEVEL_NOINTERMISSION|CHANGELEVEL_PRERAISEWEAPON, GameSkill());	//Return to the Small Hut.
	}
}

script "HandleLanding" ENTER
{
	bool fscream_upward;	//If a player has gone upward after screaming.
	While(1)
	{

	Delay(1);

	Until(GetActorZ(0)-GetActorFloorZ(0)>20.0&&GetActorVelZ(0)<-4.0) { Delay(1); If(fspeed[PlayerNumber()]<0) fspeed[PlayerNumber()] = 0; }
	
	While(GetActorZ(0)-GetActorFloorZ(0)>8.0&&CheckInventory("FloorDetected")==FALSE)
		{
			
		Delay(1);
		
		if(GetActorVelZ(0)>0) fspeed[PlayerNumber()] = 0;	//Don't count upward movement as a "fall".
		
		If(GetActorVelZ(0)<fspeed[PlayerNumber()])
			{
			fspeed[PlayerNumber()] = GetActorVelZ(0);
			If(fscreamed[PlayerNumber()]==FALSE&&fspeed[PlayerNumber()]<-10.5&&GetActorZ(0)-GetActorFloorZ(0)>512.0&&walljumping[PlayerNumber()]==0&&PlayerClass(PlayerNumber())==CHAR_MARY) { fscreamed[PlayerNumber()] = TRUE; ACS_NamedExecuteAlways("MaryScream",0,0,0,0); }
			}
		If(GetActorVelZ(0)>5.5&&fscreamed[PlayerNumber()]==TRUE&&fscream_upward==FALSE) { fscream_upward = TRUE; PlaySound(0,"lgirl/umbrella_swoop",CHAN_VOICE); }
		}
	
	StopSound(0,CHAN_VOICE);

	If(CheckInventory("FloorDetected")==TRUE&&GetActorZ(0)-GetActorFloorZ(0)>8.0)
	{	//If the player "landed" in mid-air, assume they're on an enemy and...
		GiveInventory("BounceRequested",1);	//...try to hurt the monster under Mary!
		Delay(2);	//Wait to see if it really is an enemy.
		If(ThingCount(T_NONE,1010)>0) //If it was, simulate a "bounce".
		{
			TakeInventory("MonsterHurt",1);
			ACS_NamedTerminate("EnemyBounceAC",0);	//Stop the current "bounce".
			
			fspeed[PlayerNumber()] = -fspeed[PlayerNumber()];	//Make the falling speed positive.
			
			if(fspeed[PlayerNumber()]>30.1) fspeed [PlayerNumber()] = 30.1;
			
			Delay(1);
			
			ACS_NamedExecute("EnemyBounceAC",0,0,0,0);
		}
	}
	
	If(fscreamed[PlayerNumber()]==TRUE)
	{
		fscreamed[PlayerNumber()] = FALSE;
		fscream_upward = FALSE;
		PlaySound(0,"mary/land",CHAN_VOICE,1.0);
	}
	Else If(fspeed[PlayerNumber()]<=-13.75)
	{
		PlaySound(0,"misc/land", CHAN_VOICE, 1.0);
	}
	
	//fspeed[PlayerNumber()] = 0.0;	//This is reset in the first "while" loop at the beginning of this script to allow potential ball pits to work.
	}
}

int enemies_bounced;	//Variable to track how many enemy bounces have been done.
int last_enemy_x;	//X coordinate of last enemy bounced on.
int last_enemy_y;	//Y coordinate of last enemy bounced on.

script "EnemyBounceAC" (int mode)
{
	If(enemies_bounced<6) enemies_bounced++;
	
	LocalAmbientSound(StrParam(s:"bouncecombo/", d:enemies_bounced),255);
	LocalAmbientSound(StrParam(s:"bouncecombo/", d:enemies_bounced),255);
	if(enemies_bounced>1) GiveInventory("IncreaseCombo",1);	//Award a combo for landing on multiple enemies in succession.
	GiveInventory("ScoreX",5);	//Award a combo for landing on multiple enemies in succession.
	SetActorVelocity(0, FixedDiv(GetActorVelX(0),1.5), FixedDiv(GetActorVelY(0),1.5), 15.1/*fspeed[PlayerNumber()]*/, FALSE, FALSE);
	SetAirControl(0.75);	//Give the player a lot of air control to help aim for other enemies...
	SetActorProperty(GetCurrentPlayerTID(),APROP_Gravity,0.75);	//...and reduce the gravity to increase air time.
	
	Until(on_ground[PlayerNumber()]==TRUE||GetActorZ(0)-GetActorFloorZ(0)<8.1) Delay(1);
	
	enemies_bounced = 0;	//Reset the player's combo.
	ACS_NamedExecute("RememberGravity",0,0,0,0);
}

script "IndicatePain" (void)	//Used to allow jumping on enemies' heads.
{
	Thing_ChangeTID(0, 1010);
}
script "CheckForPain" (void)
{
	If(ThingCount(T_NONE,1010)>0) SetResultValue(TRUE);
}

script "MaryScream" (void)
{
	If(PlayerClass(PlayerNumber())==CHAR_XANE) Terminate;
	
	If(CheckInventory("SuperX")==FALSE) PlaySound(0,"lgirl/fallscream",CHAN_VOICE);
	SetActorState(0,"FallScream",TRUE);
}

bool respawned[MAX_PLAYERS];

script "Drowning" ENTER
{
	If(PlayerClass(0)==CHAR_SCALETEST||ACS_NamedExecuteWithResult("CheckSpecialStage",0,0,0,0)==TRUE) Terminate;	//If in a Special Stage or the adult scale test, don't use the standard drowning behavior.
	
	int mus,dtx,dty,dmt;
	While(1)
	{
	Delay(1);
	While(GetActorProperty(GetCurrentPlayerTID(),APROP_Health)>0)
		{
		Delay(1);
		
		if(airsupply[PlayerNumber()] > 0 && (water_tics[PlayerNumber()] > 0 || GetCVAR("z_disabledrowning") == TRUE)) airsupply[PlayerNumber()] = 1050;
		
		if(airsupply[PlayerNumber()]==840||airsupply[PlayerNumber()]==560) LocalAmbientSound("misc/waterding",127);
		
		if(airsupply[PlayerNumber()]/35==8)
			{				
				//SetMusicVolume(0.1);
				//PlaySound(0,"music/drowning",CHAN_6,1.0,FALSE,0.25);
				ACS_Execute(254,0,11,0,3);
				
				While(airsupply[PlayerNumber()]/35<=8)
				{
				  if(dmt==0)
				  {
					dmt = 45;
					dtx = Random(0.4,0.6);
					dty = Random(0.4,0.6);
		
					if(airsupply[PlayerNumber()]/45<6&&GetActorProperty(GetCurrentPlayerTID(),APROP_Health)>0)HudMessage(d:airsupply[PlayerNumber()]/45; HUDMSG_FADEINOUT, 0, CR_WHITE, dtx, dty, 0.0, 0.05, 0.5);
					if(airsupply[PlayerNumber()]/45<6&&GetActorProperty(GetCurrentPlayerTID(),APROP_Health)>0)HudMessage(d:airsupply[PlayerNumber()]/45; HUDMSG_FADEINOUT, 0, CR_BLUE, dtx, dty, 0.65, 0.25, 0.5);
				  }
				  dmt--;
					Delay(1);
					
					If(airsupply[PlayerNumber()]<2) { Delay(2); airsupply[PlayerNumber()] = 1050; }
				}
				
				//StopSound(0,CHAN_6);
				//SetMusicVolume(1.0);
				ACS_Execute(254,0,-1,0,0);
			}
		
		}
	}
}

script "GiveAir" (int amount)	//Amount is in seconds, not tics; Value is multiplied by 35 here!
{
if(airsupply[PlayerNumber()]+35*amount>1050)SetAirSupply(PlayerNumber(),1050);
else SetAirSupply(PlayerNumber(),airsupply[PlayerNumber()]+35*amount);
}

function int GetCurrentPlayerTID  (void) //Gets the current player's TID (should be 1001-1008) and fills it in. This is nearly pointless nowadays.
{
int tid;

tid = 1000 + PlayerNumber();

return tid;

}

script "SetupTranslations" OPEN
{
	CreateTranslation(1,242:243=85:85,242:248=0:5);		//Red
	CreateTranslation(2,242:248=8:13);					//Orange
	CreateTranslation(3,242:248=16:21);					//Yellow
	CreateTranslation(4,242:248=24:29);					//Light Green
	CreateTranslation(5,242:248=32:37);					//Green
	CreateTranslation(6,242:248=40:45);					//Seafoam Green
	CreateTranslation(7,242:248=48:53);					//Cyan
	CreateTranslation(8,242:248=56:61);					//Cyan-blue
	CreateTranslation(9,242:248=64:69);					//Blue
	CreateTranslation(10,242:248=72:77);				//Purplish Blue
	CreateTranslation(11,242:248=80:85);				//Purple
	CreateTranslation(12,242:248=88:93);				//Pink
	CreateTranslation(13,0:255=127:127,0:7=117:127,8:15=117:127,16:23=117:127,24:31=117:127,32:39=117:127,40:47=117:127,48:55=117:127,56:63=117:127,64:71=117:127,72:79=117:127,80:87=117:127,88:95=117:127,96:111=112:127,128:135=112:127,136:143=112:127,144:159=112:127,160:175=112:127,176:191=112:127,192:207=112:127,208:215=112:127,216:223=112:127,224:231=112:127,232:239=112:127,241:253=112:127,255:255=117:117);
	//^ Fire
	CreateTranslation(14,0:255=254:254,0:7=249:254,8:15=249:254,16:23=249:254,24:31=249:254,32:39=249:254,40:47=249:254,48:55=249:254,56:63=249:254,64:71=249:254,72:79=249:254,80:87=249:254,88:95=249:254,96:111=249:254,249:254=249:254,136:143=249:254,144:159=249:254,160:175=249:254,176:191=249:254,192:207=249:254,208:215=249:254,216:223=249:254,224:231=249:254,232:239=249:254,241:253=249:254,255:255=117:117);
	//^ Ashes
	CreateTranslation(15,0:255=0:255);	//No translation
}	

script "RememberGravity" (void)
{
If(WaterLevel(0)>1) SetActorProperty(GetCurrentPlayerTID(),APROP_Gravity,0.5);
else SetActorProperty(GetCurrentPlayerTID(),APROP_Gravity,1.0);

SetAirControl(0.00390625);
}

script "ColorCoin" (int mode)
{
If(mode==0) Thing_SetTranslation(0,Random(1,12));
If(mode==1) Thing_Remove(0);
If(mode==2) UseActorInventory(GetCurrentPlayerTID(),"MaryHammer");
If(mode==3) Thing_SetTranslation(0,13);	//Fire palette
If(mode==4) Thing_SetTranslation(0,14);	//Ashes palette
If(mode==5) Thing_SetTranslation(0,15);	//Remove translation
}

script "FlowerCheck" (void)	{	If(!CheckActorFloorTexture(0,"OD1_GRS1")&&!CheckActorFloorTexture(0,"OD1_GRS2"))Thing_Remove(0);	}

script "FlowerCount" (int mode) { If(mode == TRUE) flowers++; Else if(flowers>0) flowers--; }

////////////////////////////////////
//SPRINGS, BOOST PANELS, AND RINGS//
////////////////////////////////////
int spring_timer;	//How many tics before springs are allowed to be used again. Not sure if redundant with what is below but I never bothered to add a comment to it to indicate its purpose!
int sdelay;
int boost_properties[MAX_PLAYERS*3];	//First set: Remaining tics to boost player. Second-third: X and Y velocities.

#define CONSTANT_SPRING_DISABLETICS 3	//How many tics to disable boosting objects for.

script "Spring" (int tid, int type, int power)
{
	if(spring_timer>0) Terminate;	//Don't allow springs if one was just hit!
	if(tid==0) { Log(s:"A Boosting Object didn't specify a thing ID!"); Terminate; }
	//If(sdelay<1) Terminate;
	If(GetCVAR("xane_springautorot")==2&&tid>0) tid = -tid;
	If(GetCVAR("xane_springautorot")==0&&(type==1||type==2||type==3)) tid = abs(tid);
	If(GetCVAR("xane_springautorot")==-1) tid = abs(tid);
	
	int heights[3];	//[0] thing height check, [1] highest trigger height, [2] lowest trigger height
	heights[0] =  GetActorZ (0) - GetActorZ (abs(tid));

	if(type==3)	//If it's a ring, change the detected height requirements to match the ring's size.
	{
		heights[1] = 64.01;
		heights[2] = -84.01;
	}
	else
	{
		heights[1] = 42.01;
		heights[2] = -48.01;
	}
	bool forceRotation = FALSE;	//Whether to force the player to rotate if the height check is passed.
	if(tid<0||((type==1||type==2||type==3)&&GetCVAR("xane_springautorot")>=0)) forceRotation = TRUE;	//If the thing ID variable is negative, note it for after the ckeck below!
	if(GetCVAR("xane_springautorot")<=0&&type<1&&type>2) forceRotation = FALSE;	//If set to Boost Panels Only mode, don't allow any non-Boost-Panel rotations.
	tid = abs(tid);
	
	If(IsTIDUsed(tid)==TRUE&&heights[0]<heights[1]&&heights[0]>heights[2])
	{
		//First, see if Mary's hitting this with her hammer.
		If(type!=1&&(CheckActorClass(0, "TriggerProjectile_Hammer1")||CheckActorClass(0, "TriggerProjectile_Hammer2")||CheckActorClass(0, "TriggerProjectile_Hammer3")||CheckActorClass(0, "TriggerProjectile_Hammer4")||CheckActorClass(0, "TriggerProjectile_Hammer5")||CheckActorClass(0, "TriggerProjectile_Hammer6")||CheckActorClass(0, "TriggerProjectile_Hammer7")||CheckActorClass(0, "TriggerProjectile_Hammer8")))
		{
			If(CheckActorClass(0, "TriggerProjectile_Hammer1")) SetActivator(1000, AAPTR_PLAYER1);
			If(CheckActorClass(0, "TriggerProjectile_Hammer2")) SetActivator(1001, AAPTR_PLAYER2);
			If(CheckActorClass(0, "TriggerProjectile_Hammer3")) SetActivator(1002, AAPTR_PLAYER3);
			If(CheckActorClass(0, "TriggerProjectile_Hammer4")) SetActivator(1003, AAPTR_PLAYER4);
			If(CheckActorClass(0, "TriggerProjectile_Hammer5")) SetActivator(1004, AAPTR_PLAYER5);
			If(CheckActorClass(0, "TriggerProjectile_Hammer6")) SetActivator(1005, AAPTR_PLAYER6);
			If(CheckActorClass(0, "TriggerProjectile_Hammer7")) SetActivator(1006, AAPTR_PLAYER7);
			If(CheckActorClass(0, "TriggerProjectile_Hammer8")) SetActivator(1007, AAPTR_PLAYER8);
			tid = -tid;	//Make the TID negative to indicate the hammer activated this.
		}
		If(forceRotation==TRUE) ACS_NamedExecuteAlways("ForceRotateToAngle",0,ActivatorTID(),abs(tid),0);
		ACS_NamedExecuteAlways("SpringBounce",0,tid,type,power);
		Delay(3);
	}
}

script "ForceRotateToAngle" (int affected, int reference)
{
	int player_angle = GetActorAngle(affected);
	int spring_angle = GetActorAngle(reference);
	int offset = 0.0;
	
	If(player_angle<0.5) //Hopefully, this doesn't cause runaway script errors...
	{
		Until(player_angle > 0.49)
		{
			player_angle += 0.01;
			spring_angle += 0.01;
			offset -= 0.01;	//Offset is how far off the original number was.
		}
	}
	Else
	{
		Until(player_angle < 0.51)
		{
			player_angle -= 0.01;
			spring_angle -= 0.01;
			offset += 0.01;	//Offset is how far off the original number was.
		}
	}
	int current_angle = player_angle;	//Player angle should now be aligned to ~0.5. Prepare the comparison variable.
	If(spring_angle>=1.0) spring_angle -= 1.0;	//If the spring has gone above 1 due to this, decrease it. This fixes edge cases, why this was done to begin with.
	If(spring_angle<0.0) spring_angle += 1.0;	//Same for if it went below 0.
	
	While(current_angle>spring_angle+0.05||current_angle<spring_angle-0.05)
	{
		If(player_angle>spring_angle) current_angle -= 0.03;
		Else current_angle += 0.03;
		SetActorAngle(affected,current_angle+offset);
		Delay(1);
	}
	SetActorAngle(affected,spring_angle+offset);
}

script "SpringBounce" (int tid, int type, int power) //Bounces the player in the direction of the "linked" thing like a spring.
{	//First make sure it's on the whitelist here. If it isn't, it's not allowed to use springs, boost panels, and mid-air rings.
	If(CheckActorClass(0, "LGirlPlayer")||CheckActorClass(0, "XanePlayer")||CheckActorClass(0, "FlowerProjectile3_1P")||CheckActorClass(0, "TriggerProjectile_Hammer1")||CheckActorClass(0, "TriggerProjectile_Hammer2")||CheckActorClass(0, "TriggerProjectile_Hammer3")||CheckActorClass(0, "TriggerProjectile_Hammer4")||CheckActorClass(0, "TriggerProjectile_Hammer5")||CheckActorClass(0, "TriggerProjectile_Hammer6")||CheckActorClass(0, "TriggerProjectile_Hammer7")||CheckActorClass(0, "TriggerProjectile_Hammer8")||CheckActorClass(0, "Fighter1")||CheckActorClass(0, "Cop1")||CheckActorClass(0, "Cop3")||CheckActorClass(0, "Cop4")||CheckActorClass(0, "Fighter2")||CheckActorClass(0, "Cop1_Enemy")||CheckActorClass(0, "Cop3_Enemy"))
	{
	If(CheckActorClass(0, "FlowerProjectile3_1P")) SetActorState(0, "Launch");
	bool extra_power = 0;	//This determines whether hitting this spring with Mary's hammer should increase its power.
	
	//If power is negative, this means hitting the spring with Mary's hammer should increase its power a bit. This will be 0-2, 1 if power or type is negative and 2 is both are. Note type -1 i a horizontal spring.
	If(type<0) { type = abs(type); extra_power++; }	//If type is negative, add one additional power if hit with Mary's Hammer.
	If(power<0) { extra_power++; power = abs(power); }
	If((type<1||type>2)&&tid>0)	//Don't do any of this if it is a boost panel.
	{
		//First, see if Mary's hitting this with her hammer.
		If(CheckActorClass(0, "TriggerProjectile_Hammer1")||CheckActorClass(0, "TriggerProjectile_Hammer2")||CheckActorClass(0, "TriggerProjectile_Hammer3")||CheckActorClass(0, "TriggerProjectile_Hammer4")||CheckActorClass(0, "TriggerProjectile_Hammer5")||CheckActorClass(0, "TriggerProjectile_Hammer6")||CheckActorClass(0, "TriggerProjectile_Hammer7")||CheckActorClass(0, "TriggerProjectile_Hammer8"))
		{
			If(CheckActorClass(0, "TriggerProjectile_Hammer1")) SetActivator(1000, AAPTR_PLAYER1);
			If(CheckActorClass(0, "TriggerProjectile_Hammer2")) SetActivator(1001, AAPTR_PLAYER2);
			If(CheckActorClass(0, "TriggerProjectile_Hammer3")) SetActivator(1002, AAPTR_PLAYER3);
			If(CheckActorClass(0, "TriggerProjectile_Hammer4")) SetActivator(1003, AAPTR_PLAYER4);
			If(CheckActorClass(0, "TriggerProjectile_Hammer5")) SetActivator(1004, AAPTR_PLAYER5);
			If(CheckActorClass(0, "TriggerProjectile_Hammer6")) SetActivator(1005, AAPTR_PLAYER6);
			If(CheckActorClass(0, "TriggerProjectile_Hammer7")) SetActivator(1006, AAPTR_PLAYER7);
			If(CheckActorClass(0, "TriggerProjectile_Hammer8")) SetActivator(1007, AAPTR_PLAYER8);
			tid = -tid;	//Make the TID negative to indicate the hammer activated this.
		}
	}
	
	If(tid<0)	{ power += extra_power; tid = abs(tid); }	//If this is singleplayer, allow Amy Rose-esque hitting springs with Mary's hammer. Mary must be the activator, not the projectile!
	Else extra_power = 0;

	if(1)
	{
		spring_timer = CONSTANT_SPRING_DISABLETICS;	//Disable boosting objects for a bit.
		fscreamed[PlayerNumber()] = FALSE;
		boost_properties[PlayerNumber()] = 0;	//Remaining boost tics
		boost_properties[MAX_PLAYERS+PlayerNumber()] = 0;	//X velocity
		boost_properties[(MAX_PLAYERS*2)+PlayerNumber()] = 0;	//X velocity
		cancelJump[PlayerNumber()] = TRUE;	//Cancel the player's current jump, if they're currently perfoming one.
		
		If(type==0||type>3) no_movement[PlayerNumber()] = 14;	//Don't let the player move for a second.

		SetActorVelocity(0,0,0,0,0,0);
		SetActorPosition(0,GetActorX(tid),GetActorY(tid),GetActorZ(tid),0);
		If(type==0||type>3)int angle = GetActorAngle(0);
		jumps[PlayerNumber()] = 0;
		hammermove[PlayerNumber()] = 5;

		//if(CheckActorState(0, "HitSpring")) SetActorState(0, "HitSpring");
		//else ACS_NamedExecute("PlayEnemySpringSound",0,0,0,0);

		if(type==0||type>=4) //Spring
			{
			spring[PlayerNumber()] = TRUE;
			cancelJump[PlayerNumber()] = TRUE;
			
			PlaySound(tid, "sonic/spring", CHAN_BODY, 0.75, FALSE, 0.75);
			
			if(type>=4)
				{
				//kjumped[PlayerNumber()] = 45;
				
				SetActorAngle(0,angle);
				
					If(type==4)	//High spring
					{
						ThrustThingZ(0,12*abs(power),0,1);
						ThrustThing(GetActorAngle(tid)>>8,1*abs(power)+2,0,0);
					}
					if(type==5)	//Low spring
					{
						ThrustThingZ(0,10*abs(power),0,1);
						ThrustThing(GetActorAngle(tid)>>8,8*abs(power),0,0);
					}
					if(type==6)	//Vertical spring
					{
						ACS_NamedExecute("DisableWallJump",0,35,0,0);
						ThrustThingZ(0,16*abs(power),0,1);	//The rest of this code is at the next comment.
					}

					if(GetActorProperty(0,APROP_Waterlevel)>1)
					{

						If(type==6)	//Vertical springs have a delay before they thrust you.,
							{
							Delay(3);
							ThrustThing(GetActorAngle(tid)>>8,1*abs(power),0,0);
							}
						
					}
				Else	//If out of the water...
					{
						If(type==6)
							{
							Delay(3);
							ThrustThing(GetActorAngle(tid)>>8,1*abs(power),0,0);
							}
						//Other spring types don't have delayed actions.
					}
				}
				Else
				{
				sdelay = 2;
				SetActorAngle(0,angle);
					if(power!=0)
					{
						ThrustThingZ(0,15*abs(power),0,1);
						ThrustThing(GetActorAngle(tid)>>8,5*abs(power),0,0);
					}
					Else
					{
						ThrustThingZ(0,60,0,1);
						ThrustThing(GetActorAngle(tid)>>8,20,0,0);
					}
				}
			}
		if(type<=3&&type!=0) //Boost panel/horizontal spring/ring
			{
			if(power<1) power = 2;	//If power is 0, for compatibility, treat it as 2.
			sdelay = 2;
			
			If(type==1) LocalAmbientSound("sonic/boost",96);
			If(type==2) LocalAmbientSound("sonic/spring",96);
			
			If(type==1||type==2)
				{
				SetPlayerProperty(FALSE,ON,PROP_TOTALLYFROZEN);
				//hammermove[PlayerNumber()] = 35;
				ThrustThing(GetActorAngle(tid)>> 8,15,0,0);	//Barely push the player then...
				Delay(1);	//...after a tic...
				no_movement[PlayerNumber()] = CONST_BOOST_TICS*power;	//Don't allow the player to control their movement after this (minus jumping and Air Dashes).
				boost_properties[PlayerNumber()] = CONST_BOOST_TICS*power;	//...and activate the real boost!
				boost_properties[MAX_PLAYERS+PlayerNumber()] = GetActorVelX(GetCurrentPlayerTID())/5;	//X velocity
				boost_properties[(MAX_PLAYERS*2)+PlayerNumber()] = GetActorVelY(GetCurrentPlayerTID())/5;	//X velocity
				SetPlayerProperty(FALSE,OFF,PROP_TOTALLYFROZEN);
				}
				
				if(type==3)	//Ring
				{
					If(LineSide()==LINE_BACK) SetActorAngle(0,GetActorAngle(0)+0.5);
					ThrustThingZ(0,36+(2*power),0,1);
					ThrustThing(GetActorAngle(tid)>>8,5*abs(power),0,0);
					ACS_ExecuteAlways(66,0,1,0,0);	//Restore the player's ability.
				}
			}
		If(type==0||type>3) SetActorAngle(0,angle);
		If(type==0||type>3) no_movement[PlayerNumber()] = 14;
		}
	}
}

int sadness = -7;	//This increases each USE tap.
script "MaryCry" ENTER	//Yep, Mary's crying returns!
{
	If(ACS_NamedExecuteWithResult("CheckSpecialStage",0,0,0,0)==TRUE||ACS_NamedExecuteWithResult("CheckSpecialStage",0,2,0,0)==TRUE) Terminate;	//No crying in Special Stages or the Small Hut!
	int became_sad;
	If(PlayerClass(PlayerNumber())!=CHAR_MARY) Terminate;	//If not Mary, disable crying.
	While(1)
	{
		If(sadness>-7&&framecount % (2+became_sad) == 0)
		{
			sadness--;
			If(sadness==-7&&became_sad>0) { became_sad = 0; PlaySound(GetCurrentPlayerTID(), "mary/cry_cancel", CHAN_VOICE, 1.0, FALSE, 1.33); }
			Else If(sadness==24) PlaySound(GetCurrentPlayerTID(), "mary/crybuildup4", CHAN_VOICE, 1.0, FALSE, 1.25);
			Else If(sadness==16) PlaySound(GetCurrentPlayerTID(), "mary/crybuildup3", CHAN_VOICE, 1.0, FALSE, 1.2);
			Else If(sadness==8) PlaySound(GetCurrentPlayerTID(), "mary/crybuildup2", CHAN_VOICE, 1.0, FALSE, 1.15);
			Else If(sadness==0) PlaySound(GetCurrentPlayerTID(), "mary/crybuildup1", CHAN_VOICE, 1.0, FALSE, 1.1);

		}
		
		If(OpenInput[PlayerNumber()] & BT_USE && no_scripts[PlayerNumber()]==FALSE && sadness > -42)
		{	//Sadness being -42 disables crying.
			sadness += 5;
			If(sadness>=30) { sadness = -42; ACS_NamedExecute("PlayDialogue",0,0,0,0); Delay(50); sadness = -7; became_sad = 0; }
			Else If(sadness>=24) { became_sad = 3; PlaySound(GetCurrentPlayerTID(), "mary/crybuildup4", CHAN_VOICE, 1.0, FALSE, 1.25); }
			Else If(sadness>=16) { became_sad = 2; PlaySound(GetCurrentPlayerTID(), "mary/crybuildup3", CHAN_VOICE, 1.0, FALSE, 1.2); }
			Else If(sadness>=8) PlaySound(GetCurrentPlayerTID(), "mary/crybuildup2", CHAN_VOICE, 1.0, FALSE, 1.15);
			Else If(sadness>=0) { became_sad = 1; PlaySound(GetCurrentPlayerTID(), "mary/crybuildup1", CHAN_VOICE, 1.0, FALSE, 1.1); }
		}
		
		While(openInput[PlayerNumber()] & BT_USE && no_scripts[PlayerNumber()]==FALSE) { Delay(1); If(sadness>-7 && framecount % 2 == 0) sadness--; }

		Delay(1);
	}
}

int tics_boost;	//How many tics until Xane's current Drop Dash attempt is cancelled. Push use two times to start one.

script "XaneDropDash" ENTER
{
	If(PlayerClass(PlayerNumber())!=CHAR_XANE) Terminate;	//If not Xane, get rid of the Drop Dash.
	While(1)
	{
		//Don't allow Drop Dashes if scripts are disabled or stuck to a wall.
		Until(no_scripts[PlayerNumber()]==FALSE&&walljumping[PlayerNumber()]==0&&hammermove[PlayerNumber()]==0) Delay(1);
		
		If(boost_properties[PlayerNumber()]==0&&openInput[PlayerNumber()] & BT_USE)
		{	//If on the ground and backwards+use was just pressed, give Xane a boost forward!
			tics_boost = 15;
			While(openInput[PlayerNumber()] & BT_USE) { Delay(1); tics_boost--; }
			If(tics_boost<1) { tics_boost = 0; Restart; }
			Until(tics_boost<1||openInput[PlayerNumber()] & BT_USE) { Delay(1); tics_boost--; }
			If(tics_boost<1) { tics_boost = 0; Restart; }
			Else
			{
				If(GetActorZ(0)-GetActorFloorZ(0)>64.01) { cancelJump[PlayerNumber()] = TRUE; ACS_NamedExecute("LandingBounce",0,1,0,0); }
				Else If(GetActorZ(0)-GetActorFloorZ(0)==0.0) { TakeInventory("Animation2",1); GiveInventory("Animation2",1); }	//Animation #2 for Xane uses the claw.
			}
		}
		
		Delay(1);
	}
}

script "CheckMiscScriptVariable" (int which)	//0: no_scripts, 1:hammermove, 2:walljumping
{
	Switch(which)
	{
		//First, the "no script" variables. These disable things base on what checks for them.
		Case 0:	//Used to stop certain gameplay scripts from running to prevent odd glitches.
			SetResultValue(no_scripts[PlayerNumber()]);
		Break;
		Case 1:	//If set, prevents sticking to walls and other things that check for this variable.
			SetResultValue(hammermove[PlayerNumber()]);
		Break;
		Case 2:	//This variable disables things like the hammer when on walls. It is also use for other purposes.
			SetResultValue(walljumping[PlayerNumber()]);
		Break;
		//Next, check for other variables that could be handy to cripts in different files.
		Case 3:	//This is TRUE if the activator's forcibly killed or is being arrested.
			SetResultValue(force_death[PlayerNumber()]);
		Break;
	}
}

script "LandingBounce" (int mode)
{
	int temp_fspeed;	//Not to be confused with fspeed itself, this checks your falling velocity to increase the bounce height if higher than 25.1.
	
	if(mode==1||mode==2) no_scripts[PlayerNumber()] = TRUE;	//If it's a Drop Dash or "sword drop attack", disable cripts to prevent potential glitches.
	if(mode==2) ACS_NamedExecuteAlways("XaneSwordDropAttackViewAnim",0,FALSE,0,0);	//Mode #2 is for Xane's sword drop attack.
	if(mode==1)
	{	//If doing a "Drop Dash", prevent another one from being queued up. The other script checks for one of these variables.
		//no_scripts[PlayerNumber()] = TRUE;
		no_movement[PlayerNumber()] = 140;
		PlaySound(0,"xane/dropdash1",CHAN_VOICE,1.0,FALSE);
		GiveInventory("DisableAirDash",1);	//Re-use Mary's inventory item Xane never uses to make the sword lock up.
	}
	
	//Unknown if this broke anything when commented out but it fixes a sword glitch. //Until(GetActorVelZ(0)<0.0||GetActorProperty(0,APROP_HEALTH)==1||force_death[PlayerNumber()]==TRUE) { hammermove[PlayerNumber()] = 2; Delay(1); }
	
	Until(GetActorZ(0)-GetActorFloorZ(0)<8.0||GetActorProperty(0,APROP_HEALTH)==1||force_death[PlayerNumber()]==TRUE||(GameType()!=GAME_NET_DEATHMATCH&&CheckInventory("FloorDetected")==TRUE))
	{
		hammermove[PlayerNumber()] = 2;	//Prevent sticking to walls while performing Drop Dashes.
		Delay(1);
		
		if(GetActorVelZ(0)>0) temp_fspeed = 0;	//Don't count upward movement as a "fall".
		
		If(GetActorVelZ(0)<temp_fspeed) temp_fspeed = GetActorVelZ(0);
	}
	
	If(GetActorProperty(0,APROP_HEALTH)==1||force_death[PlayerNumber()]==TRUE)
	{	//If Xane died, cancel the current Drop Dash.
		StopSound(0, CHAN_BODY);
		If(mode==2) GiveInventory("Variable4",1);	//If this is the alt. sword attack, tell the weapon to cancel it.
		no_scripts[PlayerNumber()] = FALSE;	//Allow scripts if this script is terminated early.
		TakeInventory("DisableAirDash",1);	//If Xane's doing a small Sword Beam attack while performing a Drop Dash, allow him to finish the attack, fixing a glitch.
		Terminate;
	}
	Else
	{
		If(mode==2) { GiveInventory("Variable5",1); GiveInventory("Variable4",1); }	//Variable4 tells the attack to continue while 5 tells it it's successful.
	}
	If(mode==0&&temp_fspeed>-25.1) temp_fspeed = -25.1;
	
	ACS_ExecuteAlways(66,0,0,0,0);
	
	If(mode==0)	//Bounce
	{
		SetActorVelocity(0,GetActorVelX(0)/2,GetActorVelY(0)/2,FixedDiv(abs(temp_fspeed), 2.0),FALSE,FALSE);
		PlaySound(0,"misc/boing",CHAN_ITEM,1.0);
	}
	Else If(mode==1)	//"Drop Dash"
	{
		temp_fspeed = temp_fspeed >> 16;	//Convert it into a whole number.
		If(CheckInventory("SuperX")==TRUE) temp_fspeed -= 10;
		int divide_by = 9;
		If(temp_fspeed<-15) divide_by = 8;
		If(temp_fspeed<-20) divide_by = 7;
		If(temp_fspeed<-25) divide_by = 6;
		If(temp_fspeed<-30) divide_by = 5;
		If(temp_fspeed<-35) divide_by = 4;
		If(temp_fspeed<-40) divide_by = 3;
		//Print(s:"DIVIDE! ", d:divide_by, s:"\nFSPEED: ", d:temp_fspeed, s:"\nLOCK TIME: ", d:CONST_BOOST_TICS*2);
		SetActorVelocity(0,0.0,0.0,0.0,FALSE,FALSE);	//Stop the player before boosting them!
		PlaySound(0,"sonic/thok",CHAN_VOICE,1.0,FALSE);
		SetPlayerProperty(FALSE,ON,PROP_TOTALLYFROZEN);
		//hammermove[PlayerNumber()] = 35;
		ThrustThing(GetActorAngle(0)>> 8,15,0,0);	//Barely push the player then...
		Delay(1);	//...after a tic...
		no_movement[PlayerNumber()] = CONST_BOOST_TICS*3;	//Don't allow the player to control their movement after this (minus jumping and Air Dashes).
		//no_scripts[PlayerNumber()] = FALSE;	//Allow scripts again as Xane's now on the ground.
		boost_properties[PlayerNumber()] = CONST_BOOST_TICS*3;	//...and activate the real boost!
		boost_properties[MAX_PLAYERS+PlayerNumber()] = GetActorVelX(GetCurrentPlayerTID())/divide_by;	//X velocity
		boost_properties[(MAX_PLAYERS*2)+PlayerNumber()] = GetActorVelY(GetCurrentPlayerTID())/divide_by;	//X velocity
		SetPlayerProperty(FALSE,OFF,PROP_TOTALLYFROZEN);
		TakeInventory("DisableAirDash",1);	//Take away that inventory item to unlock the sword once again.
	}
	Else If(mode==2)	//Xane's sword drop attack
	{
		ACS_NamedExecuteAlways("XaneSwordDropAttackViewAnim",0,TRUE,0,0);
		SetActorVelocity(0, 0.0, 0.0, 0.0, FALSE, FALSE);
		ThrustThing(GetActorAngle(0) >> 8, 35, TRUE, 0);
	}
	
	If(mode==1||mode==2) no_scripts[PlayerNumber()] = FALSE;	//Allow scripts as Xane should now be on the ground after the Drop Dash/sword drop attack.
}

script "XaneSwordDropAttackViewAnim" (int directionx)	//0 = down, 1 = up
{
	int xstics = 0;	//This variable counts how many tics have passed trying to forcibly make Xane look up or down. This fixes a glitch.
	If(directionx==0)
	{
		While(GetActorPitch(0)<0.175&&xstics<16)
		{
			SetActorPitch(0,GetActorPitch(0)+0.025);
			Delay(1);
			xstics++;
		}
		SetActorPitch(0,0.18);	//At the end of the movement, set it to the intended number to be safe.
	}
	Else
	{
		While(GetActorPitch(0)>0.06&&xstics<16)
		{
			SetActorPitch(0,GetActorPitch(0)-0.025);
			Delay(1);
			xstics++;
		}
		SetActorPitch(0,0.0);	//At the end of the movement, set it to the intended number to be safe.
	}
}

//Enemy behavior scripts

script "PlayEnemySpringSound" (void)
{
	if(CheckActorClass(0, "LGirlPlayer")==TRUE||CheckActorClass(0, "XanePlayer")==TRUE) Terminate;	//If a player, terminate as Mary screams through other means.
	
	If(CheckActorClass(0, "Troll")) ActivatorSound("troll/pain",255);
	If(CheckActorClass(0, "Tiger1")) ActivatorSound("m3/pain",255);
	If(CheckActorClass(0, "Tiger2")) ActivatorSound("wtiger/death",255);
	If(CheckActorClass(0, "Fighter1")||CheckActorClass(0, "Fighter2")) ActivatorSound("fighter/death",255);
	If(CheckActorClass(0, "Cop1")) ActivatorSound("cop2/death",255);
	If(CheckActorClass(0, "Cop3")) ActivatorSound("cop3/death",255);
	If(CheckActorClass(0, "Cop4")) ActivatorSound("cop4/death",255);
}

script "EnemyFollowPath" (int follower)
{
	int initial_health = GetActorProperty(0, APROP_Health);
	Thing_Activate(follower);	//Turn on the path follower.
	
	While(GetActorProperty(0, APROP_Health)==initial_health)
	{
		SetActorPosition( 0, GetActorX(follower), GetActorY(follower), GetActorZ(follower), FALSE);
		SetActorAngle(0, GetActorAngle(follower));
		Delay(1);
	}
	
	Thing_Deactivate(follower);
	Thing_Remove(follower);
	GiveInventory("Animation2",1);	//Hackish and probably stupid, but this forces enemies to stop following this path.
	Delay(3);
	TakeInventory("Animation2",1);
}

script "DisableWallJump" (int tics_disablewj)	{	hammermove[PlayerNumber()] = tics_disablewj;	}

script "HandleResetOnReturn" RETURN { ACS_NamedExecuteAlways("ResetPlayer",0,0,0,0); }

script "FixFades" ENTER	//Not sure what makes the beginning-of-level fades be delayed, but this fixes that!
{
	If(fade==0) Terminate;
	
	For(int force_fade = 0; force_fade < 7; force_fade++)
	{
		if(fade==1)
		{
			FadeTo(0,0,0,1.0,0.0);
			Delay(1);
		}
		if(fade==2)
		{
			FadeTo(255,255,255,1.0,0.0);
			Delay(1);
		}
	}
}

script "ResetPlayer" (void)
{
	SetAirControl(0.00390625);
	SetActorProperty(GetCurrentPlayerTID(),APROP_Gravity,1.0);
	If(GameType()!=GAME_NET_DEATHMATCH) SetPlayerProperty(1,ON,PROP_BUDDHA);	//Death will be scripted.
	Else SetPlayerProperty(1,OFF,PROP_BUDDHA);	//Deathmatch won't work unless Doom's idea of "death" happens.
	SetPlayerProperty(1,OFF,PROP_FROZEN);
	SetPlayerProperty(1,OFF,PROP_TOTALLYFROZEN);
	SetPlayerProperty(TRUE,OFF,PROP_FLIGHT);
	disablewind[PlayerNumber()] = 0;
	no_scripts[PlayerNumber()] = FALSE;
	
	if(StrParam(n:PRINTNAME_LEVEL)!="SPECSTG1"&&StrParam(n:PRINTNAME_LEVEL)!="SPECSTG2"&&StrParam(n:PRINTNAME_LEVEL)!="SPECSTG3"&&StrParam(n:PRINTNAME_LEVEL)!="SPECSTG4"&&StrParam(n:PRINTNAME_LEVEL)!="SPECSTG5"&&StrParam(n:PRINTNAME_LEVEL)!="SPECSTG6"&&StrParam(n:PRINTNAME_LEVEL)!="SPECSTG7"&&GameType()!=GAME_NET_DEATHMATCH/*&&(GetLevelInfo(LEVELINFO_LEVELNUM)!=0&&ss_position!=3)*/) { if(level[0]<GetLevelInfo(LEVELINFO_LEVELNUM)&&GetLevelInfo(LEVELINFO_LEVELNUM)<CONST_TRANS_LEVELS_START) level[0] = GetLevelInfo(LEVELINFO_LEVELNUM); level[1] = GetLevelInfo(LEVELINFO_LEVELNUM); If(GetLevelInfo(LEVELINFO_WORLDLEVEL)==1) level[2] = GetLevelInfo(LEVELINFO_LEVELNUM); }		//If not a special level, update this variable.
	
	if(GetLevelInfo(LEVELINFO_LEVELNUM)<CONST_TRANS_LEVELS_START)	//Don't accept fades if this is a "temporary" level.
	{
		if(fade==1)	//Black (slow)
		{
			FadeTo(0,0,0,1.0,0.0);
			fadeout = 4;	//Request all screens to fade in.
		}
		if(fade==2)	//White (slow)
		{
			FadeTo(255,255,255,1.0,0.0);
			fadeout = 5;	//Request all screens to fade in.
		}
		if(fade==3)	//Black (fast)
		{
			FadeTo(0,0,0,1.0,0.0);
			FadeTo(0,0,0,0.0,0.5);
		}
	}
	else
	{
		SetFont("3DLETTER");
		HUDMessage (l:"TXT_LOADING";
			HUDMSG_PLAIN, 0, CR_UNTRANSLATED, 0.5,0.5, 0.99);   //Loading text.
		Delay(10);
		ChangeLevel(StrParam(s:"AREA", d:level[1]-CONST_TRANS_LEVELS_START+1),0,CHANGELEVEL_NOINTERMISSION|CHANGELEVEL_PRERAISEWEAPON, GameSkill());
		Delay(3);
		HUDMessage (s:"Sorry, but this area didn't load properly! Let Xane know about this info: \nLEVEL VARS: ", d:level[0], s:"/", d:level[1], s:"/", d:level[2], s:"\nMODE #", d:gamemode, s:"\n\nAgain, apologies for any inconvenience. If in a speedrun, push ", k:"+user3", s:". Otherwise, reload your previous save or start a new game!";
			HUDMSG_PLAIN, 0, CR_BRICK, 0.5,0.1, 90.0);   //Loading text.
	}
}

script "StoreBankCoins" (void)	//Adds any on-hand coins to Mary/Xane's bank.
{
	If(gamemode!=3)	//If not practicing, allow "bank deposits".
	{
		If(CheckInventory("CoinSP")==0) { Log(s:"\c[Brick]", l:"BANK_NOCOINS"); LocalAmbientSound("misc/buzzer",255); Terminate; }
		total_coins += CheckInventory("CoinSP");	//Add this coin to the player's total coins for purchases!
		totalcointics = CONSTANT_TCOINDISPTICS;
		Log(d:CheckInventory("CoinSP"), s:" ", l:"BANK_DEPOSITED");
		TakeInventory("CoinSP",CheckInventory("CoinLimit"));	//After adding the coins, take away all of the player's coins.
	}
	Else { Log(s:"\c[Brick]", l:"BANK_DISABLED"); LocalAmbientSound("misc/buzzer",255); Terminate; }
}

script "CaptureAll" (void)
{
	SetActorAngle(0,0);
	SetActorPitch(0,0);
	Delay(35);
	SetActorAngle(0,0.25);
	Delay(35);
	SetActorAngle(0,0.5);
	Delay(35);
	SetActorAngle(0,0.75);
	Delay(35);
	SetActorAngle(0,0);
	SetActorPitch(0,1);
	Delay(35);	
	SetActorAngle(0,0);
	SetActorPitch(0,-0.25);
	Delay(35);	
	SetActorAngle(0,0);
	SetActorPitch(0,0.25);
}

int MaxLevelsPerWorld[2] = { 4, 3 };
int selectedLevel = 1;	//Internal level number, like 1 = 1-2
int clh_world = 1;	//Displayed world number
int clh_level = 2;	//Displayed level within world.

script "ChangeLevelHut" (int directiona)
{
	//If(level[0]==0&&level[1]==0) { Log(s:"\c[Brick]This can only be done from other levels."); Terminate; }
	If(directiona==FALSE&&selectedLevel>1) { selectedLevel--; clh_level--; }
	Else If(directiona==TRUE&&selectedLevel<level[0]) { selectedLevel++; clh_level++; }
	
	If(clh_level>MaxLevelsPerWorld[clh_world-1])
	{
		If(MaxLevelsPerWorld[clh_world]>0)
		{
			clh_level = 1;
			clh_world++;
		}
		Else  { clh_level--; selectedLevel--; }
	}
	If(clh_level<=0)
	{
		clh_world--;
		clh_level = MaxLevelsPerWorld[clh_world-1];
	}
	
	SetFont("2DFONTP1");
	HUDMessage (s:"SELECTED AREA: ", d:clh_world, s:"-", d:clh_level;
		HUDMSG_FADEOUT, 21, CR_ICE, 0.5, 0.2, 3.0, 1.0);
	SetFont("2DFONTP2");
	HUDMessage (l:StrParam(s:"LEVELNAME_", d:selectedLevel+1);
		HUDMSG_FADEOUT, 22, CR_FIRE, 0.5, 0.25, 3.0, 1.0);
	SetFont("2DFONTP1");
	If(completed_levels[selectedLevel]>=100) { HUDMessage (s:"PERCENT COMPLETE:\n",d:completed_levels[selectedLevel], s:"% \c[Green](COMPLETE)" ;
		HUDMSG_FADEOUT, 23, CR_SAPPHIRE, 0.5, 0.35, 3.0, 1.0); }
	Else { HUDMessage (s:"PERCENT COMPLETE:\n",d:completed_levels[selectedLevel], s:"% \c[Brick](INCOMPLETE)" ;
		HUDMSG_FADEOUT, 23, CR_SAPPHIRE, 0.5, 0.35, 3.0, 1.0); }
	ss_returnlevel = selectedLevel;
}

script "ChangePlayerTIDs" enter
{
	Thing_ChangeTID (0, 1000+PlayerNumber());
	TakeInventory("PlayerNumberX",8);
	GiveInventory("PlayerNumberX",PlayerNumber()+1);
	
	if(StrParam(l:"MOBILE")=="YES") SetCVAR("xane_controltype",1);

	ACS_NamedExecuteAlways("ResetPlayer",0,0,0,0);

	if(upgrades[1]<25&&ACS_NamedExecuteWithResult("CheckSpecialStage",0,0,0,0)==FALSE) { If(GameType()==GAME_NET_DEATHMATCH) { upgrades[1] = 50; } Else upgrades[1] = 100; }	//If the player has 0 coins, fix that...
	If(ACS_NamedExecuteWithResult("CheckSpecialStage",0,0,0,0)==TRUE)	//If in a Special Stage, swap variables around.
	{
		//stored_velocity[3] = upgrades[1];	//Store the number of coins the player really can hold until they return from the Special Stage.
		TakeInventory("SSRequiredCoins",999);
		GiveInventory("SSRequiredCoins",ACS_NamedExecuteWithResult("GetCoinsRequired",0,0,0,0));
		Log(s:"Coin code ran!\n", d:ACS_NamedExecuteWithResult("GetCoinsRequired",0,0,0,0), s:" coins should be added as req.!");
		If(CheckInventory("CoinSP")>1)	//If the player has coins, give half of them to the bank before the Special Stage removes them!
		{
			total_coins += CheckInventory("CoinSP") / 2;
			totalcointics = CONSTANT_TCOINDISPTICS;
			TakeInventory("CoinSP",999);
		}
	}

	if(GameType()==GAME_NET_DEATHMATCH) cgem_count = 7;
		
	ltime_control = TIME_PLAY;
	framecount = 0;	//I'm paranoid of this value getting too high!
	
	//Reset these level-specific variables just in case the script doesnt define them.
	initial_music = 0;	//Initial song ID that will play when this area loads.
	world_info[0] = 0;	//World number
	world_info[1] = 0;	//Level number within world
	movesky[0] = 0;	//How much less the skybox will move relative to the player. Higher values make it slower.
	movesky[1] = 0; //The above value is horizontal, but this is vertical.
	
	Delay(2);	//Give the level two tics to set up the music variable.
	
	Until(level_ready==TRUE) Delay(1);	//Wait for SeamlessHelper to be finished before playing music.
	
	ACS_ExecuteAlways(254,0,initial_music,TRUE,FALSE);	//Play the level's initial music.

	//Not sure if this is too important anymore. Still, to "prevent incorrect level transitions", set the Special Stage return position ID before the player can reach another level and teleport to another Special Stage!
	if(StrParam(n:PRINTNAME_LEVEL)!="SPECSTG1"&&StrParam(n:PRINTNAME_LEVEL)!="SPECSTG2"&&StrParam(n:PRINTNAME_LEVEL)!="SPECSTG3"&&StrParam(n:PRINTNAME_LEVEL)!="SPECSTG4"&&StrParam(n:PRINTNAME_LEVEL)!="SPECSTG5"&&StrParam(n:PRINTNAME_LEVEL)!="SPECSTG6"&&StrParam(n:PRINTNAME_LEVEL)!="SPECSTG7"&&GameType()!=GAME_NET_DEATHMATCH&&GetLevelInfo(LEVELINFO_LEVELNUM)<CONST_TRANS_LEVELS_START) { ss_position = 0; Delay(1);fade = 0; }

	if(completed_levels[level[1]+1]==TRUE)	//Test to confirm if this works when 1-2 is finished.
	{
	SetFont("BIG_TEXT");
	HUDMessage (l:"TXT_LVLCOMPLETE";
		HUDMSG_FADEINOUT, 0, CR_GREEN, 0.15, 0.999, 3.0, 0.75, 0.75);
	}
	
	if(fade>0) fade = 0;
	
	If(ACS_NamedExecuteWithResult("CheckSpecialStage",0,0,0,0)==FALSE&&ACS_NamedExecuteWithResult("CheckSpecialStage",2,0,0,0)==FALSE) { ACS_NamedExecuteAlways("SetCheckpoint",0,616,0,0); }	//Thing ID 616 is the default checkpoint.

}

script "SetSSCheckpoint" RETURN
{
	For(int clearmessages1 = 89; clearmessages1 <= 103; clearmessages1++) HUDMessage (s:""; HUDMSG_FADEOUT, clearmessages1, CR_UNTRANSLATED, 0.0,0.0, 0.0, 0.0, 0.0, 0.0);   //Player number
	
	If(ss_return_id>0) { ACS_NamedExecuteAlways("SetCheckpoint",0,ss_return_id,0,0); ss_return_id = 0; }
	if(stored_velocity[3]>0||CheckInventory("SSRequiredCoins")>0) { TakeInventory("SSRequiredCoins",999); TakeInventory("CoinSP",999); }	//Remove the requirement inventory item which will restore the player's total coins count.
}	//The second condition above in the if check on the line above this one may be hackish. If anything meses up, check it out.

int tics_scoreround = 0;	//How many tics until a score rounding occurs. If this is -1, it's disabled.
script 70 (int add_score)	//argument 2 was "mode" but I don't know what it was for.
{
	if(score[PlayerNumber()]>=9999990)
	{
		score[PlayerNumber()] = 9999990;
		Terminate;
	}
	
	score[PlayerNumber()] += add_score;	//Give or take away the requested score.
	If(add_score>0) score[MAX_PLAYERS] += add_score;	//Increase the hidden 1UP score counter (only if earning score).
	
	//Give an extra life if the player earned enough points.
	If(score[MAX_PLAYERS] >= CONSTANT_1UP_SCORE) { ACS_NamedExecuteAlways("GiveExtraLife",0,0,0,0); score[MAX_PLAYERS] = 0; }
	
	//Lastly, make sure invalid scores are impossible.
	If(score[PlayerNumber()]<0) score[PlayerNumber()] = 0;
	if(score[PlayerNumber()]>=9999990) score[PlayerNumber()] = 9999990;
	
	//Prepare a score-rounding in two seconds from this point unless more score's earned.
	tics_scoreround = 70;
}

/*int remaining =  abs(add_score);

if(mode==FALSE)
{
	if(score[PlayerNumber()]>=9999990)
	{
	score[PlayerNumber()] = 9999990;
	Terminate;
	}

	If(add_score<0)
		{

		If(score[PlayerNumber()]+add_score>=0)    //Remove score if requested.
			{
			
			int score_orig;        
			score_orig = score[PlayerNumber()];
			While(remaining > 4)
				{
				//Command to play score counting-up sound was here.
				score[PlayerNumber()] -= 5;
				remaining -= 5;	//Don't decrease the hidden total score to prevent easy life abuse.
				if(score[PlayerNumber()]<=0) remaining = 0;	//Prevent negative score!
				Delay(1);
				}

			If(score[PlayerNumber()]==score_orig) score[PlayerNumber()] = score_orig/2;
			//Command to play score finished sound was here.
			}
		Else
			{
			score[PlayerNumber()] = 0;
			//Print(d:add_score);
			}
	}
	Else    //Give points otherwise.
	{
	ss_score = remaining;
	plsbonus = TRUE;
	While(remaining > 4)
	{
		//Command to play score counting-up sound was here.
		If(remaining>100)
		{
			score[PlayerNumber()] += 10;
			if(score[MAX_PLAYERS]>=0) score[MAX_PLAYERS] += 10;	//Total (never decrease)
			remaining -= 10;
			ss_score -= 10;
		}
		Else
		{
			score[PlayerNumber()] += 5;
			if(score[MAX_PLAYERS]>=0) score[MAX_PLAYERS] += 5;	//Total (never decrease)
			remaining -= 5;
			ss_score -= 5;
		}
		Delay(1);
		
		If(score[MAX_PLAYERS] >= CONSTANT_1UP_SCORE)	//If the total earned score is large enough...
		{
			ACS_NamedExecuteAlways("GiveExtraLife",0,0,0,0);
			
			score[MAX_PLAYERS] = 0;
		}
	}

	plsbonus = FALSE;
	//Command to play score finished sound was here.
	If(score[PlayerNumber()]<0) score[PlayerNumber()] = 0;	//Just in case the above check fails, make sure negative scores are impossible!
	}

	If(score[PlayerNumber()] % 5 > 0) //Check to see if the value is a multiple of 5
	{
	remaining = score[PlayerNumber()] % 5;

	While(remaining>0)

	score[PlayerNumber()]--;
	score[MAX_PLAYERS]++;	//Total (never decrease)
	remaining--;
	Delay(1);
	}
	remaining = score[PlayerNumber()] % 5;

	While(remaining>0)
	{
	score[PlayerNumber()]--;
	remaining--;
	Delay(1);
	}
}

}*/

script "GiveExtraLife" (int number)
{
	if(number<1) number = 1;	//You requested an extra life, meaning you can't get zero!
	
	int number_2 = number;	//Sadly, a second variable is required for the "#UP" text.
	
	While(number>0)
	{
		if(lives<9) lives++;
		else ACS_ExecuteAlways(70,0,CONSTANT_1UP_PRIZE_SCORE,0,0);
		
		number--;
	}
	
	SetFont("SPECSTGF");
	int temp_alpha = 0.001;

	AmbientSound("misc/extralife",256);
	AmbientSound("misc/extralife",256);
	AmbientSound("misc/extralife",256);
	
	temp_alpha = 0.001;
	FadeTo(255,255,64,1.0,0.1);
	While(temp_alpha<0.95)
	{
		HUDMessageBold(d:number_2, s:"UP";
			HUDMSG_PLAIN|HUDMSG_ALPHA, 99, CR_UNTRANSLATED, 0.55-(cos(temp_alpha)/16), 0.99-(sin(temp_alpha)/2), 0.1, 0.5-temp_alpha);
		Delay(1);
		FadeTo(255,255,64,0.0,1.0);
		temp_alpha += 0.01;
	}
}

//Deathmatch-related
script "RemovePlayerTID" DEATH
{
Thing_ChangeTID(GetCurrentPlayerTID(),0);
Delay(1);
TakeActorInventory(GetCurrentPlayerTID(),"CoinSP",999);
}

script "TransferPlayerTID" RESPAWN
{
	Thing_ChangeTID(1000+PlayerNumber(),0);	//Get rid of the player's old thing ID...
	respawned[PlayerNumber()] = TRUE;
    Thing_ChangeTID (0, 1000+PlayerNumber());	//...then update it to this new "body".
}

function int abs (int x)
{
    if (x < 0)
        return -x;

    return x;
}

script "CheckGMode" (void)
{
If(GameType()==GAME_NET_DEATHMATCH) SetResultValue(TRUE);
Else SetResultValue(FALSE);
}

script "WarpToHut" (void)
{
	If(StrParam(n:PRINTNAME_LEVEL)=="AREA1"||ACS_NamedExecuteWithResult("CheckSpecialStage",FALSE,0,0,0)==TRUE||ACS_NamedExecuteWithResult("CheckSpecialStage",2,0,0,0)==TRUE||GetActorZ(0)-GetActorFloorZ(0)>8.25||WaterLevel(0)>2||CheckActorFloorTexture(0, "SPEC_SKY")) { Log(s:"\c[Brick]You can't warp at the moment."); LocalAmbientSound("misc/buzzer",255); Terminate; }
	Else
	{
		PlaySound(0, "misc/teleport_fast", CHAN_AUTO|CHAN_NOPAUSE, 0.75, FALSE);
		ACS_NamedExecuteAlways("PlayerMovement",0,TRUE,TRUE,TRUE);
		fadeout = 1;
		Delay(50);
		ACS_NamedExecuteAlways("PlayerMovement",0,FALSE,TRUE,TRUE);
		StopSound(0, 1);
		StopSound(0, 2);
		StopSound(0, 3);
		StopSound(0, 4);
		StopSound(0, 5);
		StopSound(0, 6);
		StopSound(0, 7);
		StopSound(0, 0);
		ss_returnlevel = GetLevelInfo(LEVELINFO_LEVELNUM);	//Indicate what level to return to to prevent the strange 1-2 glitch.
		Delay(1);
		stored_velocity[0] = -616.5;	//This odd value will force the game to take you to the hut.
		ss_return_id = -(checkpoint_id[PlayerNumber()]);
		ChangeLevel("AREA1",0,CHANGELEVEL_NOINTERMISSION|CHANGELEVEL_PRERAISEWEAPON, GameSkill());	//Teleport the player to the hut!
	}
}

//Balls don't correctly detect enemies and objects, glitchily freezing in the air as the enemy walks through them.
//To fix this, this ACS script runs during a ball's "life" and commands it to deal damage if its position doesn't change.
script "BallMonitorGlitchyBehavior" (void)
{
	int oldx, oldy, /*oldz,*/ exist_tics;	//These are used for the position checks below.
	While(CheckInventory("Variable3")==0&&exist_tics<50)
	{
		oldx = GetActorX(0)>>16;
		oldy = GetActorY(0)>>16;
		//oldz = GetActorZ(0)>>16;
		
		exist_tics++;
		Delay(1);
		
		If(GetActorX(0)>>16==oldx&&GetActorY(0)>>16==oldy/*&&GetActorZ(0)>>16==oldz*/) GiveInventory("Variable4",1);	//Force the ball to disappear.
	}
}

///////////////////////////////
//Juice box technical scripts//
///////////////////////////////

script "JuiceBoxCheck" (int type)
{
int comp;

comp = 200;

if(type==0) comp -= 25;
if(type==1) comp -= 50;

If(GetActorProperty(GetCurrentPlayerTID(),APROP_HEALTH)<comp) SetResultValue(TRUE);	//Juice boxes
Else SetResultValue(FALSE);
}

script "JuiceBoxRecover" (int type)
{
int remjuice = 50;	//Normal
if(GameSkill()==0)remjuice = 100;	//Easy
if(GameSkill()==2)remjuice = 75;	//Hard

int times = 0;
int delayx = 1;
int times_inc = 20;	//Normal
if(GameSkill()==0)times_inc = 40;	//Easy
if(GameSkill()==2)times_inc = 30;	//Hard

if(type==TRUE) remjuice = remjuice * 2;
if(type==TRUE) times_inc = times_inc * 2;

While(remjuice>0)
	{
	If(times==0)
	{
		if(GetActorProperty(GetCurrentPlayerTID(),APROP_HEALTH)<200)
		{
			SetActorProperty(GetCurrentPlayerTID(),APROP_Health,GetActorProperty(GetCurrentPlayerTID(),APROP_Health)+8);
			remjuice = remjuice - 8;
		}
	}

	If(times==1)
	{
		if(GetActorProperty(GetCurrentPlayerTID(),APROP_HEALTH)<200)
		{
			SetActorProperty(GetCurrentPlayerTID(),APROP_Health,GetActorProperty(GetCurrentPlayerTID(),APROP_Health)+4);
			remjuice = remjuice - 4;
		}
	}

	If(times==2)
	{
		if(GetActorProperty(GetCurrentPlayerTID(),APROP_HEALTH)<200)
		{
			SetActorProperty(GetCurrentPlayerTID(),APROP_Health,GetActorProperty(GetCurrentPlayerTID(),APROP_Health)+2);
			remjuice = remjuice - 2;
		}
	}

	if(times>2)
	{
		if(GetActorProperty(GetCurrentPlayerTID(),APROP_HEALTH)<200) SetActorProperty(GetCurrentPlayerTID(),APROP_Health,GetActorProperty(GetCurrentPlayerTID(),APROP_Health)+1);
		if(times % times_inc == 0) delayx++;
		remjuice--;
	}
	times++;
	Delay(delayx);
	}
}

script "CheckSpecialStage" (int mode)
{
	Switch(mode)
	{
		Case 0:	//Whether the current level is a Special Stage
			if( (StrParam(n:PRINTNAME_LEVEL)=="SPECSTG1" || StrParam(n:PRINTNAME_LEVEL)=="SPECSTG2" || StrParam(n:PRINTNAME_LEVEL)=="SPECSTG3" || StrParam(n:PRINTNAME_LEVEL)=="SPECSTG4" || StrParam(n:PRINTNAME_LEVEL)=="SPECSTG5" || StrParam(n:PRINTNAME_LEVEL)=="SPECSTG6" || StrParam(n:PRINTNAME_LEVEL)=="SPECSTG7") && GameType()!=GAME_NET_DEATHMATCH) SetResultValue(TRUE);
			else SetResultValue(FALSE);
		Break;
		Case 1:	//Return the current Special Stage number.s
			SetResultValue(ss_number-1);
		Break;
		Case 2:	//Whether this is the Small Hut.
			if(StrParam(n:PRINTNAME_LEVEL)=="AREA1"/*world_info[0]==1&&world_info[1]==1&&ss_position==3*/) SetResultValue(TRUE);
			else SetResultValue(FALSE);
		Break;
		Case 3:	//Returns TRUE if in an arena map.
			if( (StrParam(n:PRINTNAME_LEVEL)=="ARENA1") && GameType()!=GAME_NET_DEATHMATCH) SetResultValue(TRUE);
			else SetResultValue(FALSE);
		Break;


	}
}

//////////////////////////
//Coin conversion script//
//////////////////////////

script "ConvertCoinTicsToCoins" (int remove)	//Remove here won't give the coins back to the player.
{
	If(GameType()==GAME_SINGLE_PLAYER) SetActivator(1000, AAPTR_PLAYER1);	//If this is singleplayer, make sure the activator is player 1, just in case.
	
	int damagec, healc, ninjac, waterc, comboc, speedc;
	
	//First, get how many whole coins player 1 has that could be converted.
	damagec = damage_tics[PlayerNumber()]/(35*CONST_SECS_DAMAGE);
	healc = heal_tics[PlayerNumber()]/(35*CONST_SECS_HEAL);
	ninjac = ninja_tics[PlayerNumber()]/(35*CONST_SECS_NINJA);
	waterc = water_tics[PlayerNumber()]/(35*CONST_SECS_WATER);
	comboc = combo_tics[PlayerNumber()]/(35*CONST_SECS_COMBO);
	speedc = speed_tics[PlayerNumber()]/(35*CONST_SECS_SPEED);
	
	//Next, see if they have at least half of a coin left; If so, let them keep the coin.
	//First, however, a modulo must be done to see what tics were left.
	damage_tics[PlayerNumber()] = damage_tics[PlayerNumber()]%(35*CONST_SECS_DAMAGE);
	heal_tics[PlayerNumber()] = heal_tics[PlayerNumber()]%(35*CONST_SECS_HEAL);
	ninja_tics[PlayerNumber()] = ninja_tics[PlayerNumber()]%(35*CONST_SECS_NINJA);
	water_tics[PlayerNumber()] = water_tics[PlayerNumber()]%(35*CONST_SECS_WATER);
	combo_tics[PlayerNumber()] = combo_tics[PlayerNumber()]%(35*CONST_SECS_COMBO);
	speed_tics[PlayerNumber()] = speed_tics[PlayerNumber()]%(35*CONST_SECS_SPEED);
	
	//If the amount that was left is greater than half of a coin's time, consider it good enough to keep.
	If(damage_tics[PlayerNumber()]>(35*(CONST_SECS_DAMAGE/2))) damagec++;
	If(heal_tics[PlayerNumber()]>(35*(CONST_SECS_HEAL/2))) healc++;
	If(ninja_tics[PlayerNumber()]>(35*(CONST_SECS_NINJA/2))) ninjac++;
	If(water_tics[PlayerNumber()]>(35*(CONST_SECS_WATER/2))) waterc++;
	If(combo_tics[PlayerNumber()]>(35*(CONST_SECS_COMBO/2))) comboc++;
	If(speed_tics[PlayerNumber()]>(35*(CONST_SECS_SPEED/2))) speedc++;
	
	//Clear the "tics" variables as the results are now in!
	damage_tics[PlayerNumber()] = 0;
	heal_tics[PlayerNumber()] = 0;
	ninja_tics[PlayerNumber()] = 0;
	water_tics[PlayerNumber()] = 0;
	combo_tics[PlayerNumber()] = 0;
	speed_tics[PlayerNumber()] = 0;
	
	//Give the player the coins they've converted.
	if(remove==FALSE)
	{
		GiveInventory("PowerupDamage", damagec);
		GiveInventory("PowerupHeal", healc);
		GiveInventory("PowerupNinja", ninjac);
		GiveInventory("PowerupWater", waterc);
		GiveInventory("PowerupCombo", comboc);
		GiveInventory("PowerupSpeed", speedc);
	}
	
	If(important_fade[PlayerNumber()]==FALSE) FadeTo(0, 0, 0, 0.0, 0.05);	//The screen stays tinted after this; Force it to return to normal.
}

/////////////////////////////////
//Miscellaneous and combo meter//
/////////////////////////////////

int entering_ss;	//This is set to 50 when entering a Special Stage. This stops updating the player's position for a bit and reverses their angle.

int democam_tics;	//How many tics until the current demo camera reverts to the first-person view.
int democam_tid;	//The thing ID of the last camera activated, used to deactivate it later.
script "DemoCamera" (int tid, int seconds_democam, int condition)
{
	If(GetCVAR("cl_demo")==FALSE) Terminate;
	
	If(condition==0 ||
	(condition==1 && GetActorZ(0)-GetActorFloorZ(0)<8.0) ||															//1: on ground
	(condition==2 && (abs(GetActorVelX(0))>12.5||abs(GetActorVelY(0))>12.5)) ||										//2: moving fast
	(condition==3 && GetActorZ(0)-GetActorFloorZ(0)<8.0 && (abs(GetActorVelX(0))>12.5||abs(GetActorVelY(0))>12.5))	//3: Both 1 and 2
	)
	{
		Thing_Activate(tid);
		democam_tics = 35 * seconds_democam;
		democam_tid = tid;	//Give the thing ID of the camera to disable it later.
		ChangeCamera(tid, TRUE, FALSE);
	}
}

script "DemoTimer" OPEN
{
	If(GetCVAR("cl_demo")==FALSE) Terminate;
	int demo_seconds = 30;
	int lump_name2 = StrParam(n:PRINTNAME_LEVEL);

	While(demo_seconds>0)
	{
		If(GetCVAR("cl_demo")==TRUE&&demo_seconds % 2 == 0&&lump_name2 != "INTRO" && lump_name2 != "TITLE")
		{
			SetHUDSize(1024,640,TRUE);
			SetFont("TITLEFNT");
			HUDMessage(l:"TITLE_PROMPT1";
				HUDMSG_FADEINOUT, 100, CR_UNTRANSLATED, 800.4,420.1, 0.01, 1.0, 1.0);
			SetHUDSize(512,320,TRUE);
			SetFont("M_DOOM");
			HUDMessage(s:"A";
				HUDMSG_PLAIN, 101, CR_UNTRANSLATED, 586.2,5.1, 4.0);	//Is 585 or 586 more square? Verify in the future.
		}
		
		If(GetCVAR("cl_demo")==TRUE) { SetFont("BIG_TEXT"); PrintBold(d:demo_seconds); }
		Delay(35);
		demo_seconds--;
	}
	
	If(GetCVAR("cl_demo")==TRUE) PrintBold(s:"Wait for fade...");
	important_fade[0] = TRUE;
	FadeTo(0,0,0,1.0,1.0);
	Delay(35);
	If(GetCVAR("cl_demo")==TRUE) PrintBold(s:"NOW LAND IT!");
}

script "TitleOverlay" (void)
{
	PlaySound(1000,"misc/title_name", CHAN_BODY|CHAN_NOPAUSE);
	int tkeyprompt_times = 0;
	SetHUDSize(256,160,TRUE);
	SetFont("M_DOOM");
	HUDMessageBold(s:"A";
		HUDMSG_FADEINOUT, 0, CR_UNTRANSLATED, 128.0,40.0, 28.0, 1.0, 1.0);	
	SetHUDSize(1024,640,FALSE);
	SetFont("3DLETTER");
	HUDMessageBold(s:"(C)2016-2018 Xane Corp. Version 1.88";
		HUDMSG_FADEINOUT, 0, CR_WHITE, 1236.2,638.2, 28.0, 1.0, 1.0);

	SetHUDSize(512,320,TRUE);
	While(tkeyprompt_times<15)
	{
		HUDMessageBold(l:"TITLE_PROMPT1", s:" ", l:"TITLE_PROMPT2";
		HUDMSG_FADEINOUT, 0, CR_UNTRANSLATED, 256.0,200.0, 0.01, 1.0, 1.0);
		Delay(70);
		tkeyprompt_times++;
		If(tkeyprompt_times==1) PlaySound(1000,"misc/title_begin", CHAN_VOICE|CHAN_NOPAUSE);
	}
}

script "UpdateMiscellaneous" ENTER  //Armor is the "combo meter". This script updates things every tic. Avoid Delay(#) here!
{
bool wl;
int wind_reduction;
int pushvels[3];	//Calculated wind X/Y velocities based on the wind_reduction variable.
framecount = 0;

Delay(1);
Until(level_ready==TRUE) Delay(1);	//Wait for SeamlessHelper before starting the main loop.

While(1)
	{
		If(GetCVAR("cl_demo")==TRUE)
		{
			if(framecount % 4 == 1) SetActorProperty(1000, APROP_Health, 100);
			
			If(PlayerClass(0)==CHAR_MARY&framecount<8) GiveInventory("MaryHammer",1);
			If(PlayerClass(0)==CHAR_MARY&framecount<8) GiveInventory("MaryUmbrella",1);
			If(PlayerClass(0)==CHAR_MARY&framecount<8) GiveInventory("MaryWand",1);
			If(PlayerClass(0)==CHAR_XANE&framecount<8) GiveInventory("XaneSword",1);
			If(PlayerClass(0)==CHAR_MARY&&framecount<8) UseInventory("MaryHammer");
			If(PlayerClass(0)==CHAR_MARY&&framecount<8) TakeInventory("MaryUmbrella_Intro",1);
			If(PlayerClass(0)==CHAR_XANE&&framecount<8) UseInventory("XaneSword");
			
		}
		
		If(GetCVAR("cl_demo")==TRUE&&democam_tics>0)
		{
			democam_tics--;
			if(democam_tics==0) { ChangeCamera(0, TRUE, FALSE); If(democam_tid>0) Thing_Deactivate(democam_tid); }	//Revert the demo player's camera to the first-person camera view.
		}
		
		//Print(d:on_ground[0], s:" AND DETECTION IS ", d:detected[0]);
		If(GetCVAR("debug_wind")!=FALSE) PrintBold(s:"-WIND DEBUG-\n\nREQ: ", f:direction[0], s:"\nCUR: ", f:wind_phase[0], s:"\nPWR: ", d:wind_power[0], s:"\nFORCE DIR: ", d:override[0], s:"\nDISABLE: ", d:disablewind[0], s:" (", d:wind_disabledelay[0], s:")\n\nALSO, FLOWERS VARIABLE (LAG REASON) IS\n", d:flowers);
		
		If(no_scripts[PlayerNumber()]==FALSE&&GameType()!=GAME_NET_DEATHMATCH&&openInput[PlayerNumber()] & BT_USER2&&!(openInput[MAX_PLAYERS+PlayerNumber()] & BT_USER2)) { ACS_NamedExecute("WarpToHut",0,0,0,0); }
		
		pushvels[0] = 0;	//Clear the wind velocity variables before setting them to avoid thrusting the player around with no wind.
		pushvels[1] = 0;
		//[2] is for reducing boost velocity when jumping.
		
		If(GetActorZ(0)-GetActorFloorZ(0)<4.5) { wind_reduction = 2; pushvels[2] = 0; }
		Else { wind_reduction = 32; pushvels[2] = 1; }
		
		If(flight_script_running[PlayerNumber()]==TRUE&&CheckInventory("MaryHammer_MidAirDone")==FALSE) wind_reduction = 4;
		
		If(CheckInventory("SuperX")) wind_reduction += 6;
		
		If(disablewind[PlayerNumber()]==FALSE&&wind_power[PlayerNumber()]>0) { pushvels[0] = wind_x[PlayerNumber()]/wind_reduction; pushvels[1] = wind_y[PlayerNumber()]/wind_reduction; }
		
		If(pushvels[2]==FALSE) SetActorVelocity(0, pushvels[0]+boost_properties[MAX_PLAYERS+PlayerNumber()], pushvels[1]+boost_properties[(MAX_PLAYERS*2)+PlayerNumber()],0,TRUE,TRUE); //Move the player with the wind and boost panels.
		Else SetActorVelocity(0, pushvels[0]+(boost_properties[MAX_PLAYERS+PlayerNumber()]/16), pushvels[1]+(boost_properties[(MAX_PLAYERS*2)+PlayerNumber()]/16),0,TRUE,TRUE);
			
		if(boost_properties[PlayerNumber()]>0) boost_properties[PlayerNumber()]--;
		Else { boost_properties[MAX_PLAYERS+PlayerNumber()] = 0; boost_properties[(MAX_PLAYERS*2)+PlayerNumber()] = 0; }
		
		If(wind_disabledelay[PlayerNumber()]>0) wind_disabledelay[PlayerNumber()]--;
		
		if(PlayerNumber()==0) framecount++;
		
		if(entering_ss==0&&GetActorZ(0)-GetActorFloorZ(0)==0.0&&framecount>5&&CheckActorFloorTexture(0, "SPECTS04")==FALSE&&CheckActorFloorTexture(0, "SPECTS07")==FALSE&&CheckActorFloorTexture(0, "SPEC_SKY")==FALSE&&ACS_NamedExecuteWithResult("CheckSpecialStage",0,0,0,0)==FALSE&&ACS_NamedExecuteWithResult("CheckSpecialStage",2,0,0,0)==FALSE)
		{
			last_ground_position[PlayerNumber()] = GetActorX(0);
			last_ground_position[MAX_PLAYERS+PlayerNumber()] = GetActorY(0);
			last_ground_position[(MAX_PLAYERS*2)+PlayerNumber()] = GetActorZ(0)+8.0;
			last_ground_position[(MAX_PLAYERS*3)+PlayerNumber()] = GetActorAngle(0);
			//Print(s:"X: ", d:last_ground_position[PlayerNumber()] >> 16, s:"\nY: ", d:last_ground_position[MAX_PLAYERS+PlayerNumber()] >> 16, s:"\nZ: ", d:last_ground_position[(MAX_PLAYERS*2)+PlayerNumber()] >> 16, s:"\nA: ", f:last_ground_position[(MAX_PLAYERS*3)+PlayerNumber()]);
		}
		
		last_ground_position[(MAX_PLAYERS*4)+PlayerNumber()] = 0.0;	//Clear this variable first.
		if(GetActorZ(0)-GetActorFloorZ(0)>8.5&&GetActorVelZ(0)>3.5)	last_ground_position[(MAX_PLAYERS*4)+PlayerNumber()] = GetActorVelZ(0);	//Misleading, but it saves a variable! MAX_PLAYERS*4 is for going through platforms.
		
		If(entering_ss==49) last_ground_position[(MAX_PLAYERS*3)+PlayerNumber()] += 0.5;	//Turn the player's respawn point around.
		If(entering_ss>0) entering_ss--;	//Decrease the timer to make the position update by the time the player returns to this level.
		
		If(sdelay>0) sdelay--;
		If(sdelay<0) sdelay = 0;
		
		If(claw_verify_tics>0) claw_verify_tics--;
		//If(GetActorCeilingZ(0)-GetActorZ(0)<56.5&&GetActorVelZ(0)>1.25) { SetActorVelocity(0, GetActorVelX(0), GetActorVelY(0), -(GetActorVelZ(0))/2, FALSE, TRUE); PlaySound(GetCurrentPlayerTID(), "misc/hit_ceiling", CHAN_WEAPON, 0.8, FALSE, 0.8); }	//If the player went too close to the ceiling, make them hit their head on it!
		
		If(ACS_NamedExecuteWithResult("CheckSpecialStage",0,0,0,0)==FALSE&&ACS_NamedExecuteWithResult("CheckSpecialStage",2,0,0,0)==FALSE)
		{
			if(water_tics[PlayerNumber()]>0&&no_scripts[PlayerNumber()]==FALSE)
			{
				if(important_fade[PlayerNumber()]==FALSE&&framecount % 14 == 0) FadeTo(64,128,255,0.25,0.1);
				water_tics[PlayerNumber()]--;
				If(important_fade[PlayerNumber()]==FALSE&&water_tics[PlayerNumber()]==0) FadeTo(0,0,0,0.0,0.5);
			}
			
			if(ninja_tics[PlayerNumber()]>0&&no_scripts[PlayerNumber()]==FALSE)
			{
				if(important_fade[PlayerNumber()]==FALSE&&framecount % 14 == 2) FadeTo(255,128,255,0.1,0.1);
				ninja_tics[PlayerNumber()]--;
				If(important_fade[PlayerNumber()]==FALSE&&ninja_tics[PlayerNumber()]==0) { FadeTo(0,0,0,0.0,0.5); }
			}
			
			if(damage_tics[PlayerNumber()]>0&&no_scripts[PlayerNumber()]==FALSE)
			{
				if(important_fade[PlayerNumber()]==FALSE&&framecount % 14 == 4) FadeTo(255,128,64,0.25,0.1);
				damage_tics[PlayerNumber()]--;
				If(important_fade[PlayerNumber()]==FALSE&&damage_tics[PlayerNumber()]==0) { FadeTo(0,0,0,0.0,0.5); }
			}

			if(heal_tics[PlayerNumber()]>0&&no_scripts[PlayerNumber()]==FALSE)
			{
				if(important_fade[PlayerNumber()]==FALSE&&framecount % 14 == 6) FadeTo(64,255,255,0.1,0.1);
				If(framecount % 7 == 6) HealThing(1,100);
				heal_tics[PlayerNumber()]--;
				If(important_fade[PlayerNumber()]==FALSE&&heal_tics[PlayerNumber()]==0) { FadeTo(0,0,0,0.0,0.5); }
			}
			
			if(combo_tics[PlayerNumber()]>0&&no_scripts[PlayerNumber()]==FALSE)
			{
				if(important_fade[PlayerNumber()]==FALSE&&framecount % 14 == 8) FadeTo(255,255,64,0.1,0.1);
				combo_tics[PlayerNumber()]--;
				If(important_fade[PlayerNumber()]==FALSE&&combo_tics[PlayerNumber()]==0) { FadeTo(0,0,0,0.0,0.5); }
			}
			
			if(speed_tics[PlayerNumber()]>0&&no_scripts[PlayerNumber()]==FALSE)
			{
				if(important_fade[PlayerNumber()]==FALSE&&framecount % 14 == 10) FadeTo(64,255,192,0.1,0.1);
				speed_tics[PlayerNumber()]--;
				If(important_fade[PlayerNumber()]==FALSE&&combo_tics[PlayerNumber()]==0) { FadeTo(0,0,0,0.0,0.5); }
			}
		}
		
		If(tics_scoreround>-1)	//If the score doesn't end in 0 or 5, round it up or down.
		{
			tics_scoreround--;
			If(tics_scoreround==0)
			{
				If(score[PlayerNumber()] % 5 <= 2) score[PlayerNumber()] -= score[PlayerNumber()] % 5;
				Else score[PlayerNumber()] += (5 - (score[PlayerNumber()] % 5) );
				tics_scoreround = -1;	//Disable rounding score.
			}
		}
		
		If(walljumping[PlayerNumber()]>0) walljumping[PlayerNumber()]--;
		If(spring_timer>0) spring_timer--;	//Spring timer is used to prevent the game from trying to use boosting objects too quickly.
		
		If(totalcointics>0)
		{
			totalcointics--;
			If(total_coins<0) total_coins = 0;
			GiveActorInventory(1000,"ShowTotalCoins",1);
			GiveActorInventory(1001,"ShowTotalCoins",1);
			GiveActorInventory(1002,"ShowTotalCoins",1);
			GiveActorInventory(1003,"ShowTotalCoins",1);
			GiveActorInventory(1004,"ShowTotalCoins",1);
			GiveActorInventory(1005,"ShowTotalCoins",1);
			GiveActorInventory(1006,"ShowTotalCoins",1);
			GiveActorInventory(1007,"ShowTotalCoins",1);
		}
		Else
		{
			TakeActorInventory(1000,"ShowTotalCoins",1);
			TakeActorInventory(1001,"ShowTotalCoins",1);
			TakeActorInventory(1002,"ShowTotalCoins",1);
			TakeActorInventory(1003,"ShowTotalCoins",1);
			TakeActorInventory(1004,"ShowTotalCoins",1);
			TakeActorInventory(1005,"ShowTotalCoins",1);
			TakeActorInventory(1006,"ShowTotalCoins",1);
			TakeActorInventory(1007,"ShowTotalCoins",1);
		}
		
		if(moved_up_wall[PlayerNumber()]>0&&no_scripts[PlayerNumber()]==FALSE) moved_up_wall[PlayerNumber()]--;
		
		If(walljumping[PlayerNumber()]>0&&no_scripts[PlayerNumber()]==FALSE) walljumping[PlayerNumber()]--; If(hammermove[PlayerNumber()]>0) hammermove[PlayerNumber()]--;
		
		If(CheckInventory("HammerUpgrades")<upgrades[0])
		{
			TakeInventory("HammerUpgrades",5);
			GiveInventory("HammerUpgrades",upgrades[0]);
		}
		If(CheckInventory("CoinLimit")<upgrades[1])
		{
			TakeInventory("CoinLimit",999);
			GiveInventory("CoinLimit",upgrades[1]);
		}
		If(CheckInventory("UmbrellaUpgrades")<upgrades[2])
		{
			TakeInventory("UmbrellaUpgrades",3);
			GiveInventory("UmbrellaUpgrades",upgrades[2]);
		}
		If(CheckInventory("SwordUpgrades")<upgrades[3])
		{
			TakeInventory("SwordUpgrades",3);
			GiveInventory("SwordUpgrades",upgrades[3]);
		}
		
		If(ACS_NamedExecuteWithResult("CheckSpecialStage",0,0,0,0)==FALSE&&CheckInventory("CoinSP")>CheckInventory("CoinLimit")) TakeInventory("CoinSP",CheckInventory("CoinSP")-CheckInventory("CoinLimit"));
		
		If(specialbehavior[PlayerNumber()]==0&&WaterLevel(0)==4) airsupply[PlayerNumber()]--;
		Else airsupply[PlayerNumber()] = 1050;
		
		If(airsupply[PlayerNumber()]<=0) { force_death[PlayerNumber()] = TRUE; }
		
		if(abs(GetActorVelX(1000+PlayerNumber()))>19.1||abs(GetActorVelY(1000+PlayerNumber())>19.1)) GiveInventory("SpeedTrailX",1);
		Else TakeInventory("PowerSpeed",1);
		
		If(CheckActorInventory(GetCurrentPlayerTID(),"SuperX")==FALSE)
		{
			If(speed_tics[PlayerNumber()]==0) SetActorProperty(GetCurrentPlayerTID(), APROP_Speed, 1.0);
			Else SetActorProperty(GetCurrentPlayerTID(), APROP_Speed, 1.18);
			SetActorProperty(GetCurrentPlayerTID(), APROP_Friction, 1.0);
			SetActorProperty(GetCurrentPlayerTID(), APROP_DamageMultiplier, 1.0);
		}
		Else
		{
			If(speed_tics[PlayerNumber()]==0) SetActorProperty(GetCurrentPlayerTID(), APROP_Speed, 1.225);
			Else SetActorProperty(GetCurrentPlayerTID(), APROP_Speed, 1.413);
			SetActorProperty(GetCurrentPlayerTID(), APROP_Friction, 1.015);
			SetActorProperty(GetCurrentPlayerTID(), APROP_DamageMultiplier, 1.5);
		}
		
		If(forcenormal[PlayerNumber()]==TRUE&&no_movement[PlayerNumber()]==FALSE)
		{
			SetActorProperty(GetCurrentPlayerTID(), APROP_Speed, 1.0);
			SetActorProperty(GetCurrentPlayerTID(), APROP_Friction, 1.0);
		}
		
		if(no_movement[PlayerNumber()]>0)
		{
			no_movement[PlayerNumber()]--;
			SetActorProperty(GetCurrentPlayerTID(), APROP_Speed, 0.0);
			SetActorProperty(GetCurrentPlayerTID(), APROP_Friction, 1.0);
		}
		
		If(
		(WaterLevel(0) >= 2&&wl==FALSE)
		||
		(WaterLevel(0) < 2&&wl==TRUE))
		{
		wl = !wl;
		if(wl==TRUE) SetActorProperty(GetCurrentPlayerTID(),APROP_Gravity,0.5);
		if(wl==FALSE) SetActorProperty(GetCurrentPlayerTID(),APROP_Gravity,1.0);
		}
		
		if(CheckActorInventory(GetCurrentPlayerTID(),"Health125")==FALSE && GetActorProperty(GetCurrentPlayerTID(),APROP_Health) > 125) GiveActorInventory(GetCurrentPlayerTID(),"Health125",1);
		if(CheckActorInventory(GetCurrentPlayerTID(),"Health125")==TRUE && GetActorProperty(GetCurrentPlayerTID(),APROP_Health) <= 125) TakeActorInventory(GetCurrentPlayerTID(),"Health125",1);

		if(CheckActorInventory(GetCurrentPlayerTID(),"ScoreX")!=0)
		{
			ACS_ExecuteAlways(70,0,CheckActorInventory(GetCurrentPlayerTID(),"ScoreX")*(1+combo[PlayerNumber()]),0,0)	;
			TakeActorInventory(GetCurrentPlayerTID(),"ScoreX",32767);
		}
		
		If(GetActorFloorZ(GetCurrentPlayerTID())-GetActorZ(GetCurrentPlayerTID())==0)
		{
			ACS_ExecuteAlways(66,0,1,0,0);
			spring[PlayerNumber()] = FALSE;
		}

		//If(PlayerClass(PlayerNumber())==0) If(kjumped[PlayerNumber()]>0) kjumped[PlayerNumber()]--;
		
		If(CheckActorInventory(GetCurrentPlayerTID(),"Armor")!=meter[PlayerNumber()])
		{
				TakeActorInventory(GetCurrentPlayerTID(),"Armor",100);
				GiveActorInventory(GetCurrentPlayerTID(),"NotArmorBonus",meter[PlayerNumber()]);
		}
		
		If(CheckInventory("SuperX")==TRUE&&damage_tics[PlayerNumber()]>0) { GiveInventory("InternalDCoin_Super",1); }
		Else If(CheckInventory("SuperX")==TRUE) { GiveInventory("InternalDSuper",1); }
		Else If(damage_tics[PlayerNumber()]>0) { GiveInventory("InternalDCoin",1); }
		
		Delay(1);	//The only "delay" allowed.
		
		//After the delay, take away all of the player's damage-increasing "powerups".
		TakeInventory("PowerDamage",99);
		TakeInventory("PowerDoubleDamage",99);
		TakeInventory("InternalDCoin",99);
		TakeInventory("InternalDSuper",99);
		TakeInventory("InternalDCoin_Super",99);
		TakeInventory("PowerDCoin",99);
		TakeInventory("PowerDSuper",99);
		TakeInventory("PowerDCoin_Super",99);
		
	}
}

script "SpeedDebug" ENTER
{
	If(GetCVAR("debug_hammer")) upgrades[0] = CONST_MAXUPGRADES_HAMMER;
	If(GetCVAR("debug_umbrella")) upgrades[2] = CONST_MAXUPGRADES_UMBRELLA;
	If(GetCVAR("debug_sword")) upgrades[3] = CONST_MAXUPGRADES_SWORD;
	
	While(1)
	{
		If(GetCVAR("debug_speed")==TRUE) PrintBold(d:GetActorVelX(0) >> 16, s:"\n", d:GetActorVelY(0) >> 16);
		If(GetCVAR("debug_speed")==FALSE) Delay(35); If(GetCVAR("debug_speed")==TRUE) Delay(1);
	}
}

script "HandleRamps" ENTER
{
int powers[2], oldheight[MAX_PLAYERS];

	While(1)
	{
		oldheight[PlayerNumber()] = GetActorZ(GetCurrentPlayerTID())-GetActorFloorZ(GetCurrentPlayerTID());

		Delay(1);	//After a tic, check for if the player went over a ramp.
		
		If(ramph[PlayerNumber()]>0 && rampv[PlayerNumber()]>0)
		{
			if(oldheight[PlayerNumber()]<12.0)
			{
			powers[0] = 0.25 * ramph[PlayerNumber()];	//4 = default, 1; Other umbes are multiples of 0.25.
			powers[1] = 0.25 * rampv[PlayerNumber()];
			
			jumps[PlayerNumber()] = 0;
			detected[PlayerNumber()] = 1;
			remjumps[PlayerNumber()] = 1;
			cancelJump[PlayerNumber()] = TRUE;
			
			If(abs(GetActorVelX(0))>abs(GetActorVelY(0))/*&&abs(GetActorVelX(0))>8.0*/) SetActorVelocity(0, FixedMul(GetActorVelX(0),powers[0]), FixedMul(GetActorVelY(0),powers[0]), FixedMul(abs(GetActorVelX(0)),powers[1]), FALSE, TRUE);
			If(abs(GetActorVelY(0))>abs(GetActorVelX(0))/*&&abs(GetActorVelY(0))>8.0*/) SetActorVelocity(0, FixedMul(GetActorVelX(0),powers[0]), FixedMul(GetActorVelY(0),powers[0]), FixedMul(abs(GetActorVelY(0)),powers[1]), FALSE, TRUE);
			
			Until(GetActorZ(GetCurrentPlayerTID())-GetActorFloorZ(GetCurrentPlayerTID())<8.0) { Delay(1); }
			}
			
		ramph[PlayerNumber()] = 0;
		rampv[PlayerNumber()] = 0;
		
		}
	}
}

script "PlayerMovement" (int mode, int all_players, int freeze)	//Freeze is used to cause special behavior. 1 = freeze, 2 = lock player only (rails)
{
hammermove[PlayerNumber()] = 35*60;
If(all_players==FALSE)
	{
	//Log(s:"SINGLE PLAYER");
	If(mode==FALSE)
		{
		//Log(s:"THAWED");
		no_scripts[PlayerNumber()] = FALSE;
		SetPlayerProperty(0,OFF,PROP_TOTALLYFROZEN);
		}
	If(mode==TRUE)
		{
		//Log(s:"FROZEN");
		no_scripts[PlayerNumber()] = TRUE;
		SetPlayerProperty(0,ON,PROP_TOTALLYFROZEN);
		}
	}
If(all_players==TRUE)
	{
	//Log(s:"ALL PLAYERS.");
	If(mode==FALSE)
		{
		//Log(s:"THAWED");
		For(int i1; i1 <=7; i1++) { no_scripts[i1] = FALSE; }
		SetPlayerProperty(1,OFF,PROP_TOTALLYFROZEN);
		}
	If(mode==TRUE)
		{
		//Log(s:"FROZEN");
		For(int i2; i2 <=7; i2++) { no_scripts[i2] = TRUE; }
		SetPlayerProperty(1,ON,PROP_TOTALLYFROZEN);
		}
	}

If(freeze>0)
	{
	If(mode==TRUE)
		{
			If(all_players==TRUE)
			{
				
				If(freeze==1)
				{
					GiveActorInventory(1000,"Cutscene",1);
					GiveActorInventory(1001,"Cutscene",1);
					GiveActorInventory(1002,"Cutscene",1);
					GiveActorInventory(1003,"Cutscene",1);
					GiveActorInventory(1004,"Cutscene",1);
					GiveActorInventory(1005,"Cutscene",1);
					GiveActorInventory(1006,"Cutscene",1);
					GiveActorInventory(1007,"Cutscene",1);
				}
				
				ACS_NamedExecuteAlways("SetWind",0,2,1,1);	//Prevent wind from moving all players while frozen.
				
				Delay(1);
				
				SetActorProperty(1000,APROP_Gravity,0.0);
				SetActorVelocity(1000,0.0,0.0,0.0,FALSE,FALSE);
				SetActorProperty(1001,APROP_Gravity,0.0);
				SetActorVelocity(1001,0.0,0.0,0.0,FALSE,FALSE);
				SetActorProperty(1002,APROP_Gravity,0.0);
				SetActorVelocity(1002,0.0,0.0,0.0,FALSE,FALSE);
				SetActorProperty(1003,APROP_Gravity,0.0);
				SetActorVelocity(1003,0.0,0.0,0.0,FALSE,FALSE);
				SetActorProperty(1004,APROP_Gravity,0.0);
				SetActorVelocity(1004,0.0,0.0,0.0,FALSE,FALSE);
				SetActorProperty(1005,APROP_Gravity,0.0);
				SetActorVelocity(1005,0.0,0.0,0.0,FALSE,FALSE);
				SetActorProperty(1006,APROP_Gravity,0.0);
				SetActorVelocity(1006,0.0,0.0,0.0,FALSE,FALSE);
				SetActorProperty(1007,APROP_Gravity,0.0);
				SetActorVelocity(1007,0.0,0.0,0.0,FALSE,FALSE);
			}
			Else
			{
				stored_velocity[0] = GetActorVelX(GetCurrentPlayerTID());
				stored_velocity[1] = GetActorVelY(GetCurrentPlayerTID());
				stored_velocity[2] = GetActorVelZ(GetCurrentPlayerTID());
				
				If(freeze==1) GiveInventory("Cutscene",1);
				ACS_NamedExecuteAlways("SetWind",0,2,1,0);	//Prevent wind from moving the player while they're frozen.
				SetActorProperty(1000+PlayerNumber(),APROP_Gravity,0.0);
				SetActorVelocity(1000+PlayerNumber(),0.0,0.0,0.0,FALSE,FALSE);
			}
			
			ltime_control = TIME_PAUSE;
		}
	Else
		{
			If(all_players==TRUE)
			{
				If(freeze==1)
				{
					TakeActorInventory(1000,"PowerTimeFreezer",1);
					TakeActorInventory(1001,"PowerTimeFreezer",1);
					TakeActorInventory(1002,"PowerTimeFreezer",1);
					TakeActorInventory(1003,"PowerTimeFreezer",1);
					TakeActorInventory(1004,"PowerTimeFreezer",1);
					TakeActorInventory(1005,"PowerTimeFreezer",1);
					TakeActorInventory(1006,"PowerTimeFreezer",1);
					TakeActorInventory(1007,"PowerTimeFreezer",1);
				}
				
				ACS_NamedExecuteAlways("SetWind",0,2,0,1);	//Re-allow wind to affect the player now.
				
				SetActivator(1000,AAPTR_PLAYER1); ACS_NamedExecuteAlways("RememberGravity",0,0,0,0);
				SetActivator(1001,AAPTR_PLAYER2); ACS_NamedExecuteAlways("RememberGravity",0,0,0,0);
				SetActivator(1002,AAPTR_PLAYER3); ACS_NamedExecuteAlways("RememberGravity",0,0,0,0);
				SetActivator(1003,AAPTR_PLAYER4); ACS_NamedExecuteAlways("RememberGravity",0,0,0,0);
				SetActivator(1004,AAPTR_PLAYER5); ACS_NamedExecuteAlways("RememberGravity",0,0,0,0);
				SetActivator(1005,AAPTR_PLAYER6); ACS_NamedExecuteAlways("RememberGravity",0,0,0,0);
				SetActivator(1006,AAPTR_PLAYER7); ACS_NamedExecuteAlways("RememberGravity",0,0,0,0);
				SetActivator(1007,AAPTR_PLAYER8); ACS_NamedExecuteAlways("RememberGravity",0,0,0,0);
			}
			Else
			{
				If(freeze==1) TakeInventory("PowerTimeFreezer",1);
				ACS_NamedExecuteAlways("SetWind",0,2,0,0);	//Re-allow wind to affect the player now.
				If(freeze==1) SetActorVelocity(1000+PlayerNumber(),stored_velocity[0],stored_velocity[1],stored_velocity[2],FALSE,FALSE);
				ACS_NamedExecuteAlways("RememberGravity",0,0,0,0);
			}
			ltime_control = TIME_PLAY;
		}
	}
	
  if(mode==FALSE)
  {
	If(all_players==TRUE)
	{
	  hammermove[0] = 35;
	  hammermove[1] = 35;
	  hammermove[2] = 35;
	  hammermove[3] = 35;
	  hammermove[4] = 35;
	  hammermove[5] = 35;
	  hammermove[6] = 35;
	  hammermove[7] = 35;
	}
	Else
	{
	  hammermove[PlayerNumber()] = 35;
	}
  }
}

script "ShowEnding" (int failed)
{
ACS_NamedExecuteAlways("PlayerMovement",0,1,0,0);
If(failed==FALSE)ACS_NamedExecute("DetermineScore",0,0,0,0);
If(failed==FALSE)Delay(100);
If(failed==FALSE)If(PlayerNumber()==0)ACS_NamedExecute("AddCGem",0,0,0,0);

FadeTo(0,0,0,100.0,0.75);
GiveActorInventory(GetCurrentPlayerTID(),"NoHUD",1);
Delay(27);
SetActorPosition(1000,GetActorX(1050),GetActorY(1050),GetActorFloorZ(1050),0);
SetActorPosition(1001,GetActorX(1051),GetActorY(1051),GetActorFloorZ(1051),0);
SetActorPosition(1002,GetActorX(1052),GetActorY(1052),GetActorFloorZ(1052),0);
SetActorPosition(1003,GetActorX(1053),GetActorY(1053),GetActorFloorZ(1053),0);
SetActorPosition(1004,GetActorX(1054),GetActorY(1054),GetActorFloorZ(1054),0);
SetActorPosition(1005,GetActorX(1055),GetActorY(1055),GetActorFloorZ(1055),0);
SetActorPosition(1006,GetActorX(1056),GetActorY(1056),GetActorFloorZ(1056),0);
SetActorPosition(1007,GetActorX(1057),GetActorY(1057),GetActorFloorZ(1057),0);


SetFont("BGSSCOMP");	//The background is now actually on-screen!
HUDMessage (s:"A";
	HUDMSG_FADEINOUT, 4, CR_UNTRANSLATED, 0.5, 0.5, 6.0, 0.75, 0.75);   //Player number
				

ACS_NamedExecuteAlways("ShowCGemGFX",0,0,0,0);

for (int ms2 = -0.5; ms2 < 0; ms2 += 0.034) {
            SetFont("SPECSTGF");
		if(failed==FALSE)
		{
			If(cgem_count<=6)
			{
				SetFont("SPECSTGF");
				HUDMessage (n:0, s:" ", l:"SS_SUCCESS1";
					HUDMSG_FADEOUT, 1, CR_UNTRANSLATED, 0.5-ms2,0.15, 1.0, 0.05, 0.05);   //Player number
				HUDMessage (l:"SS_SUCCESS2";
					HUDMSG_FADEOUT, 2, CR_UNTRANSLATED, 0.5+ms2,0.25, 1.0, 0.05, 0.05);   //Player number
				
			}
			Else
			{
				SetFont("SPECSTGF");
				HUDMessage (n:0, s:" ", l:"SS_SUCCESS3";
					HUDMSG_FADEOUT, 1, CR_UNTRANSLATED, 0.5-ms2,0.15, 1.0, 0.05, 0.05);   //Player number
				HUDMessage (l:"SS_SUCCESS4";
					HUDMSG_FADEOUT, 2, CR_UNTRANSLATED, 0.5+ms2,0.25, 1.0, 0.05, 0.05);   //Player number
			}
			Delay(1);
			if(ms2<=0&&ms2>-0.05)
				{
				If(cgem_count<=6)
					{
					LocalAmbientSound("announcer/ss_complete",255);
					SetFont("SPECSTGF");
						HUDMessage (n:0, s:" ", l:"SS_SUCCESS1";
							HUDMSG_FADEOUT, 1, CR_UNTRANSLATED, 0.5-ms2,0.15, 4.5, 1.0, 1.0);   //Player number
						HUDMessage (l:"SS_SUCCESS2";
							HUDMSG_FADEOUT, 2, CR_UNTRANSLATED, 0.5+ms2,0.25, 4.5, 1.0, 1.0);   //Player number
					}
				Else
					{
					LocalAmbientSound("announcer/ss_gotthemall",255);
					SetFont("SPECSTGF");
						HUDMessage (n:0, s:" ", l:"SS_SUCCESS3";
							HUDMSG_FADEOUT, 1, CR_UNTRANSLATED, 0.5-ms2,0.15, 4.5, 1.0, 1.0);   //Player number
						HUDMessage (l:"SS_SUCCESS4";
							HUDMSG_FADEOUT, 2, CR_UNTRANSLATED, 0.5+ms2,0.25, 4.5, 1.0, 1.0);   //Player number
					}
				}
			}
			Else //If player failed the special stage...
			{
				SetFont("SPECSTGF");
				HUDMessage (n:0, s:" ", l:"SS_FAILED1";
					HUDMSG_FADEOUT, 1, CR_UNTRANSLATED, 0.5-ms2,0.15, 1.0, 0.05, 0.05);   //Player number
				HUDMessage (l:"SS_FAILED2";
					HUDMSG_FADEOUT, 2, CR_UNTRANSLATED, 0.5+ms2,0.25, 1.0, 0.05, 0.05);   //Player number
			Delay(1);
			if(ms2<=0&&ms2>-0.05)
				{
					LocalAmbientSound("announcer/ss_failed",255);
					SetFont("SPECSTGF");
						HUDMessage (n:0, s:" ", l:"SS_FAILED1";
							HUDMSG_FADEOUT, 1, CR_UNTRANSLATED, 0.5-ms2,0.15, 4.5, 1.0, 1.0);   //Player number
						HUDMessage (l:"SS_FAILED2";
							HUDMSG_FADEOUT, 2, CR_UNTRANSLATED, 0.5+ms2,0.25, 4.5, 1.0, 1.0);   //Player number
				}
			}
      }

FadeTo(254,254,254,1.0,0.1);

SetFont("BIG_TEXT");
		ACS_ExecuteAlways(70,0,ACS_NamedExecuteWithResult("GetSSScore",0,0,0,0),0,0);
      HUDMessage (s:"TIME BONUS: ", d:ACS_NamedExecuteWithResult("GetSSScore",0,0,0,0);
		HUDMSG_FADEINOUT, 0, CR_UNTRANSLATED, 0.5,0.7, 4.5,0.75,1.00);   //Player number

			If(cgem_count<=6)
			{
                If(failed==FALSE) { HUDMessage (l:"SS_NEEDMORE1", s:" ", d:7-cgem_count, s:" ", l:"SS_NEEDMORE2";
					HUDMSG_FADEINOUT, 3, CR_UNTRANSLATED, 0.5,0.9, 4.5,0.75,1.00); }	//Player number
                Else { HUDMessage (l:"SS_NEEDFAIL1", s:" ", d:7-cgem_count, s:" ", l:"SS_NEEDFAIL2";
					HUDMSG_FADEINOUT, 3, CR_UNTRANSLATED, 0.5,0.9, 4.5,0.75,1.00); }	//Player number
			}
			Else
			{
			//HUDMessage (n:0, s:" ", s:"CAN NOW BE";
				//HUDMSG_FADEINOUT, 3, CR_UNTRANSLATED, 0.5,0.825, 4.5,0.75,1.00);   //Player number
			HUDMessage (n:0, s:" ", l:"SS_CANTURN", s:" ", n:0, s:"!";
				HUDMSG_FADEINOUT, 3, CR_UNTRANSLATED, 0.5,0.9, 4.5,0.75,1.00);   //Player number
			}
	



    Delay(27);

Delay(200);
FadeTo(255,255,255,100.0,0.75);
Delay(24);
FadeTo(0,0,0,100.0,0.75);
stored_velocity[0] = 616.5;	//Indicate that the player should respawn where they were last in the area.
Delay(24);
ACS_NamedExecute("ExitSpecialStage",0,1,0,0);
}

script "ShowCGemGFX" (void)
{
int cg;
int basepos = 47.5;
int additional = 0;
int add_al = 2;

if(cgem_count>7) cgem_count = 7;	//No ugly big "A"'s on the results screen!

SetHUDSize(240,160,FALSE);

for (int cgems = 1; cgems <= cgem_count; cgems++)
	{
	cg++;
	SetFont(StrParam(s:"CGM", d:cg, s:"A0"));
	HUDMessage (s:"A";
	HUDMSG_FADEINOUT, 0, CR_UNTRANSLATED, basepos-add_al*-cg*9.00,80.0, 4.5, 1.0, 1.0, 1.0);   //Player number
	Delay(1);
	}
	
for (int remainingxs = cg; remainingxs < 7; remainingxs++)
	{
	cg++;
	SetFont("CGEMGFX0");
	HUDMessage (s:"A";
	HUDMSG_FADEINOUT, 0, CR_UNTRANSLATED, basepos-add_al*-cg*9.00,80.0, 4.5, 1.0, 1.0, 1.0);   //Player number
	}
}

////////////////////////////\
//SPECIAL STAGE INTERACTION/|
/////////////////////////////

script "ExitSpecialStage" (int won)
{
	If(won==0)FadeTo(0,0,0,100.0,1.0);
	if(won==0)Delay(35);
	fade = 1;

//The PlayerMovement script never ran here for unknown reasons.

TakeActorInventory(1000,"NoHUD",9);
TakeActorInventory(1001,"NoHUD",9);
TakeActorInventory(1002,"NoHUD",9);
TakeActorInventory(1003,"NoHUD",9);
TakeActorInventory(1004,"NoHUD",9);
TakeActorInventory(1005,"NoHUD",9);
TakeActorInventory(1006,"NoHUD",9);
TakeActorInventory(1007,"NoHUD",9);
TakeActorInventory(1000,"SpecialStageHUDMod",9);
TakeActorInventory(1001,"SpecialStageHUDMod",9);
TakeActorInventory(1002,"SpecialStageHUDMod",9);
TakeActorInventory(1003,"SpecialStageHUDMod",9);
TakeActorInventory(1004,"SpecialStageHUDMod",9);
TakeActorInventory(1005,"SpecialStageHUDMod",9);
TakeActorInventory(1006,"SpecialStageHUDMod",9);
TakeActorInventory(1007,"SpecialStageHUDMod",9);
no_scripts[PlayerNumber()] = FALSE;
SetPlayerProperty(1,OFF,PROP_TOTALLYFROZEN);
ChangeLevel(StrParam(s:"AREA", d:ss_returnlevel+1),0,CHANGELEVEL_NOINTERMISSION|CHANGELEVEL_PRERAISEWEAPON, GameSkill());	//Return the player to the level they left; They keep the monsters/items/secrets percentages when they return.
}

script "RunSeamlessHelper" RETURN { ACS_NamedExecuteAlways("SeamlessHelper",0,FALSE,0,0); }	//Seamless helper has to be run any time a level loads or the player may be left "in the darkness"...
script "InitialSeamlessHelper" ENTER { level_ready = FALSE; ACS_NamedExecuteAlways("SeamlessHelper",0,TRUE,0,0); }
script "SeamlessHelper" (int initial_load)	//If initial_load is set, an additional waiting time will be added for culling.
{
	ACS_NamedExecuteAlways("SuperFormCheck",0,0,0,0);	//Always check for super forms, regardless of where the player is.
	If(ACS_NamedExecuteWithResult("CheckSpecialStage",0,0,0,0)==TRUE) { Log(s:"This code's running, problem solved."); fadeout = 5; Delay(2); SetActorPosition(1000+PlayerNumber(), GetActorX(1100+PlayerNumber()), GetActorY(1100+PlayerNumber()), GetActorZ(1100+PlayerNumber()), FALSE); SetActorAngle(1000+PlayerNumber(), GetActorAngle(1100+PlayerNumber())); /*ACS_NamedExecuteAlways("GiveWeapons",0,0,0,0);*/ Delay(2); }	//This really should be identical to what's below but I'm nervous about breaking this thing.
	Else { fadeout = 4;
	
	Delay(2);
	
	If(stored_velocity[0]==-616.5) { ss_position = 3; ACS_NamedExecuteAlways("SmallTitle",0,1,0,0); Line_SetBlocking(3, BLOCKF_PLAYERS, 0); }	//This is a hack to make sure the ss_position for the Small Hut is set when necessary!
	Else ACS_NamedExecuteAlways("TitleCard",0,0,0,0);	//This will run most of the time, but when returning to the hut, the above line runs.
	
	If(IsTIDUsed(1100+(8*(ss_position))+PlayerNumber())==FALSE) { ss_position = 0; }	//If the place the player's being teleported to doesn't exist, send them to the standard starting position.
	
	If(stored_velocity[0]==616.5) { For(int temp_settpflag = 0; temp_settpflag<PlayerCount()+1; temp_settpflag++) { tp_to_last_ground_position[temp_settpflag] = TRUE; } stored_velocity[0] = 0; tp_to_last_ground_position[PlayerNumber()] = TRUE; ss_position = 0; checkpoint_id[PlayerNumber()] = abs(ss_return_id); ss_return_id = 0; ACS_NamedExecuteAlways("LoadCheckpointInfo",0,FALSE,0,0); }	//Hack that reloads the player's info in the level they were in.
	Else
	{
		SetActorPosition(1000+PlayerNumber(), GetActorX(1100+(8*(ss_position))+PlayerNumber()), GetActorY(1100+(8*(ss_position))+PlayerNumber()), GetActorZ(1100+(8*(ss_position))+PlayerNumber()), FALSE);
		SetActorAngle(1000+PlayerNumber(), GetActorAngle(1100+(8*(ss_position))+PlayerNumber()));
	}
	if(IsTIDUsed(1995)&&PlayerClass(0)==CHAR_XANE&&GameType()!=GAME_NET_COOPERATIVE&&GameType()!=GAME_NET_DEATHMATCH)
	{	//If this is singleplayer and the player is Xane, start them at a different place, a'la Knuckles in the classic Sonic games.
		SetActorPosition(1000,GetActorX(1995),GetActorY(1995),GetActorZ(1995),FALSE);
		SetActorAngle(1000,GetActorAngle(1995));
	}
	if(GetCVAR("debug_spawn")==TRUE&&IsTIDUsed(1149)&&GameType()!=GAME_NET_COOPERATIVE)
	{	//If this is singleplayer and the player is Xane, start them at a different place, a'la Knuckles in the classic Sonic games.
		SetActorPosition(1000,GetActorX(1149),GetActorY(1149),GetActorZ(1149),FALSE);
		SetActorAngle(1000,GetActorAngle(1149));
	} }
	
	//After spawning the player at the correct spawn point, await the culling polyobject if necessary.
	If(initial_load!=0) ACS_NamedExecute("WaitForCulling",0,-1,0,0);
	Else { level_ready = TRUE; }	//If culling isn't on, signal it's safe to assume the level is ready now.
	
	//SuperX check was here.
}

script "WaitForCulling" (int culltics, int cullfade)
{
	If(GetCVar("xane_rculling")!=FALSE&&GameType()==GAME_SINGLE_PLAYER)
	{	//First, do some sanity checks.
		If(culltics<-1||culltics==0||culltics>3) { Log(s:"ERROR: Valid wait times are 1-3.\nSee WaitForCulling call."); Terminate; }
		If(cullfade<0||cullfade>1) { Log(s:"ERROR: Invalid fade for culling. Valid values are 0-1.\nSee WaitForCulling call."); Terminate; }
		
		fadeout = 6+cullfade;	//This will be either a black or white fade out.
		ACS_NamedExecuteAlways("PlayerMovement",0,TRUE,FALSE,FALSE);	//This only freezes the activator, which should be player 1.
		GiveInventory("Variable5",1);	//Variable5 makes players phase through everything.
		GiveInventory("Cutscene",1);	//Freeze everything during the video.

		SetFont("3DLETTER");
		HUDMessage (l:"TXT_LOADING";
			HUDMSG_FADEINOUT, 5, CR_UNTRANSLATED, 0.5,0.5, 3.0, 0.33, 0.33);   //Loading text.

		level_ready = FALSE;	//Make the render-culling polyobject speed up temporarily.
		If(culltics==1)Delay(35);	//Wait for the set time before unlocking the player.
		Else If(culltics==2)Delay(70);
		Else If(culltics==3)Delay(100);		
		Else If(ACS_NamedExecuteWithResult("CheckSpecialStage",0,0,0,0)==FALSE) Delay(100); Else Delay(35);	//-1 will use the original SeamlessHelper values.
		
		HUDMessage (l:"TXT_LOADING";
			HUDMSG_FADEOUT, 5, CR_UNTRANSLATED, 0.5,0.5, 0.0, 0.33);   //Loading text.
		
		TakeInventory("PowerTimeFreezer",1);
		fadeout = 8+cullfade;	//This will be either a black or white fade in.
		TakeInventory("Variable5",1);
		ACS_NamedExecuteAlways("PlayerMovement",0,FALSE,FALSE,FALSE);
		level_ready = TRUE;	//Signal it's safe to resume the level now, which will make the screen fade in.
	}
	Else { level_ready = TRUE; }	//If in multiplayer or culling is disabled, indicate the level is "ready" to prevent an infinite black/white screen.
}

script "SuperFormCheck" (void)
{
	If(ss_position==0)
	{
		ss_position = 0;
		
		/*If(CheckInventory("SuperX")==TRUE)	//If the player is visiting a new level and is transformed, make sure they turn back into their transformed forms!
		{
			If(PlayerClass(PlayerNumber())==CHAR_MARY) MorphActor(1000, "Remove meh", "", 32767, MRF_NEWTIDBEHAVIOUR|MRF_UNDOBYDEATHFORCED, "", "");	//Magical Cutie Mary
			Else If(PlayerClass(PlayerNumber())==CHAR_XANE) MorphActor(1000, "Remove meh", "", 32767, MRF_NEWTIDBEHAVIOUR|MRF_UNDOBYDEATHFORCED, "", "");	//Magical Cutie Mary						
		}*/
		//Log(d:GetLevelInfo(LEVELINFO_LEVELNUM), s:"/", d:gamemode);
		//If(GetLevelInfo(LEVELINFO_LEVELNUM)!=0) stored_velocity[0] = 0;
		If(gamemode>0&&GetLevelInfo(LEVELINFO_LEVELNUM)==0) stored_velocity[0] = -616.5;
	}
}

script "HandleRCulling" ENTER
//Polyobjects:
//11&12: ~3000
//13&14: ~4096
{
	If(GetCVAR("xane_rculling")>2||GetCVAR("xane_rculling")<0) SetCVAR("xane_rculling",0);	//Disable culling if the CVAR is set to an invalid value..
	int last_cull_setting = GetCVar("xane_rculling");
	If(GameType()!=GAME_SINGLE_PLAYER||last_cull_setting<=0) Terminate;
	Else Delay(3);

	While(1)	//Begin moving the polyobject in hopes it reaches the player in time.
	{
		If(level_ready==TRUE)	//After the initial movement (which takes two seconds to be safe).
		{
			Polyobj_MoveToSpot(9+(last_cull_setting*2), 256, 1000);
			Polyobj_MoveToSpot(9+(last_cull_setting*2)+1, 256, 1000);
		}
		Else
		{
			Polyobj_MoveToSpot(9+(last_cull_setting*2), 4096, 1000);
			Polyobj_MoveToSpot(9+(last_cull_setting*2)+1, 4096, 1000);
		}
		Delay(1);
	}
}

script "HandleFadeOut" ENTER
{
	While(1)
	{
		If(fadeout>0)
		{
			important_fade[PlayerNumber()] = TRUE;	//These are important fades.
			Switch(fadeout)
			{
				Case 1:	//Black
				FadeTo(0,0,0,100.0,1.0);
				Break;
				Case 2:	//White
				FadeTo(255,255,255,100.0,1.0);
				Break;
				Case 3:	//Game over FMV
				SetPlayerProperty(TRUE,ON,PROP_TOTALLYFROZEN);
				SetPlayerProperty(TRUE,ON,PROP_FLIGHT);
				SetActorVelocity(GetCurrentPlayerTID(),0.01,0.01,1,FALSE,FALSE);
				ACS_NamedExecuteAlways("PlayFMV",0,1,209,0);
				Break;
				Case 4: //Black fade-in
				FadeTo(0,0,0,1.0,0.0);
				Until(level_ready==TRUE) { Delay(1); FadeTo(0,0,0,1.0,0.0); }
				Delay(17);
				FadeTo(0,0,0,0.0,1.0);
				Break;
				Case 5: //White fade-in
				FadeTo(255,255,255,1.0,0.0);
				Until(level_ready==TRUE) { Delay(1); FadeTo(255,255,255,1.0,0.0); }
				Delay(17);
				FadeTo(255,255,255,0.0,1.0);
				Break;
				Case 6: //Quick black fade-out
				FadeTo(0,0,0,1.0,0.33);
				Break;
				Case 7: //Quick white fade-out
				FadeTo(255,255,255,1.0,0.33);
				Break;
				Case 8: //Quick black fade-in
				FadeTo(0,0,0,1.0,0.0);
				Until(level_ready==TRUE) { Delay(1); FadeTo(0,0,0,1.0,0.0); }
				Delay(1);
				FadeTo(0,0,0,0.0,0.33);
				Break;
				Case 9: //Quick white fade-in
				FadeTo(255,255,255,1.0,0.0);
				Until(level_ready==TRUE) { Delay(1); FadeTo(255,255,255,1.0,0.0); }
				Delay(1);
				FadeTo(255,255,255,0.0,0.33 );
				Break;
				Default:
				Log(s:"INVALID FADE '", d:fadeout, s:"'!");
				Break;
			}
			fadeout = 0;
			important_fade[PlayerNumber()] = FALSE;	//Allow Powerup Coins to tint the screen again.
		}
		
		Delay(1);
	}
}

script "AddCGem" (void) { cgem_count++; }

script "SSEnter" (int return_position_id, int id_special, int respawn_point)
{
If(cgem_count<7)
	{
		If(special_id[id_special]==TRUE) { Print(l:"TXT_SS_FOUND"); Terminate; }
		no_scripts[0] = TRUE;
		no_scripts[1] = TRUE;
		no_scripts[2] = TRUE;
		no_scripts[3] = TRUE;
		no_scripts[4] = TRUE;
		no_scripts[5] = TRUE;
		no_scripts[6] = TRUE;
		no_scripts[7] = TRUE;
		SetPlayerProperty(0,ON,PROP_TOTALLYFROZEN);
		ss_position = return_position_id;
		special_id[id_special] = TRUE;	//Prevent revisiting this Special Stage in the future.
		important_fade[PlayerNumber()] = TRUE;
		ACS_NamedExecute("SSEntryTransition",0,0,0,0);
		entering_ss = 50;
		//fadeout = 2;
		ss_returnlevel = GetLevelInfo(LEVELINFO_LEVELNUM);	//Indicate what level to return to to prevent the strange 1-2 glitch.
		
		SetFont("SPECSTGF");
		
		for (int ms = -0.5; ms < 0; ms += 0.1)
		{
			HUDMessage (s:"SPECIAL STAGE";
				HUDMSG_FADEOUT, 89, CR_UNTRANSLATED, 0.5-ms,0.5, 0.001, 0.001, 0.001);   //Player number
			
			if(ms<=0&&ms>-0.05)
			{
						HUDMessage (s:"SPECIAL STAGE";
						HUDMSG_FADEOUT, 89, CR_UNTRANSLATED, 0.5-ms,0.5, 3.0, 1.0, 1.0);   //Player number
			}
			Delay(1);
		}
		
		Delay(27);
		walldetected[0] = TRUE;
		walldetected[1] = TRUE;
		walldetected[2] = TRUE;
		walldetected[3] = TRUE;
		walldetected[4] = TRUE;
		walldetected[5] = TRUE;
		walldetected[6] = TRUE;
		walldetected[7] = TRUE;
		Delay(15);
		walldetected[0] = FALSE;
		walldetected[1] = FALSE;
		walldetected[2] = FALSE;
		walldetected[3] = FALSE;
		walldetected[4] = FALSE;
		walldetected[5] = FALSE;
		walldetected[6] = FALSE;
		walldetected[7] = FALSE;
		SetPlayerProperty(0,OFF,PROP_TOTALLYFROZEN);
		ss_return_id = respawn_point;	//Prepare the player's respawn point for when they return to the area afterwards.
		no_scripts[0] = FALSE;
		no_scripts[1] = FALSE;
		no_scripts[2] = FALSE;
		no_scripts[3] = FALSE;
		no_scripts[4] = FALSE;
		no_scripts[5] = FALSE;
		no_scripts[6] = FALSE;
		no_scripts[7] = FALSE;
		Delay(1);
		fade = 2;
		ChangeLevel(StrParam(s:"SPECSTG", d:cgem_count+1),0,CHANGELEVEL_NOINTERMISSION|CHANGELEVEL_PRERAISEWEAPON, GameSkill());
	}
Else
	{
		GiveActorInventory(GetCurrentPlayerTID(),"CoinSP",50);
		Print(s:"50 COINS!\nTRANSFORM USING ", k:"+user1", s:"!"); //Insert "giving hidden ring-like objects for super forms" here.
	}
}

script "SSEntryTransition" (void)
{
	//SetHUDSize(320, 200, FALSE);
	int trans_x = 0.0;
	int hud_number = 90;
	
	While(1)
	{
		For(int trans_anim = 1; trans_anim <= 3; trans_anim++)
		{
			SetFont(StrParam(s:"TRANSPC", d:trans_anim));
			HUDMessage (s:"A";
				HUDMSG_FADEOUT, hud_number, CR_UNTRANSLATED, trans_x,0.5, 6.0, 1.0, 1.0);   //Player number
			Delay(1);
		}
		
		if(trans_x==0.999) Terminate;
		
		if(trans_x<1.0)trans_x += 0.09;
		else trans_x = 0.999;
		hud_number++;
	}
}

script "CoinConversion" ENTER
{
While(1)
	{
	If(cdrop_delay[PlayerNumber()]>0) cdrop_delay[PlayerNumber()]--;
	If(CheckActorInventory(GetCurrentPlayerTID(),"CoinX")>0)
		{ 
		TakeActorInventory(GetCurrentPlayerTID(),"CoinX",1);
		GiveActorInventory(GetCurrentPlayerTID(),"CoinSP",1);
		}
	If(CheckActorInventory(GetCurrentPlayerTID(),"DroppedCoin")>0&&CheckActorInventory(GetCurrentPlayerTID(),"DroppedCoin")<20)
		{
		TakeActorInventory(GetCurrentPlayerTID(),"DroppedCoin",1);
		GiveActorInventory(GetCurrentPlayerTID(),"CoinSP",1);
		}
	If(CheckActorInventory(GetCurrentPlayerTID(),"JuiceBoxA_Spawn")>0) TakeActorInventory(GetCurrentPlayerTID(),"JuiceBoxA_Spawn",1);
	Delay(1);
	}
}

int prevhealth2[MAX_PLAYERS];

script "HandleCoinDrops" ENTER
{
prevhealth2[PlayerNumber()] = GetActorProperty(GetCurrentPlayerTID(),APROP_Health);
While(1)
	{
	prevhealth2[PlayerNumber()] = GetActorProperty(GetCurrentPlayerTID(),APROP_Health);
	Delay(1);
	int coins;
	
	if(GetActorProperty(GetCurrentPlayerTID(),APROP_Health) < prevhealth2[PlayerNumber()])	//Drop coin depending on the character.
		{
		ACS_NamedExecuteAlways("DropCoins",0,(prevhealth2[PlayerNumber()]-GetActorProperty(GetCurrentPlayerTID(),APROP_Health))/2,0,0);
		prevhealth2[PlayerNumber()] = GetActorProperty(GetCurrentPlayerTID(),APROP_Health);
		}

	if(GetActorProperty(GetCurrentPlayerTID(),APROP_Health) > prevhealth2[PlayerNumber()]) prevhealth2[PlayerNumber()] = GetActorProperty(GetCurrentPlayerTID(),APROP_Health);
	}
}

script "DropCoins" (int number)
{
	If(ActivatorTID()>=1000&&ActivatorTID()<=1007)
	{
		if(framecount<10) Terminate;
		if(number<3) Terminate;
		if(number>20) number = 20;
		int angle_divided;

		if(cdrop_delay[PlayerNumber()]>0) Terminate;

		If(CheckInventory("CoinSP")>=3)
		{
			ActivatorSound("droppedcoin/drop",255);
			ActivatorSound("droppedcoin/drop",255);
		}

		cdrop_delay[PlayerNumber()] = 35;
	}
	
	angle_divided = 255 / number;	//This gives the base angle amount which is multiplied later.

	For(int i2 = 0; i2 < number; i2++)
	{
		if(CheckActorClass(0, "LGirlPlayer")==TRUE||CheckActorClass(0, "XanePlayer")==TRUE)
		{
			If(CheckInventory("CoinSP")) { TakeInventory("CoinSP",1); /*total_coins--; totalcointics = CONSTANT_TCOINDISPTICS;*/ }
			Else Terminate;
		}
		if(CheckActorClass(0, "LGirlPlayer")==TRUE||CheckActorClass(0, "XanePlayer")==TRUE) SpawnProjectile(0/*ActivatorTID()*/,"DroppedCoin",angle_divided * i2 + 1,31,37/*Random(26,36),Random(35,40)*/,1.0,0);
		else SpawnProjectile(0/*ActivatorTID()*/,"DroppedCoin",angle_divided * i2 + 1,24,33,1.0,0);
	}

}

script "GetCDropTimer" (int mode)
{
if(mode==0) SetResultValue(cdrop_delay[PlayerNumber()]);
if(mode==1) SetResultValue(CheckWeapon("MaryHammer"));
if(mode==2) SetResultValue(CheckActorInventory(GetCurrentPlayerTID(),"MaryHammer"));
}

script "PlaySoundX" (int number)
{
	Switch(number)
	{
		Case 1:
			PlaySound(GetCurrentPlayerTID(),"misc/jump",CHAN_VOICE,1.0);
		Break;
		Case 2:
			PlaySound(GetCurrentPlayerTID(),"lgirl/double_jump",CHAN_VOICE,1.0);
		Break;
		Case 3:
			PlaySound(GetCurrentPlayerTID(),"lgirl/triple_jump",CHAN_VOICE,1.0);
		Break;
	}
}

script "AutoDoorOpener_Command" (int sid, int reflection, int open_door)
{
	If(reflection>=2)
	{
		If(reflection==2)	//North/south PolyObject door.
		{
			If(open_door)
			{
				Polyobj_Move(sid,24,64,56);	//42
			}
			Else
			{
				Polyobj_Move(sid,24,192,56);
			}
		}
		
		If(reflection==3)	//West/East PolyObject door.
		{
			If(open_door)
			{
				Polyobj_Move(sid,24,128,56);
			}
			Else
			{
				Polyobj_Move(sid,24,0,56);
			}
		}
		
		If(reflection==4)	//Counter-clockwise rotating door.
		{
			If(open_door)
			{
				Polyobj_OR_RotateLeft(sid, 24, 85);
			}
			Else
			{
				Polyobj_OR_RotateRight(sid, 24, 85);
			}
		}
		If(reflection==5)	//Dynamic Lights (thing activate/deactivate)
		{
			If(open_door)
			{
				Thing_Activate(sid);
			}
			Else
			{
				Thing_Deactivate(sid);
			}
		}
	}
	Else
	{
		If(open_door)
		{
			Door_Open(sid, 32, 0);
			If(reflection==1) Floor_LowerByValue(sid, 32, 124);
		}
		Else
		{
			Door_Close(sid, 32, 0);
			If(reflection==1) Floor_RaiseByValue(sid, 32, 124);
		}
	}
}