#library "xglobal"
#include "zcommon.acs"


//WORLD variables are only valid until the next level. Special Stages and the Small Hut don't reset them. Use these to let level scripts interact with global script variables.
world int 5:ss_returnlevel;	//What level to return to on request by certain scripts.
world int 8:framecount;	//Current frame; Use for waiting for certain frames to do something.

world bool 9:level_ready;	//This prevents certain scripts from working until it's set to TRUE by SeamlessHelper.

world int 10:ss_return_id;	//The checkpoint ID that the player will respawn from upon returning from a special stage.

//GLOBAL variables are always valid, no matter how many levels the player goes through.
global bool 0:initial_setup;	//Some things only happen upon starting a game and never any other time. This prevents it from happening on every level.
global bool 6:fade;	//Requested fade upon level transition.
global int 8:curscore[];

//Global variable #14 is available.

global int 15:combo[];	//Current combo (successive kills). First MAX_PLAYERS is current, while second are decrease amounts.

global bool 19:challenge_status[];	//Indicates if a challenge for a level is completed, marking it in the interface when selecting levels. There's only one per level, so each index is the level number - 1.

global int 20:level[];	//Level number; [0] is highest level reached, [1] is last level played, and [2] is the last #-1 (start of world) level visited (used for Game Over script).

global bool 22:no_scripts[];	//Tells most standard scripts like special abilities not to run.
global int 25:gamemode;	//0: Normal, 1: Time attack, 2: Boss rush, 3: Practice

//These four variables below are mainly used in this file (hopefully).
world int 14:time_override;	//If set, this will either force a stormy appearance or disable sky/fog changes, allowing levels to use their own settings. 1: Change to stormy appearance, 2: Disable automatic time of day changes, 
world int 15:time_settings;	//This determines which arrays will be used when setting the sky appearance, sector/fade colors, and brightness levels. The stormy weather above overrides this.
world bool 16:time_safe;	//If the sky cannot be seen in the area the player's in, set this to TRUE and the time of day will advance mid-level.

//The world variable below determines what will happen if the time cycle system is disabled on the current level.
//Set this array's contents at the start of every level in the script where skybox and title card settings are set.
//Naturally as the time-of-day system doesn't work on Special Stages, these won't work there even if forced.
//
//[0] - This determines if the time-of-day system should still apply the appearance of a certain time (specified in [1])
//		using the settings specified in time_settings' selected arrays. If 0, the level's built-in lighting is used.
//		Naturally, if "time_override" is set to 1, the stormy weather will be used for this.
//[1] - This variable chooses what time of day this level is canonically supposed to take place at, which time_of_day
//		is set to if the system is disabled, for use with the "to next sunset/sunrise" script.
world int 17:time_defaults[];

global int 12:time_seconds;	//This counts how many seconds the current time of day has been enabled. If it goes over a certain number, time of day will advance upon changing levels/entering an "indoor" location.
global int 13:time_of_day;	//This keeps track of which time of day it currently is. 1: Day, 2: Sunset, 3: Night, 4: Sunrise. This is always updated like the seconds even if overridden.

#define TIME_LENGTH 90	//How long a part of the day lasts. Sunsets and sunrises are half of this.
#define TIME_SUNSET_DIVIDE 3	//How much of TIME_LENGTH is a sunset/sunrise.
#define TIME_STORMFOG_CHANGE 24	//How much the fog distance varies during a storm depending on the time of day.
//Sector tag 183 is used for outdoor sectors that use the fog/fade colors specified below. 184 is used for non-foggy ones. Obviously the latter will only be used on 1-1's land areas.

script "ApplyTODSettings" (void)	//This script will change the appearance of the current area when called.
{
	//First, let's specify all of the settings. The last values for each are for stormy weather (time_override = 1).
	//The first two arrays are first filler zeroes then RGB values/desaturation for each time of day.
	//The third array is for brightness levels/fog distances at those times. There's no filler in this one!
	//The fourth array contains filler then each group of two names are for the two sky layers for the four times.
	
	//SETTINGS #0: Hell City
	int sectorcolors0[24] = { 0, 0, 0, 0,
		236, 248, 255, 0,		//Day
		255, 216, 192, 32,		//Sunset
		128, 192, 255, 0,		//Night
		255, 224, 208, 64,		//Sunrise
		172, 182, 206, 96 };	//Stormy
	int fadecolors0[19] = { 0, 0, 0,
		144, 192, 255,	//Day
		226, 160, 112,	//Sunset
		0, 0, 8,		//Night
		226, 167, 167,	//Sunrise
		45, 60, 77 };	//Stormy
	int brightness0[5] = { 236, 240, 200, 240, 192 };
	str skytexture0[12] = { "", "",
		"SKYOVLS1", "WOKSKY01",
		"SKYOVLS2", "WOKSKY02",
		"WOKSKY04", "WOKSKY04",
		"SKYOVLS2", "WOKSKY13",
		"SKYOVLS4", "STORM_01"};
	
	If(ACS_NamedExecuteWithResult("CheckSpecialStage",0,0,0,0)==TRUE) Terminate;	//Don't run in Special Stages!
	
	If(time_of_day != TIME_NIGHT)
	{	//It if isn't night, change the building textures to their daytime counterparts.
		ReplaceTextures("CITYBNIT", "CITYWIND");		
	}
	Else
	{	//Otherwise, change the daytime textures to fit night better in the city.
		ReplaceTextures("CITYWIND", "CITYBNIT");		
	}
	
	If(time_override==0)
	{	//The settings in this section are for the four normal times of day, daytime, sunset, night, and sunrise.
		Switch(time_settings)
		{
			Case 0:	//Hell City
			Light_Fade(183, brightness0[time_of_day-1],70);	//Tag sectors with 183 to use the TOD system's settings.
			
			//Sectors with fog enabled (tag 183)
			Sector_SetColor(183, sectorcolors0[4*time_of_day], sectorcolors0[(4*time_of_day)+1], sectorcolors0[(4*time_of_day)+2], sectorcolors0[(4*time_of_day)+3]);
			Sector_SetFade(183, fadecolors0[3*time_of_day], fadecolors0[(3*time_of_day)+1], fadecolors0[(3*time_of_day)+2]);
			
			ChangeSky(skytexture0[2*time_of_day], skytexture0[(2*time_of_day)+1]);
		}
	}
	Else If(time_override==1)
	{	//This is used for if it's raining. Using the other override mode, 2, will result in no code running.
		Switch(time_settings)
		{
			Case 0:	//Hell City
			If(time_of_day==TIME_DAY) Light_Fade(183, brightness0[4]+TIME_STORMFOG_CHANGE,70);
			Else If(time_of_day==TIME_NIGHT) Light_Fade(183, brightness0[4]-TIME_STORMFOG_CHANGE,70);
			Else Light_Fade(183, brightness0[4],70);
			
			//Sectors with fog enabled (tag 183)
			Sector_SetColor(183, sectorcolors0[20], sectorcolors0[21], sectorcolors0[22], sectorcolors0[23]);
			Sector_SetFade(183, fadecolors0[15], fadecolors0[16], fadecolors0[17]);
			
			ChangeSky(skytexture0[10], skytexture0[11]);
		}
	}
}

script "TOD_Timer" OPEN
{
	If(ACS_NamedExecuteWithResult("CheckSpecialStage",0,0,0,0)==TRUE) Terminate;	//Don't run in Special Stages!
	Delay(2);	//Wait for level variables to be prepared in case this level wants these scripts to set up lighting...
	If(time_defaults[1]<=0||time_defaults[1]>4) time_defaults[1] = 1;	//If invalid, the time of day is daytime.
	If(initial_setup==FALSE||GetCVAR("xane_timecycle")==FALSE) time_of_day = time_defaults[1];	//If starting a game, set the time to its default.
	If(GetCVAR("xane_timecycle")==FALSE)
	{
		If(time_defaults[0]>0)	//Disabled? If settings are set correctly, handle them before terminating this script.
		{
			time_of_day = time_defaults[1];	//Set the current "time" to the default time before running the script.
			ACS_NamedExecuteAlways("ApplyTODSettings",0,0,0,0);	//Run the script to set the environment's settings!
		}
		//Terminate;	//Sadly, this is where this script must stop running...
	}	//Let the script always run, even if this system is disabled. Just don't let time advance naturally and don't
		//forcibly apply time settings if not specified by the level itself.
	//First, let's do some checks, no matter how redundant with the code below.
	If(time_of_day<=0||time_of_day>4) time_of_day = 1;	//If it's an invalid time of day, set it to daytime.
	If(ACS_NamedExecuteWithResult("TimeSectionSecondsComplete",0,0,0,0))
	{
		if(time_of_day % 2 == 1) time_seconds -= TIME_LENGTH;
		else { time_seconds -= TIME_LENGTH/TIME_SUNSET_DIVIDE; }
		if(time_seconds > TIME_LENGTH * 2) time_seconds = TIME_LENGTH/2;
		//time_seconds = 0;
		time_of_day++;
		If(time_of_day>4) time_of_day = 1;	//If it's sunrise, it's logically daytime next!
	}
	
	//After that, apply the settings forcibly, but only if the system is really enabled.
	If(GetCVAR("xane_timecycle")==TRUE) ACS_NamedExecuteAlways("ApplyTODSettings",0,0,0,0);
	
	int old_override = time_override;	//Set these variables so the moment one changes the settings can be re-applied.
	int old_settings = time_settings;
	
	While(GetCVAR("xane_timecycle")==TRUE)	//If the player ever turns off this system, stop working.
	{
		If(framecount % 35 == 0 && GetCVAR("xane_timecycle") == TRUE) { time_seconds++; /*Print(s:"Seconds into current time phase:\n", d:time_seconds);*/ }
		
		old_override = time_override;	//Update the setting variables to monitor if they change next tic.
		old_settings = time_settings;
		
		Delay(1);
		
		If(GetCVAR("xane_timecycle")==FALSE || (ACS_NamedExecuteWithResult("TimeSectionSecondsComplete",0,0,0,0) && time_safe==TRUE) || time_settings != old_settings || time_override != old_override)
		{	//If the timer went over the limit or a setting was changed and it's safe, change the appearance of the area.
			If(ACS_NamedExecuteWithResult("TimeSectionSecondsComplete",0,0,0,0))
			{	//If the timer is over the limit, reset it while we're at it.
				if(time_of_day % 2 == 1) time_seconds -= TIME_LENGTH;
				else { time_seconds -= TIME_LENGTH/TIME_SUNSET_DIVIDE; }
				if(time_seconds > TIME_LENGTH * 2) time_seconds = TIME_LENGTH/2;
				//time_seconds = 0;
				time_of_day++;
				If(time_of_day>4) time_of_day = 1;	//If it's sunrise, it's logically daytime next!
			}
			ACS_NamedExecuteAlways("ApplyTODSettings",0,0,0,0);
			//Print(s:"Time is now ", d:time_of_day, s:"!");
		}
	}
}

script "TimeSectionSecondsComplete" (void)
{	//This returns TRUE if the seconds counter for the time-of-day system has gone over the point where it normally changes times of day.
	If((time_of_day % 2 == 1 && time_seconds>=TIME_LENGTH) || (time_of_day % 2 == 0 && time_seconds>TIME_LENGTH/TIME_SUNSET_DIVIDE)) SetResultValue(TRUE);
	Else SetResultValue(FALSE);
}

script "AdvanceNearestSunTime" (void)
{	//This script advances time to the next sunset/sunrise. If it's already that time, this does nothing.
	If(time_of_day % 2 == 1) { time_seconds = TIME_LENGTH; }//If it's day or night, set up a time change.
}

script "TimeSafeBoundary" (void)
{	//This toggles the "safe to change time of day" variable upon crossing it.
	If(GetCVAR("xane_timecycle")==FALSE) Terminate;	//Don't care about how safe it is if the system is disabled.
	If(LineSide()==LINE_FRONT) time_safe = TRUE;
	Else time_safe = FALSE;
}

script "td" (int mode)
{
	If(mode==FALSE)
	{
		time_safe = !time_safe;
		If(time_safe) Log(s:"Time will now advance.");
		Else Log(s:"Time cycling is now disabled.");
	}
	Else time_seconds = TIME_LENGTH;
}